'\" t
.\" Automatically generated by Pandoc 2.18
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "LLVM Language Reference Manual" "" "" "" ""
.hy
.SH Abstract
.PP
This document is a reference manual for the LLVM assembly language.
LLVM is a Static Single Assignment (SSA) based representation that
provides type safety, low-level operations, flexibility, and the
capability of representing \[aq]all\[aq] high-level languages cleanly.
It is the common code representation used throughout all phases of the
LLVM compilation strategy.
.SH Introduction
.PP
The LLVM code representation is designed to be used in three different
forms: as an in-memory compiler IR, as an on-disk bitcode representation
(suitable for fast loading by a Just-In-Time compiler), and as a human
readable assembly language representation.
This allows LLVM to provide a powerful intermediate representation for
efficient compiler transformations and analysis, while providing a
natural means to debug and visualize the transformations.
The three different forms of LLVM are all equivalent.
This document describes the human readable representation and notation.
.PP
The LLVM representation aims to be light-weight and low-level while
being expressive, typed, and extensible at the same time.
It aims to be a \[dq]universal IR\[dq] of sorts, by being at a low
enough level that high-level ideas may be cleanly mapped to it (similar
to how microprocessors are \[dq]universal IR\[aq]s\[dq], allowing many
source languages to be mapped to them).
By providing type information, LLVM can be used as the target of
optimizations: for example, through pointer analysis, it can be proven
that a C automatic variable is never accessed outside of the current
function, allowing it to be promoted to a simple SSA value instead of a
memory location.
.SS Well-Formedness
.PP
It is important to note that this document describes \[aq]well
formed\[aq] LLVM assembly language.
There is a difference between what the parser accepts and what is
considered \[aq]well formed\[aq].
For example, the following instruction is syntactically okay, but not
well formed:
.IP
.nf
\f[C]
%x = add i32 1, %x
\f[R]
.fi
.PP
because the definition of \f[V]%x\f[R] does not dominate all of its
uses.
The LLVM infrastructure provides a verification pass that may be used to
verify that an LLVM module is well formed.
This pass is automatically run by the parser after parsing input
assembly and by the optimizer before it outputs bitcode.
The violations pointed out by the verifier pass indicate bugs in
transformation passes or input to the parser.
.SH Identifiers
.PP
LLVM identifiers come in two basic types: global and local.
Global identifiers (functions, global variables) begin with the
\f[V]\[aq]\[at]\[aq]\f[R] character.
Local identifiers (register names, types) begin with the
\f[V]\[aq]%\[aq]\f[R] character.
Additionally, there are three different formats for identifiers, for
different purposes:
.IP "1." 3
Named values are represented as a string of characters with their
prefix.
For example, \f[V]%foo\f[R], \f[V]\[at]DivisionByZero\f[R],
\f[V]%a.really.long.identifier\f[R].
The actual regular expression used is
\[aq]\f[V][%\[at]][-a-zA-Z$._][-a-zA-Z$._0-9]*\f[R]\[aq].
Identifiers that require other characters in their names can be
surrounded with quotes.
Special characters may be escaped using \f[V]\[dq]\[rs]xx\[dq]\f[R]
where \f[V]xx\f[R] is the ASCII code for the character in hexadecimal.
In this way, any character can be used in a name value, even quotes
themselves.
The \f[V]\[dq]\[rs]01\[dq]\f[R] prefix can be used on global values to
suppress mangling.
.IP "2." 3
Unnamed values are represented as an unsigned numeric value with their
prefix.
For example, \f[V]%12\f[R], \f[V]\[at]2\f[R], \f[V]%44\f[R].
.IP "3." 3
Constants, which are described in the section Constants below.
.PP
LLVM requires that values start with a prefix for two reasons: Compilers
don\[aq]t need to worry about name clashes with reserved words, and the
set of reserved words may be expanded in the future without penalty.
Additionally, unnamed identifiers allow a compiler to quickly come up
with a temporary variable without having to avoid symbol table
conflicts.
.PP
Reserved words in LLVM are very similar to reserved words in other
languages.
There are keywords for different opcodes (\[aq]\f[V]add\f[R]\[aq],
\[aq]\f[V]bitcast\f[R]\[aq], \[aq]\f[V]ret\f[R]\[aq], etc...), for
primitive type names (\[aq]\f[V]void\f[R]\[aq], \[aq]\f[V]i32\f[R]\[aq],
etc...), and others.
These reserved words cannot conflict with variable names, because none
of them start with a prefix character (\f[V]\[aq]%\[aq]\f[R] or
\f[V]\[aq]\[at]\[aq]\f[R]).
.PP
Here is an example of LLVM code to multiply the integer variable
\[aq]\f[V]%X\f[R]\[aq] by 8:
.PP
The easy way:
.IP
.nf
\f[C]
%result = mul i32 %X, 8
\f[R]
.fi
.PP
After strength reduction:
.IP
.nf
\f[C]
%result = shl i32 %X, 3
\f[R]
.fi
.PP
And the hard way:
.IP
.nf
\f[C]
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
\f[R]
.fi
.PP
This last way of multiplying \f[V]%X\f[R] by 8 illustrates several
important lexical features of LLVM:
.IP "1." 3
Comments are delimited with a \[aq]\f[V];\f[R]\[aq] and go until the end
of line.
.IP "2." 3
Unnamed temporaries are created when the result of a computation is not
assigned to a named value.
.IP "3." 3
Unnamed temporaries are numbered sequentially (using a per-function
incrementing counter, starting with 0).
Note that basic blocks and unnamed function parameters are included in
this numbering.
For example, if the entry basic block is not given a label name and all
function parameters are named, then it will get number 0.
.PP
It also shows a convention that we follow in this document.
When demonstrating instructions, we will follow an instruction with a
comment that defines the type and name of value produced.
.SH High Level Structure
.SS Module Structure
.PP
LLVM programs are composed of \f[V]Module\f[R]\[aq]s, each of which is a
translation unit of the input programs.
Each module consists of functions, global variables, and symbol table
entries.
Modules may be combined together with the LLVM linker, which merges
function (and global variable) definitions, resolves forward
declarations, and merges symbol table entries.
Here is an example of the \[dq]hello world\[dq] module:
.IP
.nf
\f[C]
; Declare the string constant as a global constant.
\[at].str = private unnamed_addr constant [13 x i8] c\[dq]hello world\[rs]0A\[rs]00\[dq]

; External declaration of the puts function
declare i32 \[at]puts(i8* nocapture) nounwind

; Definition of main function
define i32 \[at]main() {   ; i32()*
  ; Convert [13 x i8]* to i8*...
  %cast210 = getelementptr [13 x i8], [13 x i8]* \[at].str, i64 0, i64 0

  ; Call puts function to write out the string to stdout.
  call i32 \[at]puts(i8* %cast210)
  ret i32 0
}

; Named metadata
!0 = !{i32 42, null, !\[dq]string\[dq]}
!foo = !{!0}
\f[R]
.fi
.PP
This example is made up of a \f[V]global variable <globalvars>\f[R]
named \[dq]\f[V].str\f[R]\[dq], an external declaration of the
\[dq]\f[V]puts\f[R]\[dq] function, a
\f[V]function definition <functionstructure>\f[R] for
\[dq]\f[V]main\f[R]\[dq] and
\f[V]named metadata <namedmetadatastructure>\f[R]
\[dq]\f[V]foo\f[R]\[dq].
.PP
In general, a module is made up of a list of global values (where both
functions and global variables are global values).
Global values are represented by a pointer to a memory location (in this
case, a pointer to an array of char, and a pointer to a function), and
have one of the following \f[V]linkage types <linkage>\f[R].
.SS Linkage Types
.PP
All Global Variables and Functions have one of the following types of
linkage:
.TP
\f[V]private\f[R]
Global values with \[dq]\f[V]private\f[R]\[dq] linkage are only directly
accessible by objects in the current module.
In particular, linking code into a module with a private global value
may cause the private to be renamed as necessary to avoid collisions.
Because the symbol is private to the module, all references can be
updated.
This doesn\[aq]t show up in any symbol table in the object file.
.TP
\f[V]internal\f[R]
Similar to private, but the value shows as a local symbol
(\f[V]STB_LOCAL\f[R] in the case of ELF) in the object file.
This corresponds to the notion of the \[aq]\f[V]static\f[R]\[aq] keyword
in C.
.TP
\f[V]available_externally\f[R]
Globals with \[dq]\f[V]available_externally\f[R]\[dq] linkage are never
emitted into the object file corresponding to the LLVM module.
From the linker\[aq]s perspective, an \f[V]available_externally\f[R]
global is equivalent to an external declaration.
They exist to allow inlining and other optimizations to take place given
knowledge of the definition of the global, which is known to be
somewhere outside the module.
Globals with \f[V]available_externally\f[R] linkage are allowed to be
discarded at will, and allow inlining and other optimizations.
This linkage type is only allowed on definitions, not declarations.
.TP
\f[V]linkonce\f[R]
Globals with \[dq]\f[V]linkonce\f[R]\[dq] linkage are merged with other
globals of the same name when linkage occurs.
This can be used to implement some forms of inline functions, templates,
or other code which must be generated in each translation unit that uses
it, but where the body may be overridden with a more definitive
definition later.
Unreferenced \f[V]linkonce\f[R] globals are allowed to be discarded.
Note that \f[V]linkonce\f[R] linkage does not actually allow the
optimizer to inline the body of this function into callers because it
doesn\[aq]t know if this definition of the function is the definitive
definition within the program or whether it will be overridden by a
stronger definition.
To enable inlining and other optimizations, use
\[dq]\f[V]linkonce_odr\f[R]\[dq] linkage.
.TP
\f[V]weak\f[R]
\[dq]\f[V]weak\f[R]\[dq] linkage has the same merging semantics as
\f[V]linkonce\f[R] linkage, except that unreferenced globals with
\f[V]weak\f[R] linkage may not be discarded.
This is used for globals that are declared \[dq]weak\[dq] in C source
code.
.TP
\f[V]common\f[R]
\[dq]\f[V]common\f[R]\[dq] linkage is most similar to
\[dq]\f[V]weak\f[R]\[dq] linkage, but they are used for tentative
definitions in C, such as \[dq]\f[V]int X;\f[R]\[dq] at global scope.
Symbols with \[dq]\f[V]common\f[R]\[dq] linkage are merged in the same
way as \f[V]weak symbols\f[R], and they may not be deleted if
unreferenced.
\f[V]common\f[R] symbols may not have an explicit section, must have a
zero initializer, and may not be marked
\[aq]\f[V]constant <globalvars>\f[R]\[aq].
Functions and aliases may not have common linkage.
.TP
\f[V]appending\f[R]
\[dq]\f[V]appending\f[R]\[dq] linkage may only be applied to global
variables of pointer to array type.
When two global variables with appending linkage are linked together,
the two global arrays are appended together.
This is the LLVM, typesafe, equivalent of having the system linker
append together \[dq]sections\[dq] with identical names when .o files
are linked.
.RS
.PP
Unfortunately this doesn\[aq]t correspond to any feature in .o files, so
it can only be used for variables like \f[V]llvm.global_ctors\f[R] which
llvm interprets specially.
.RE
.TP
\f[V]extern_weak\f[R]
The semantics of this linkage follow the ELF object file model: the
symbol is weak until linked, if not linked, the symbol becomes null
instead of being an undefined reference.
.TP
\f[V]linkonce_odr\f[R], \f[V]weak_odr\f[R]
Some languages allow differing globals to be merged, such as two
functions with different semantics.
Other languages, such as \f[V]C++\f[R], ensure that only equivalent
globals are ever merged (the \[dq]one definition rule\[dq] ---
\[dq]ODR\[dq]).
Such languages can use the \f[V]linkonce_odr\f[R] and \f[V]weak_odr\f[R]
linkage types to indicate that the global will only be merged with
equivalent globals.
These linkage types are otherwise the same as their non-\f[V]odr\f[R]
versions.
.TP
\f[V]external\f[R]
If none of the above identifiers are used, the global is externally
visible, meaning that it participates in linkage and can be used to
resolve external symbol references.
.PP
It is illegal for a global variable or function \f[I]declaration\f[R] to
have any linkage type other than \f[V]external\f[R] or
\f[V]extern_weak\f[R].
.SS Calling Conventions
.PP
LLVM \f[V]functions <functionstructure>\f[R], \f[V]calls <i_call>\f[R]
and \f[V]invokes <i_invoke>\f[R] can all have an optional calling
convention specified for the call.
The calling convention of any pair of dynamic caller/callee must match,
or the behavior of the program is undefined.
The following calling conventions are supported by LLVM, and more may be
added in the future:
.TP
\[dq]\f[V]ccc\f[R]\[dq] - The C calling convention
This calling convention (the default if no other calling convention is
specified) matches the target C calling conventions.
This calling convention supports varargs function calls and tolerates
some mismatch in the declared prototype and implemented declaration of
the function (as does normal C).
.TP
\[dq]\f[V]fastcc\f[R]\[dq] - The fast calling convention
This calling convention attempts to make calls as fast as possible (e.g.
by passing things in registers).
This calling convention allows the target to use whatever tricks it
wants to produce fast code for the target, without having to conform to
an externally specified ABI (Application Binary Interface).
Tail calls can only be optimized when this, the tailcc, the GHC or the
HiPE convention is used.
This calling convention does not support varargs and requires the
prototype of all callees to exactly match the prototype of the function
definition.
.TP
\[dq]\f[V]coldcc\f[R]\[dq] - The cold calling convention
This calling convention attempts to make code in the caller as efficient
as possible under the assumption that the call is not commonly executed.
As such, these calls often preserve all registers so that the call does
not break any live ranges in the caller side.
This calling convention does not support varargs and requires the
prototype of all callees to exactly match the prototype of the function
definition.
Furthermore the inliner doesn\[aq]t consider such function calls for
inlining.
.TP
\[dq]\f[V]cc 10\f[R]\[dq] - GHC convention
This calling convention has been implemented specifically for use by the
Glasgow Haskell Compiler (GHC) (http://www.haskell.org/ghc).
It passes everything in registers, going to extremes to achieve this by
disabling callee save registers.
This calling convention should not be used lightly but only for specific
situations such as an alternative to the \f[I]register pinning\f[R]
performance technique often used when implementing functional
programming languages.
At the moment only X86 supports this convention and it has the following
limitations:
.RS
.IP \[bu] 2
On \f[I]X86-32\f[R] only supports up to 4 bit type parameters.
No floating-point types are supported.
.IP \[bu] 2
On \f[I]X86-64\f[R] only supports up to 10 bit type parameters and 6
floating-point parameters.
.PP
This calling convention supports tail call optimization but requires
both the caller and callee are using it.
.RE
.TP
\[dq]\f[V]cc 11\f[R]\[dq] - The HiPE calling convention
This calling convention has been implemented specifically for use by the
High-Performance Erlang
(HiPE) (http://www.it.uu.se/research/group/hipe/) compiler,
\f[I]the\f[R] native code compiler of the Ericsson\[aq]s Open Source
Erlang/OTP system (http://www.erlang.org/download.shtml).
It uses more registers for argument passing than the ordinary C calling
convention and defines no callee-saved registers.
The calling convention properly supports tail call optimization but
requires that both the caller and the callee use it.
It uses a \f[I]register pinning\f[R] mechanism, similar to GHC\[aq]s
convention, for keeping frequently accessed runtime components pinned to
specific hardware registers.
At the moment only X86 supports this convention (both 32 and 64 bit).
.TP
\[dq]\f[V]webkit_jscc\f[R]\[dq] - WebKit\[aq]s JavaScript calling convention
This calling convention has been implemented for WebKit FTL
JIT (https://trac.webkit.org/wiki/FTLJIT).
It passes arguments on the stack right to left (as cdecl does), and
returns a value in the platform\[aq]s customary return register.
.TP
\[dq]\f[V]anyregcc\f[R]\[dq] - Dynamic calling convention for code patching
This is a special convention that supports patching an arbitrary code
sequence in place of a call site.
This convention forces the call arguments into registers but allows them
to be dynamically allocated.
This can currently only be used with calls to
llvm.experimental.patchpoint because only this intrinsic records the
location of its arguments in a side table.
See \f[V]StackMaps\f[R].
.TP
\[dq]\f[V]preserve_mostcc\f[R]\[dq] - The PreserveMost calling convention
This calling convention attempts to make the code in the caller as
unintrusive as possible.
This convention behaves identically to the C calling convention on how
arguments and return values are passed, but it uses a different set of
caller/callee-saved registers.
This alleviates the burden of saving and recovering a large register set
before and after the call in the caller.
If the arguments are passed in callee-saved registers, then they will be
preserved by the callee across the call.
This doesn\[aq]t apply for values returned in callee-saved registers.
.RS
.IP \[bu] 2
On X86-64 the callee preserves all general purpose registers, except for
R11.
R11 can be used as a scratch register.
Floating-point registers (XMMs/YMMs) are not preserved and need to be
saved by the caller.
.PP
The idea behind this convention is to support calls to runtime functions
that have a hot path and a cold path.
The hot path is usually a small piece of code that doesn\[aq]t use many
registers.
The cold path might need to call out to another function and therefore
only needs to preserve the caller-saved registers, which haven\[aq]t
already been saved by the caller.
The PreserveMost calling convention is very similar to the cold calling
convention in terms of caller/callee-saved registers, but they are used
for different types of function calls.
coldcc is for function calls that are rarely executed, whereas
preserve_mostcc function calls are intended to be on the hot path and
definitely executed a lot.
Furthermore preserve_mostcc doesn\[aq]t prevent the inliner from
inlining the function call.
.PP
This calling convention will be used by a future version of the
ObjectiveC runtime and should therefore still be considered experimental
at this time.
Although this convention was created to optimize certain runtime calls
to the ObjectiveC runtime, it is not limited to this runtime and might
be used by other runtimes in the future too.
The current implementation only supports X86-64, but the intention is to
support more architectures in the future.
.RE
.TP
\[dq]\f[V]preserve_allcc\f[R]\[dq] - The PreserveAll calling convention
This calling convention attempts to make the code in the caller even
less intrusive than the PreserveMost calling convention.
This calling convention also behaves identical to the C calling
convention on how arguments and return values are passed, but it uses a
different set of caller/callee-saved registers.
This removes the burden of saving and recovering a large register set
before and after the call in the caller.
If the arguments are passed in callee-saved registers, then they will be
preserved by the callee across the call.
This doesn\[aq]t apply for values returned in callee-saved registers.
.RS
.IP \[bu] 2
On X86-64 the callee preserves all general purpose registers, except for
R11.
R11 can be used as a scratch register.
Furthermore it also preserves all floating-point registers (XMMs/YMMs).
.PP
The idea behind this convention is to support calls to runtime functions
that don\[aq]t need to call out to any other functions.
.PP
This calling convention, like the PreserveMost calling convention, will
be used by a future version of the ObjectiveC runtime and should be
considered experimental at this time.
.RE
.TP
\[dq]\f[V]cxx_fast_tlscc\f[R]\[dq] - The CXX_FAST_TLS calling convention for access functions
Clang generates an access function to access C++-style TLS.
The access function generally has an entry block, an exit block and an
initialization block that is run at the first time.
The entry and exit blocks can access a few TLS IR variables, each access
will be lowered to a platform-specific sequence.
.RS
.PP
This calling convention aims to minimize overhead in the caller by
preserving as many registers as possible (all the registers that are
preserved on the fast path, composed of the entry and exit blocks).
.PP
This calling convention behaves identical to the C calling convention on
how arguments and return values are passed, but it uses a different set
of caller/callee-saved registers.
.PP
Given that each platform has its own lowering sequence, hence its own
set of preserved registers, we can\[aq]t use the existing PreserveMost.
.IP \[bu] 2
On X86-64 the callee preserves all general purpose registers, except for
RDI and RAX.
.RE
.TP
\[dq]\f[V]tailcc\f[R]\[dq] - Tail callable calling convention
This calling convention ensures that calls in tail position will always
be tail call optimized.
This calling convention is equivalent to fastcc, except for an
additional guarantee that tail calls will be produced whenever possible.
Tail calls can only be optimized when this, the fastcc, the GHC or the
HiPE convention is used.
This calling convention does not support varargs and requires the
prototype of all callees to exactly match the prototype of the function
definition.
.TP
\[dq]\f[V]swiftcc\f[R]\[dq] - This calling convention is used for Swift language.
.IP \[bu] 2
On X86-64 RCX and R8 are available for additional integer returns, and
XMM2 and XMM3 are available for additional FP/vector returns.
.IP \[bu] 2
On iOS platforms, we use AAPCS-VFP calling convention.
.TP
\[dq]\f[V]swifttailcc\f[R]\[dq]
This calling convention is like \f[V]swiftcc\f[R] in most respects, but
also the callee pops the argument area of the stack so that mandatory
tail calls are possible as in \f[V]tailcc\f[R].
.TP
\[dq]\f[V]cfguard_checkcc\f[R]\[dq] - Windows Control Flow Guard (Check mechanism)
This calling convention is used for the Control Flow Guard check
function, calls to which can be inserted before indirect calls to check
that the call target is a valid function address.
The check function has no return value, but it will trigger an OS-level
error if the address is not a valid target.
The set of registers preserved by the check function, and the register
containing the target address are architecture-specific.
.RS
.IP \[bu] 2
On X86 the target address is passed in ECX.
.IP \[bu] 2
On ARM the target address is passed in R0.
.IP \[bu] 2
On AArch64 the target address is passed in X15.
.RE
.TP
\[dq]\f[V]cc <n>\f[R]\[dq] - Numbered convention
Any calling convention may be specified by number, allowing
target-specific calling conventions to be used.
Target specific calling conventions start at 64.
.PP
More calling conventions can be added/defined on an as-needed basis, to
support Pascal conventions or any other well-known target-independent
convention.
.SS Visibility Styles
.PP
All Global Variables and Functions have one of the following visibility
styles:
.TP
\[dq]\f[V]default\f[R]\[dq] - Default style
On targets that use the ELF object file format, default visibility means
that the declaration is visible to other modules and, in shared
libraries, means that the declared entity may be overridden.
On Darwin, default visibility means that the declaration is visible to
other modules.
On XCOFF, default visibility means no explicit visibility bit will be
set and whether the symbol is visible (i.e \[dq]exported\[dq]) to other
modules depends primarily on export lists provided to the linker.
Default visibility corresponds to \[dq]external linkage\[dq] in the
language.
.TP
\[dq]\f[V]hidden\f[R]\[dq] - Hidden style
Two declarations of an object with hidden visibility refer to the same
object if they are in the same shared object.
Usually, hidden visibility indicates that the symbol will not be placed
into the dynamic symbol table, so no other module (executable or shared
library) can reference it directly.
.TP
\[dq]\f[V]protected\f[R]\[dq] - Protected style
On ELF, protected visibility indicates that the symbol will be placed in
the dynamic symbol table, but that references within the defining module
will bind to the local symbol.
That is, the symbol cannot be overridden by another module.
.PP
A symbol with \f[V]internal\f[R] or \f[V]private\f[R] linkage must have
\f[V]default\f[R] visibility.
.SS DLL Storage Classes
.PP
All Global Variables, Functions and Aliases can have one of the
following DLL storage class:
.TP
\f[V]dllimport\f[R]
\[dq]\f[V]dllimport\f[R]\[dq] causes the compiler to reference a
function or variable via a global pointer to a pointer that is set up by
the DLL exporting the symbol.
On Microsoft Windows targets, the pointer name is formed by combining
\f[V]__imp_\f[R] and the function or variable name.
.TP
\f[V]dllexport\f[R]
On Microsoft Windows targets, \[dq]\f[V]dllexport\f[R]\[dq] causes the
compiler to provide a global pointer to a pointer in a DLL, so that it
can be referenced with the \f[V]dllimport\f[R] attribute.
the pointer name is formed by combining \f[V]__imp_\f[R] and the
function or variable name.
On XCOFF targets, \f[V]dllexport\f[R] indicates that the symbol will be
made visible to other modules using \[dq]exported\[dq] visibility and
thus placed by the linker in the loader section symbol table.
Since this storage class exists for defining a dll interface, the
compiler, assembler and linker know it is externally referenced and must
refrain from deleting the symbol.
.SS Thread Local Storage Models
.PP
A variable may be defined as \f[V]thread_local\f[R], which means that it
will not be shared by threads (each thread will have a separated copy of
the variable).
Not all targets support thread-local variables.
Optionally, a TLS model may be specified:
.TP
\f[V]localdynamic\f[R]
For variables that are only used within the current shared library.
.TP
\f[V]initialexec\f[R]
For variables in modules that will not be loaded dynamically.
.TP
\f[V]localexec\f[R]
For variables defined in the executable and only used within it.
.PP
If no explicit model is given, the \[dq]general dynamic\[dq] model is
used.
.PP
The models correspond to the ELF TLS models; see ELF Handling For
Thread-Local Storage (http://people.redhat.com/drepper/tls.pdf) for more
information on under which circumstances the different models may be
used.
The target may choose a different TLS model if the specified model is
not supported, or if a better choice of model can be made.
.PP
A model can also be specified in an alias, but then it only governs how
the alias is accessed.
It will not have any effect in the aliasee.
.PP
For platforms without linker support of ELF TLS model, the
-femulated-tls flag can be used to generate GCC compatible emulated TLS
code.
.SS Runtime Preemption Specifiers
.PP
Global variables, functions and aliases may have an optional runtime
preemption specifier.
If a preemption specifier isn\[aq]t given explicitly, then a symbol is
assumed to be \f[V]dso_preemptable\f[R].
.TP
\f[V]dso_preemptable\f[R]
Indicates that the function or variable may be replaced by a symbol from
outside the linkage unit at runtime.
.TP
\f[V]dso_local\f[R]
The compiler may assume that a function or variable marked as
\f[V]dso_local\f[R] will resolve to a symbol within the same linkage
unit.
Direct access will be generated even if the definition is not within
this compilation unit.
.SS Structure Types
.PP
LLVM IR allows you to specify both \[dq]identified\[dq] and
\[dq]literal\[dq] \f[V]structure
types <t_struct>\f[R].
Literal types are uniqued structurally, but identified types are never
uniqued.
An \f[V]opaque structural type <t_opaque>\f[R] can also be used to
forward declare a type that is not yet available.
.PP
An example of an identified structure specification is:
.IP
.nf
\f[C]
%mytype = type { %mytype*, i32 }
\f[R]
.fi
.PP
Prior to the LLVM 3.0 release, identified types were structurally
uniqued.
Only literal types are uniqued in recent versions of LLVM.
.SS Non-Integral Pointer Type
.PP
Note: non-integral pointer types are a work in progress, and they should
be considered experimental at this time.
.PP
LLVM IR optionally allows the frontend to denote pointers in certain
address spaces as \[dq]non-integral\[dq] via the
\f[V]datalayout string<langref_datalayout>\f[R].
Non-integral pointer types represent pointers that have an
\f[I]unspecified\f[R] bitwise representation; that is, the integral
representation may be target dependent or unstable (not backed by a
fixed integer).
.PP
\f[V]inttoptr\f[R] and \f[V]ptrtoint\f[R] instructions have the same
semantics as for integral (i.e.
normal) pointers in that they convert integers to and from corresponding
pointer types, but there are additional implications to be aware of.
Because the bit-representation of a non-integral pointer may not be
stable, two identical casts of the same operand may or may not return
the same value.
Said differently, the conversion to or from the non-integral type
depends on environmental state in an implementation defined manner.
.PP
If the frontend wishes to observe a \f[I]particular\f[R] value following
a cast, the generated IR must fence with the underlying environment in
an implementation defined manner.
(In practice, this tends to require \f[V]noinline\f[R] routines for such
operations.)
.PP
From the perspective of the optimizer, \f[V]inttoptr\f[R] and
\f[V]ptrtoint\f[R] for non-integral types are analogous to ones on
integral types with one key exception: the optimizer may not, in
general, insert new dynamic occurrences of such casts.
If a new cast is inserted, the optimizer would need to either ensure
that a) all possible values are valid, or b) appropriate fencing is
inserted.
Since the appropriate fencing is implementation defined, the optimizer
can\[aq]t do the latter.
The former is challenging as many commonly expected properties, such as
\f[V]ptrtoint(v)-ptrtoint(v) == 0\f[R], don\[aq]t hold for non-integral
types.
.SS Global Variables
.PP
Global variables define regions of memory allocated at compilation time
instead of run-time.
.PP
Global variable definitions must be initialized.
.PP
Global variables in other translation units can also be declared, in
which case they don\[aq]t have an initializer.
.PP
Global variables can optionally specify a
\f[V]linkage type <linkage>\f[R].
.PP
Either global variable definitions or declarations may have an explicit
section to be placed in and may have an optional explicit alignment
specified.
If there is a mismatch between the explicit or inferred section
information for the variable declaration and its definition the
resulting behavior is undefined.
.PP
A variable may be defined as a global \f[V]constant\f[R], which
indicates that the contents of the variable will \f[B]never\f[R] be
modified (enabling better optimization, allowing the global data to be
placed in the read-only section of an executable, etc).
Note that variables that need runtime initialization cannot be marked
\f[V]constant\f[R] as there is a store to the variable.
.PP
LLVM explicitly allows \f[I]declarations\f[R] of global variables to be
marked constant, even if the final definition of the global is not.
This capability can be used to enable slightly better optimization of
the program, but requires the language definition to guarantee that
optimizations based on the \[aq]constantness\[aq] are valid for the
translation units that do not include the definition.
.PP
As SSA values, global variables define pointer values that are in scope
(i.e.
they dominate) all basic blocks in the program.
Global variables always define a pointer to their \[dq]content\[dq] type
because they describe a region of memory, and all memory objects in LLVM
are accessed through pointers.
.PP
Global variables can be marked with \f[V]unnamed_addr\f[R] which
indicates that the address is not significant, only the content.
Constants marked like this can be merged with other constants if they
have the same initializer.
Note that a constant with significant address \f[I]can\f[R] be merged
with a \f[V]unnamed_addr\f[R] constant, the result being a constant
whose address is significant.
.PP
If the \f[V]local_unnamed_addr\f[R] attribute is given, the address is
known to not be significant within the module.
.PP
A global variable may be declared to reside in a target-specific
numbered address space.
For targets that support them, address spaces may affect how
optimizations are performed and/or what target instructions are used to
access the variable.
The default address space is zero.
The address space qualifier must precede any other attributes.
.PP
LLVM allows an explicit section to be specified for globals.
If the target supports it, it will emit globals to the section
specified.
Additionally, the global can placed in a comdat if the target has the
necessary support.
.PP
External declarations may have an explicit section specified.
Section information is retained in LLVM IR for targets that make use of
this information.
Attaching section information to an external declaration is an assertion
that its definition is located in the specified section.
If the definition is located in a different section, the behavior is
undefined.
.PP
By default, global initializers are optimized by assuming that global
variables defined within the module are not modified from their initial
values before the start of the global initializer.
This is true even for variables potentially accessible from outside the
module, including those with external linkage or appearing in
\f[V]\[at]llvm.used\f[R] or dllexported variables.
This assumption may be suppressed by marking the variable with
\f[V]externally_initialized\f[R].
.PP
An explicit alignment may be specified for a global, which must be a
power of 2.
If not present, or if the alignment is set to zero, the alignment of the
global is set by the target to whatever it feels convenient.
If an explicit alignment is specified, the global is forced to have
exactly that alignment.
Targets and optimizers are not allowed to over-align the global if the
global has an assigned section.
In this case, the extra alignment could be observable: for example, code
could assume that the globals are densely packed in their section and
try to iterate over them as an array, alignment padding would break this
iteration.
The maximum alignment is \f[V]1 << 32\f[R].
.PP
For global variables declarations, as well as definitions that may be
replaced at link time (\f[V]linkonce\f[R], \f[V]weak\f[R],
\f[V]extern_weak\f[R] and \f[V]common\f[R] linkage types), LLVM makes no
assumptions about the allocation size of the variables, except that they
may not overlap.
The alignment of a global variable declaration or replaceable definition
must not be greater than the alignment of the definition it resolves to.
.PP
Globals can also have a \f[V]DLL storage class <dllstorageclass>\f[R],
an optional
\f[V]runtime preemption specifier <runtime_preemption_model>\f[R], an
optional \f[V]global attributes <glattrs>\f[R] and an optional list of
attached \f[V]metadata <metadata>\f[R].
.PP
Variables and aliases can have a
\f[V]Thread Local Storage Model <tls_model>\f[R].
.PP
\f[V]Scalable vectors <t_vector>\f[R] cannot be global variables or
members of arrays because their size is unknown at compile time.
They are allowed in structs to facilitate intrinsics returning multiple
values.
Structs containing scalable vectors cannot be used in loads, stores,
allocas, or GEPs.
.PP
Syntax:
.IP
.nf
\f[C]
\[at]<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]
                   [DLLStorageClass] [ThreadLocal]
                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
                   [ExternallyInitialized]
                   <global | constant> <Type> [<InitializerConstant>]
                   [, section \[dq]name\[dq]] [, partition \[dq]name\[dq]]
                   [, comdat [($name)]] [, align <Alignment>]
                   [, no_sanitize] [, no_sanitize_address]
                   [, no_sanitize_hwaddress] [, sanitize_address_dyninit]
                   (, !name !N)*
\f[R]
.fi
.PP
For example, the following defines a global in a numbered address space
with an initializer, section, and alignment:
.IP
.nf
\f[C]
\[at]G = addrspace(5) constant float 1.0, section \[dq]foo\[dq], align 4
\f[R]
.fi
.PP
The following example just declares a global variable
.IP
.nf
\f[C]
\[at]G = external global i32
\f[R]
.fi
.PP
The following example defines a thread-local global with the
\f[V]initialexec\f[R] TLS model:
.IP
.nf
\f[C]
\[at]G = thread_local(initialexec) global i32 0, align 4
\f[R]
.fi
.SS Functions
.PP
LLVM function definitions consist of the \[dq]\f[V]define\f[R]\[dq]
keyword, an optional \f[V]linkage type <linkage>\f[R], an optional
\f[V]runtime preemption
specifier <runtime_preemption_model>\f[R], an optional \f[V]visibility
style <visibility>\f[R], an optional
\f[V]DLL storage class <dllstorageclass>\f[R], an optional
\f[V]calling convention <callingconv>\f[R], an optional
\f[V]unnamed_addr\f[R] attribute, a return type, an optional
\f[V]parameter attribute <paramattrs>\f[R] for the return type, a
function name, a (possibly empty) argument list (each with optional
\f[V]parameter
attributes <paramattrs>\f[R]), optional
\f[V]function attributes <fnattrs>\f[R], an optional address space, an
optional section, an optional partition, an optional alignment, an
optional \f[V]comdat <langref_comdats>\f[R], an optional
\f[V]garbage collector name <gc>\f[R], an optional
\f[V]prefix <prefixdata>\f[R], an optional
\f[V]prologue <prologuedata>\f[R], an optional
\f[V]personality <personalityfn>\f[R], an optional list of attached
\f[V]metadata <metadata>\f[R], an opening curly brace, a list of basic
blocks, and a closing curly brace.
.PP
Syntax:
.IP
.nf
\f[C]
define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> \[at]<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
       [section \[dq]name\[dq]] [partition \[dq]name\[dq]] [comdat [($name)]] [align N]
       [gc] [prefix Constant] [prologue Constant] [personality Constant]
       (!name !N)* { ... }
\f[R]
.fi
.PP
The argument list is a comma separated sequence of arguments where each
argument is of the following form:
.PP
Syntax:
.IP
.nf
\f[C]
<type> [parameter Attrs] [name]
\f[R]
.fi
.PP
LLVM function declarations consist of the \[dq]\f[V]declare\f[R]\[dq]
keyword, an optional \f[V]linkage type <linkage>\f[R], an optional
\f[V]visibility style
<visibility>\f[R], an optional
\f[V]DLL storage class <dllstorageclass>\f[R], an optional
\f[V]calling convention <callingconv>\f[R], an optional
\f[V]unnamed_addr\f[R] or \f[V]local_unnamed_addr\f[R] attribute, an
optional address space, a return type, an optional
\f[V]parameter attribute <paramattrs>\f[R] for the return type, a
function name, a possibly empty list of arguments, an optional
alignment, an optional \f[V]garbage
collector name <gc>\f[R], an optional \f[V]prefix <prefixdata>\f[R], and
an optional \f[V]prologue <prologuedata>\f[R].
.PP
Syntax:
.IP
.nf
\f[C]
declare [linkage] [visibility] [DLLStorageClass]
        [cconv] [ret attrs]
        <ResultType> \[at]<FunctionName> ([argument list])
        [(unnamed_addr|local_unnamed_addr)] [align N] [gc]
        [prefix Constant] [prologue Constant]
\f[R]
.fi
.PP
A function definition contains a list of basic blocks, forming the CFG
(Control Flow Graph) for the function.
Each basic block may optionally start with a label (giving the basic
block a symbol table entry), contains a list of instructions, and ends
with a \f[V]terminator <terminators>\f[R] instruction (such as a branch
or function return).
If an explicit label name is not provided, a block is assigned an
implicit numbered label, using the next value from the same counter as
used for unnamed temporaries (\f[V]see above<identifiers>\f[R]).
For example, if a function entry block does not have an explicit label,
it will be assigned label \[dq]%0\[dq], then the first unnamed temporary
in that block will be \[dq]%1\[dq], etc.
If a numeric label is explicitly specified, it must match the numeric
label that would be used implicitly.
.PP
The first basic block in a function is special in two ways: it is
immediately executed on entrance to the function, and it is not allowed
to have predecessor basic blocks (i.e.
there can not be any branches to the entry block of a function).
Because the block can have no predecessors, it also cannot have any
\f[V]PHI nodes <i_phi>\f[R].
.PP
LLVM allows an explicit section to be specified for functions.
If the target supports it, it will emit functions to the section
specified.
Additionally, the function can be placed in a COMDAT.
.PP
An explicit alignment may be specified for a function.
If not present, or if the alignment is set to zero, the alignment of the
function is set by the target to whatever it feels convenient.
If an explicit alignment is specified, the function is forced to have at
least that much alignment.
All alignments must be a power of 2.
.PP
If the \f[V]unnamed_addr\f[R] attribute is given, the address is known
to not be significant and two identical functions can be merged.
.PP
If the \f[V]local_unnamed_addr\f[R] attribute is given, the address is
known to not be significant within the module.
.PP
If an explicit address space is not given, it will default to the
program address space from the
\f[V]datalayout string<langref_datalayout>\f[R].
.SS Aliases
.PP
Aliases, unlike function or variables, don\[aq]t create any new data.
They are just a new symbol and metadata for an existing position.
.PP
Aliases have a name and an aliasee that is either a global value or a
constant expression.
.PP
Aliases may have an optional \f[V]linkage type <linkage>\f[R], an
optional
\f[V]runtime preemption specifier <runtime_preemption_model>\f[R], an
optional \f[V]visibility style <visibility>\f[R], an optional
\f[V]DLL storage class
<dllstorageclass>\f[R] and an optional \f[V]tls model <tls_model>\f[R].
.PP
Syntax:
.IP
.nf
\f[C]
\[at]<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* \[at]<Aliasee>
          [, partition \[dq]name\[dq]]
\f[R]
.fi
.PP
The linkage must be one of \f[V]private\f[R], \f[V]internal\f[R],
\f[V]linkonce\f[R], \f[V]weak\f[R], \f[V]linkonce_odr\f[R],
\f[V]weak_odr\f[R], \f[V]external\f[R].
Note that some system linkers might not correctly handle dropping a weak
symbol that is aliased.
.PP
Aliases that are not \f[V]unnamed_addr\f[R] are guaranteed to have the
same address as the aliasee expression.
\f[V]unnamed_addr\f[R] ones are only guaranteed to point to the same
content.
.PP
If the \f[V]local_unnamed_addr\f[R] attribute is given, the address is
known to not be significant within the module.
.PP
Since aliases are only a second name, some restrictions apply, of which
some can only be checked when producing an object file:
.IP \[bu] 2
The expression defining the aliasee must be computable at assembly time.
Since it is just a name, no relocations can be used.
.IP \[bu] 2
No alias in the expression can be weak as the possibility of the
intermediate alias being overridden cannot be represented in an object
file.
.IP \[bu] 2
No global value in the expression can be a declaration, since that would
require a relocation, which is not possible.
.IP \[bu] 2
If either the alias or the aliasee may be replaced by a symbol outside
the module at link time or runtime, any optimization cannot replace the
alias with the aliasee, since the behavior may be different.
The alias may be used as a name guaranteed to point to the content in
the current module.
.SS IFuncs
.PP
IFuncs, like as aliases, don\[aq]t create any new data or func.
They are just a new symbol that dynamic linker resolves at runtime by
calling a resolver function.
.PP
IFuncs have a name and a resolver that is a function called by dynamic
linker that returns address of another function associated with the
name.
.PP
IFunc may have an optional \f[V]linkage type <linkage>\f[R] and an
optional \f[V]visibility style <visibility>\f[R].
.PP
Syntax:
.IP
.nf
\f[C]
\[at]<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* \[at]<Resolver>
          [, partition \[dq]name\[dq]]
\f[R]
.fi
.SS Comdats
.PP
Comdat IR provides access to object file COMDAT/section group
functionality which represents interrelated sections.
.PP
Comdats have a name which represents the COMDAT key and a selection kind
to provide input on how the linker deduplicates comdats with the same
key in two different object files.
A comdat must be included or omitted as a unit.
Discarding the whole comdat is allowed but discarding a subset is not.
.PP
A global object may be a member of at most one comdat.
Aliases are placed in the same COMDAT that their aliasee computes to, if
any.
.PP
Syntax:
.IP
.nf
\f[C]
$<Name> = comdat SelectionKind
\f[R]
.fi
.PP
For selection kinds other than \f[V]nodeduplicate\f[R], only one of the
duplicate comdats may be retained by the linker and the members of the
remaining comdats must be discarded.
The following selection kinds are supported:
.TP
\f[V]any\f[R]
The linker may choose any COMDAT key, the choice is arbitrary.
.TP
\f[V]exactmatch\f[R]
The linker may choose any COMDAT key but the sections must contain the
same data.
.TP
\f[V]largest\f[R]
The linker will choose the section containing the largest COMDAT key.
.TP
\f[V]nodeduplicate\f[R]
No deduplication is performed.
.TP
\f[V]samesize\f[R]
The linker may choose any COMDAT key but the sections must contain the
same amount of data.
.IP \[bu] 2
XCOFF and Mach-O don\[aq]t support COMDATs.
.IP \[bu] 2
COFF supports all selection kinds.
Non-\f[V]nodeduplicate\f[R] selection kinds need a non-local linkage
COMDAT symbol.
.IP \[bu] 2
ELF supports \f[V]any\f[R] and \f[V]nodeduplicate\f[R].
.IP \[bu] 2
WebAssembly only supports \f[V]any\f[R].
.PP
Here is an example of a COFF COMDAT where a function will only be
selected if the COMDAT key\[aq]s section is the largest:
.IP
.nf
\f[C]
$foo = comdat largest
\[at]foo = global i32 2, comdat($foo)

define void \[at]bar() comdat($foo) {
  ret void
}
\f[R]
.fi
.PP
In a COFF object file, this will create a COMDAT section with selection
kind \f[V]IMAGE_COMDAT_SELECT_LARGEST\f[R] containing the contents of
the \f[V]\[at]foo\f[R] symbol and another COMDAT section with selection
kind \f[V]IMAGE_COMDAT_SELECT_ASSOCIATIVE\f[R] which is associated with
the first COMDAT section and contains the contents of the
\f[V]\[at]bar\f[R] symbol.
.PP
As a syntactic sugar the \f[V]$name\f[R] can be omitted if the name is
the same as the global name:
.IP
.nf
\f[C]
$foo = comdat any
\[at]foo = global i32 2, comdat
\[at]bar = global i32 3, comdat($foo)
\f[R]
.fi
.PP
There are some restrictions on the properties of the global object.
It, or an alias to it, must have the same name as the COMDAT group when
targeting COFF.
The contents and size of this object may be used during link-time to
determine which COMDAT groups get selected depending on the selection
kind.
Because the name of the object must match the name of the COMDAT group,
the linkage of the global object must not be local; local symbols can
get renamed if a collision occurs in the symbol table.
.PP
The combined use of COMDATS and section attributes may yield surprising
results.
For example:
.IP
.nf
\f[C]
$foo = comdat any
$bar = comdat any
\[at]g1 = global i32 42, section \[dq]sec\[dq], comdat($foo)
\[at]g2 = global i32 42, section \[dq]sec\[dq], comdat($bar)
\f[R]
.fi
.PP
From the object file perspective, this requires the creation of two
sections with the same name.
This is necessary because both globals belong to different COMDAT groups
and COMDATs, at the object file level, are represented by sections.
.PP
Note that certain IR constructs like global variables and functions may
create COMDATs in the object file in addition to any which are specified
using COMDAT IR.
This arises when the code generator is configured to emit globals in
individual sections (e.g.
when -data-sections or -function-sections is supplied to llc).
.SS Named Metadata
.PP
Named metadata is a collection of metadata.
\f[V]Metadata
nodes <metadata>\f[R] (but not metadata strings) are the only valid
operands for a named metadata.
.IP "1." 3
Named metadata are represented as a string of characters with the
metadata prefix.
The rules for metadata names are the same as for identifiers, but quoted
names are not allowed.
\f[V]\[dq]\[rs]xx\[dq]\f[R] type escapes are still valid, which allows
any character to be part of a name.
.PP
Syntax:
.IP
.nf
\f[C]
; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!\[dq]zero\[dq]}
!1 = !{!\[dq]one\[dq]}
!2 = !{!\[dq]two\[dq]}
; A named metadata.
!name = !{!0, !1, !2}
\f[R]
.fi
.SS Parameter Attributes
.PP
The return type and each parameter of a function type may have a set of
\f[I]parameter attributes\f[R] associated with them.
Parameter attributes are used to communicate additional information
about the result or parameters of a function.
Parameter attributes are considered to be part of the function, not of
the function type, so functions with different parameter attributes can
have the same function type.
.PP
Parameter attributes are simple keywords that follow the type specified.
If multiple parameter attributes are needed, they are space separated.
For example:
.IP
.nf
\f[C]
declare i32 \[at]printf(i8* noalias nocapture, ...)
declare i32 \[at]atoi(i8 zeroext)
declare signext i8 \[at]returns_signed_char()
\f[R]
.fi
.PP
Note that any attributes for the function result (\f[V]nounwind\f[R],
\f[V]readonly\f[R]) come immediately after the argument list.
.PP
Currently, only the following parameter attributes are defined:
.TP
\f[V]zeroext\f[R]
This indicates to the code generator that the parameter or return value
should be zero-extended to the extent required by the target\[aq]s ABI
by the caller (for a parameter) or the callee (for a return value).
.TP
\f[V]signext\f[R]
This indicates to the code generator that the parameter or return value
should be sign-extended to the extent required by the target\[aq]s ABI
(which is usually 32-bits) by the caller (for a parameter) or the callee
(for a return value).
.TP
\f[V]inreg\f[R]
This indicates that this parameter or return value should be treated in
a special target-dependent fashion while emitting code for a function
call or return (usually, by putting it in a register as opposed to
memory, though some targets use it to distinguish between two different
kinds of registers).
Use of this attribute is target-specific.
.TP
\f[V]byval(<ty>)\f[R]
This indicates that the pointer parameter should really be passed by
value to the function.
The attribute implies that a hidden copy of the pointee is made between
the caller and the callee, so the callee is unable to modify the value
in the caller.
This attribute is only valid on LLVM pointer arguments.
It is generally used to pass structs and arrays by value, but is also
valid on pointers to scalars.
The copy is considered to belong to the caller not the callee (for
example, \f[V]readonly\f[R] functions should not write to
\f[V]byval\f[R] parameters).
This is not a valid attribute for return values.
.RS
.PP
The byval type argument indicates the in-memory value type, and must be
the same as the pointee type of the argument.
.PP
The byval attribute also supports specifying an alignment with the align
attribute.
It indicates the alignment of the stack slot to form and the known
alignment of the pointer specified to the call site.
If the alignment is not specified, then the code generator makes a
target-specific assumption.
.RE
.PP
\f[V]byref(<ty>)\f[R]
.RS
.PP
The \f[V]byref\f[R] argument attribute allows specifying the pointee
memory type of an argument.
This is similar to \f[V]byval\f[R], but does not imply a copy is made
anywhere, or that the argument is passed on the stack.
This implies the pointer is dereferenceable up to the storage size of
the type.
.PP
It is not generally permissible to introduce a write to an
\f[V]byref\f[R] pointer.
The pointer may have any address space and may be read only.
.PP
This is not a valid attribute for return values.
.PP
The alignment for an \f[V]byref\f[R] parameter can be explicitly
specified by combining it with the \f[V]align\f[R] attribute, similar to
\f[V]byval\f[R].
If the alignment is not specified, then the code generator makes a
target-specific assumption.
.PP
This is intended for representing ABI constraints, and is not intended
to be inferred for optimization use.
.RE
.TP
\f[V]preallocated(<ty>)\f[R]
This indicates that the pointer parameter should really be passed by
value to the function, and that the pointer parameter\[aq]s pointee has
already been initialized before the call instruction.
This attribute is only valid on LLVM pointer arguments.
The argument must be the value returned by the appropriate
\f[V]llvm.call.preallocated.arg<int_call_preallocated_arg>\f[R] on non
\f[V]musttail\f[R] calls, or the corresponding caller parameter in
\f[V]musttail\f[R] calls, although it is ignored during codegen.
.RS
.PP
A non \f[V]musttail\f[R] function call with a \f[V]preallocated\f[R]
attribute in any parameter must have a \f[V]\[dq]preallocated\[dq]\f[R]
operand bundle.
A \f[V]musttail\f[R] function call cannot have a
\f[V]\[dq]preallocated\[dq]\f[R] operand bundle.
.PP
The preallocated attribute requires a type argument, which must be the
same as the pointee type of the argument.
.PP
The preallocated attribute also supports specifying an alignment with
the align attribute.
It indicates the alignment of the stack slot to form and the known
alignment of the pointer specified to the call site.
If the alignment is not specified, then the code generator makes a
target-specific assumption.
.RE
.PP
\f[V]inalloca(<ty>)\f[R]
.RS
.PP
The \f[V]inalloca\f[R] argument attribute allows the caller to take the
address of outgoing stack arguments.
An \f[V]inalloca\f[R] argument must be a pointer to stack memory
produced by an \f[V]alloca\f[R] instruction.
The alloca, or argument allocation, must also be tagged with the
inalloca keyword.
Only the last argument may have the \f[V]inalloca\f[R] attribute, and
that argument is guaranteed to be passed in memory.
.PP
An argument allocation may be used by a call at most once because the
call may deallocate it.
The \f[V]inalloca\f[R] attribute cannot be used in conjunction with
other attributes that affect argument storage, like \f[V]inreg\f[R],
\f[V]nest\f[R], \f[V]sret\f[R], or \f[V]byval\f[R].
The \f[V]inalloca\f[R] attribute also disables LLVM\[aq]s implicit
lowering of large aggregate return values, which means that frontend
authors must lower them with \f[V]sret\f[R] pointers.
.PP
When the call site is reached, the argument allocation must have been
the most recent stack allocation that is still live, or the behavior is
undefined.
It is possible to allocate additional stack space after an argument
allocation and before its call site, but it must be cleared off with
\f[V]llvm.stackrestore
<int_stackrestore>\f[R].
.PP
The inalloca attribute requires a type argument, which must be the same
as the pointee type of the argument.
.PP
See \f[V]InAlloca\f[R] for more information on how to use this
attribute.
.RE
.TP
\f[V]sret(<ty>)\f[R]
This indicates that the pointer parameter specifies the address of a
structure that is the return value of the function in the source
program.
This pointer must be guaranteed by the caller to be valid: loads and
stores to the structure may be assumed by the callee not to trap and to
be properly aligned.
This is not a valid attribute for return values.
.RS
.PP
The sret type argument specifies the in memory type, which must be the
same as the pointee type of the argument.
.RE
.PP
\f[V]elementtype(<ty>)\f[R]
.RS
.PP
The \f[V]elementtype\f[R] argument attribute can be used to specify a
pointer element type in a way that is compatible with opaque pointers.
.PP
The \f[V]elementtype\f[R] attribute by itself does not carry any
specific semantics.
However, certain intrinsics may require this attribute to be present and
assign it particular semantics.
This will be documented on individual intrinsics.
.PP
The attribute may only be applied to pointer typed arguments of
intrinsic calls.
It cannot be applied to non-intrinsic calls, and cannot be applied to
parameters on function declarations.
For non-opaque pointers, the type passed to \f[V]elementtype\f[R] must
match the pointer element type.
.RE
.TP
\f[V]align <n>\f[R] or \f[V]align(<n>)\f[R]
This indicates that the pointer value or vector of pointers has the
specified alignment.
If applied to a vector of pointers, \f[I]all\f[R] pointers (elements)
have the specified alignment.
If the pointer value does not have the specified alignment,
\f[V]poison value <poisonvalues>\f[R] is returned or passed instead.
The \f[V]align\f[R] attribute should be combined with the
\f[V]noundef\f[R] attribute to ensure a pointer is aligned, or otherwise
the behavior is undefined.
Note that \f[V]align 1\f[R] has no effect on non-byval, non-preallocated
arguments.
.RS
.PP
Note that this attribute has additional semantics when combined with the
\f[V]byval\f[R] or \f[V]preallocated\f[R] attribute, which are
documented there.
.RE
.TP
\f[V]noalias\f[R]
This indicates that memory locations accessed via pointer values
\f[V]based <pointeraliasing>\f[R] on the argument or return value are
not also accessed, during the execution of the function, via pointer
values not \f[I]based\f[R] on the argument or return value.
This guarantee only holds for memory locations that are
\f[I]modified\f[R], by any means, during the execution of the function.
The attribute on a return value also has additional semantics described
below.
The caller shares the responsibility with the callee for ensuring that
these requirements are met.
For further details, please see the discussion of the NoAlias response
in \f[V]alias analysis <Must, May,
or No>\f[R].
.RS
.PP
Note that this definition of \f[V]noalias\f[R] is intentionally similar
to the definition of \f[V]restrict\f[R] in C99 for function arguments.
.PP
For function return values, C99\[aq]s \f[V]restrict\f[R] is not
meaningful, while LLVM\[aq]s \f[V]noalias\f[R] is.
Furthermore, the semantics of the \f[V]noalias\f[R] attribute on return
values are stronger than the semantics of the attribute when used on
function arguments.
On function return values, the \f[V]noalias\f[R] attribute indicates
that the function acts like a system memory allocation function,
returning a pointer to allocated storage disjoint from the storage for
any other object accessible to the caller.
.RE
.TP
\f[V]nocapture\f[R]
This indicates that the callee does not
\f[V]capture <pointercapture>\f[R] the pointer.
This is not a valid attribute for return values.
This attribute applies only to the particular copy of the pointer passed
in this argument.
A caller could pass two copies of the same pointer with one being
annotated nocapture and the other not, and the callee could validly
capture through the non annotated parameter.
.IP
.nf
\f[C]
define void \[at]f(i8* nocapture %a, i8* %b) {
  ; (capture %b)
}

call void \[at]f(i8* \[at]glb, i8* \[at]glb) ; well-defined
\f[R]
.fi
.TP
\f[V]nofree\f[R]
This indicates that callee does not free the pointer argument.
This is not a valid attribute for return values.
.TP
\f[V]nest\f[R]
This indicates that the pointer parameter can be excised using the
\f[V]trampoline intrinsics <int_trampoline>\f[R].
This is not a valid attribute for return values and can only be applied
to one parameter.
.TP
\f[V]returned\f[R]
This indicates that the function always returns the argument as its
return value.
This is a hint to the optimizer and code generator used when generating
the caller, allowing value propagation, tail call optimization, and
omission of register saves and restores in some cases; it is not checked
or enforced when generating the callee.
The parameter and the function return type must be valid operands for
the \f[V]bitcast instruction <i_bitcast>\f[R].
This is not a valid attribute for return values and can only be applied
to one parameter.
.TP
\f[V]nonnull\f[R]
This indicates that the parameter or return pointer is not null.
This attribute may only be applied to pointer typed parameters.
This is not checked or enforced by LLVM; if the parameter or return
pointer is null, \f[V]poison value <poisonvalues>\f[R] is returned or
passed instead.
The \f[V]nonnull\f[R] attribute should be combined with the
\f[V]noundef\f[R] attribute to ensure a pointer is not null or otherwise
the behavior is undefined.
.TP
\f[V]dereferenceable(<n>)\f[R]
This indicates that the parameter or return pointer is dereferenceable.
This attribute may only be applied to pointer typed parameters.
A pointer that is dereferenceable can be loaded from speculatively
without a risk of trapping.
The number of bytes known to be dereferenceable must be provided in
parentheses.
It is legal for the number of bytes to be less than the size of the
pointee type.
The \f[V]nonnull\f[R] attribute does not imply dereferenceability
(consider a pointer to one element past the end of an array), however
\f[V]dereferenceable(<n>)\f[R] does imply \f[V]nonnull\f[R] in
\f[V]addrspace(0)\f[R] (which is the default address space), except if
the \f[V]null_pointer_is_valid\f[R] function attribute is present.
\f[V]n\f[R] should be a positive number.
The pointer should be well defined, otherwise it is undefined behavior.
This means \f[V]dereferenceable(<n>)\f[R] implies \f[V]noundef\f[R].
.TP
\f[V]dereferenceable_or_null(<n>)\f[R]
This indicates that the parameter or return value isn\[aq]t both
non-null and non-dereferenceable (up to \f[V]<n>\f[R] bytes) at the same
time.
All non-null pointers tagged with \f[V]dereferenceable_or_null(<n>)\f[R]
are \f[V]dereferenceable(<n>)\f[R].
For address space 0 \f[V]dereferenceable_or_null(<n>)\f[R] implies that
a pointer is exactly one of \f[V]dereferenceable(<n>)\f[R] or
\f[V]null\f[R], and in other address spaces
\f[V]dereferenceable_or_null(<n>)\f[R] implies that a pointer is at
least one of \f[V]dereferenceable(<n>)\f[R] or \f[V]null\f[R] (i.e.
it may be both \f[V]null\f[R] and \f[V]dereferenceable(<n>)\f[R]).
This attribute may only be applied to pointer typed parameters.
.TP
\f[V]swiftself\f[R]
This indicates that the parameter is the self/context parameter.
This is not a valid attribute for return values and can only be applied
to one parameter.
.TP
\f[V]swiftasync\f[R]
This indicates that the parameter is the asynchronous context parameter
and triggers the creation of a target-specific extended frame record to
store this pointer.
This is not a valid attribute for return values and can only be applied
to one parameter.
.TP
\f[V]swifterror\f[R]
This attribute is motivated to model and optimize Swift error handling.
It can be applied to a parameter with pointer to pointer type or a
pointer-sized alloca.
At the call site, the actual argument that corresponds to a
\f[V]swifterror\f[R] parameter has to come from a \f[V]swifterror\f[R]
alloca or the \f[V]swifterror\f[R] parameter of the caller.
A \f[V]swifterror\f[R] value (either the parameter or the alloca) can
only be loaded and stored from, or used as a \f[V]swifterror\f[R]
argument.
This is not a valid attribute for return values and can only be applied
to one parameter.
.RS
.PP
These constraints allow the calling convention to optimize access to
\f[V]swifterror\f[R] variables by associating them with a specific
register at call boundaries rather than placing them in memory.
Since this does change the calling convention, a function which uses the
\f[V]swifterror\f[R] attribute on a parameter is not ABI-compatible with
one which does not.
.PP
These constraints also allow LLVM to assume that a \f[V]swifterror\f[R]
argument does not alias any other memory visible within a function and
that a \f[V]swifterror\f[R] alloca passed as an argument does not
escape.
.RE
.TP
\f[V]immarg\f[R]
This indicates the parameter is required to be an immediate value.
This must be a trivial immediate integer or floating-point constant.
Undef or constant expressions are not valid.
This is only valid on intrinsic declarations and cannot be applied to a
call site or arbitrary function.
.TP
\f[V]noundef\f[R]
This attribute applies to parameters and return values.
If the value representation contains any undefined or poison bits, the
behavior is undefined.
Note that this does not refer to padding introduced by the type\[aq]s
storage representation.
.TP
\f[V]alignstack(<n>)\f[R]
This indicates the alignment that should be considered by the backend
when assigning this parameter to a stack slot during calling convention
lowering.
The enforcement of the specified alignment is target-dependent, as
target-specific calling convention rules may override this value.
This attribute serves the purpose of carrying language specific
alignment information that is not mapped to base types in the backend
(for example, over-alignment specification through language attributes).
.TP
\f[V]allocalign\f[R]
The function parameter marked with this attribute is is the alignment in
bytes of the newly allocated block returned by this function.
The returned value must either have the specified alignment or be the
null pointer.
The return value MAY be more aligned than the requested alignment, but
not less aligned.
Invalid (e.g.
non-power-of-2) alignments are permitted for the allocalign parameter,
so long as the returned pointer is null.
This attribute may only be applied to integer parameters.
.TP
\f[V]allocptr\f[R]
The function parameter marked with this attribute is the pointer that
will be manipulated by the allocator.
For a realloc-like function the pointer will be invalidated upon success
(but the same address may be returned), for a free-like function the
pointer will always be invalidated.
.SS Garbage Collector Strategy Names
.PP
Each function may specify a garbage collector strategy name, which is
simply a string:
.IP
.nf
\f[C]
define void \[at]f() gc \[dq]name\[dq] { ... }
\f[R]
.fi
.PP
The supported values of \f[I]name\f[R] includes those
\f[V]built in to LLVM
<builtin-gc-strategies>\f[R] and any provided by loaded plugins.
Specifying a GC strategy will cause the compiler to alter its output in
order to support the named garbage collection algorithm.
Note that LLVM itself does not contain a garbage collector, this
functionality is restricted to generating machine code which can
interoperate with a collector provided externally.
.SS Prefix Data
.PP
Prefix data is data associated with a function which the code generator
will emit immediately before the function\[aq]s entrypoint.
The purpose of this feature is to allow frontends to associate
language-specific runtime metadata with specific functions and make it
available through the function pointer while still allowing the function
pointer to be called.
.PP
To access the data for a given function, a program may bitcast the
function pointer to a pointer to the constant\[aq]s type and dereference
index -1.
This implies that the IR symbol points just past the end of the prefix
data.
For instance, take the example of a function annotated with a single
\f[V]i32\f[R],
.IP
.nf
\f[C]
define void \[at]f() prefix i32 123 { ... }
\f[R]
.fi
.PP
The prefix data can be referenced as,
.IP
.nf
\f[C]
%0 = bitcast void* () \[at]f to i32*
%a = getelementptr inbounds i32, i32* %0, i32 -1
%b = load i32, i32* %a
\f[R]
.fi
.PP
Prefix data is laid out as if it were an initializer for a global
variable of the prefix data\[aq]s type.
The function will be placed such that the beginning of the prefix data
is aligned.
This means that if the size of the prefix data is not a multiple of the
alignment size, the function\[aq]s entrypoint will not be aligned.
If alignment of the function\[aq]s entrypoint is desired, padding must
be added to the prefix data.
.PP
A function may have prefix data but no body.
This has similar semantics to the \f[V]available_externally\f[R] linkage
in that the data may be used by the optimizers but will not be emitted
in the object file.
.SS Prologue Data
.PP
The \f[V]prologue\f[R] attribute allows arbitrary code (encoded as
bytes) to be inserted prior to the function body.
This can be used for enabling function hot-patching and instrumentation.
.PP
To maintain the semantics of ordinary function calls, the prologue data
must have a particular format.
Specifically, it must begin with a sequence of bytes which decode to a
sequence of machine instructions, valid for the module\[aq]s target,
which transfer control to the point immediately succeeding the prologue
data, without performing any other visible action.
This allows the inliner and other passes to reason about the semantics
of the function definition without needing to reason about the prologue
data.
Obviously this makes the format of the prologue data highly target
dependent.
.PP
A trivial example of valid prologue data for the x86 architecture is
\f[V]i8 144\f[R], which encodes the \f[V]nop\f[R] instruction:
.IP
.nf
\f[C]
define void \[at]f() prologue i8 144 { ... }
\f[R]
.fi
.PP
Generally prologue data can be formed by encoding a relative branch
instruction which skips the metadata, as in this example of valid
prologue data for the x86_64 architecture, where the first two bytes
encode \f[V]jmp .+10\f[R]:
.IP
.nf
\f[C]
%0 = type <{ i8, i8, i8* }>

define void \[at]f() prologue %0 <{ i8 235, i8 8, i8* \[at]md}> { ... }
\f[R]
.fi
.PP
A function may have prologue data but no body.
This has similar semantics to the \f[V]available_externally\f[R] linkage
in that the data may be used by the optimizers but will not be emitted
in the object file.
.SS Personality Function
.PP
The \f[V]personality\f[R] attribute permits functions to specify what
function to use for exception handling.
.SS Attribute Groups
.PP
Attribute groups are groups of attributes that are referenced by objects
within the IR.
They are important for keeping \f[V].ll\f[R] files readable, because a
lot of functions will use the same set of attributes.
In the degenerative case of a \f[V].ll\f[R] file that corresponds to a
single \f[V].c\f[R] file, the single attribute group will capture the
important command line flags used to build that file.
.PP
An attribute group is a module-level object.
To use an attribute group, an object references the attribute
group\[aq]s ID (e.g.
\f[V]#37\f[R]).
An object may refer to more than one attribute group.
In that situation, the attributes from the different groups are merged.
.PP
Here is an example of attribute groups for a function that should always
be inlined, has a stack alignment of 4, and which shouldn\[aq]t use SSE
instructions:
.IP
.nf
\f[C]
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { \[dq]no-sse\[dq] }

; Function \[at]f has attributes: alwaysinline, alignstack=4, and \[dq]no-sse\[dq].
define void \[at]f() #0 #1 { ... }
\f[R]
.fi
.SS Function Attributes
.PP
Function attributes are set to communicate additional information about
a function.
Function attributes are considered to be part of the function, not of
the function type, so functions with different function attributes can
have the same function type.
.PP
Function attributes are simple keywords that follow the type specified.
If multiple attributes are needed, they are space separated.
For example:
.IP
.nf
\f[C]
define void \[at]f() noinline { ... }
define void \[at]f() alwaysinline { ... }
define void \[at]f() alwaysinline optsize { ... }
define void \[at]f() optsize { ... }
\f[R]
.fi
.TP
\f[V]alignstack(<n>)\f[R]
This attribute indicates that, when emitting the prologue and epilogue,
the backend should forcibly align the stack pointer.
Specify the desired alignment, which must be a power of two, in
parentheses.
.TP
\f[V]\[dq]alloc-family\[dq]=\[dq]FAMILY\[dq]\f[R]
This indicates which \[dq]family\[dq] an allocator function is part of.
To avoid collisions, the family name should match the mangled name of
the primary allocator function, that is \[dq]malloc\[dq] for
malloc/calloc/realloc/free, \[dq]_Znwm\[dq] for
\f[V]::operator::new\f[R] and \f[V]::operator::delete\f[R], and
\[dq]_ZnwmSt11align_val_t\[dq] for aligned \f[V]::operator::new\f[R] and
\f[V]::operator::delete\f[R].
Matching malloc/realloc/free calls within a family can be optimized, but
mismatched ones will be left alone.
.TP
\f[V]allockind(\[dq]KIND\[dq])\f[R]
Describes the behavior of an allocation function.
The KIND string contains comma separated entries from the following
options:
.RS
.IP \[bu] 2
\[dq]alloc\[dq]: the function returns a new block of memory or null.
.IP \[bu] 2
\[dq]realloc\[dq]: the function returns a new block of memory or null.
If the result is non-null the memory contents from the start of the
block up to the smaller of the original allocation size and the new
allocation size will match that of the \f[V]allocptr\f[R] argument and
the \f[V]allocptr\f[R] argument is invalidated, even if the function
returns the same address.
.IP \[bu] 2
\[dq]free\[dq]: the function frees the block of memory specified by
\f[V]allocptr\f[R].
.IP \[bu] 2
\[dq]uninitialized\[dq]: Any newly-allocated memory (either a new block
from a \[dq]alloc\[dq] function or the enlarged capacity from a
\[dq]realloc\[dq] function) will be uninitialized.
.IP \[bu] 2
\[dq]zeroed\[dq]: Any newly-allocated memory (either a new block from a
\[dq]alloc\[dq] function or the enlarged capacity from a
\[dq]realloc\[dq] function) will be zeroed.
.IP \[bu] 2
\[dq]aligned\[dq]: the function returns memory aligned according to the
\f[V]allocalign\f[R] parameter.
.PP
The first three options are mutually exclusive, and the remaining
options describe more details of how the function behaves.
The remaining options are invalid for \[dq]free\[dq]-type functions.
.RE
.TP
\f[V]allocsize(<EltSizeParam>[, <NumEltsParam>])\f[R]
This attribute indicates that the annotated function will always return
at least a given number of bytes (or null).
Its arguments are zero-indexed parameter numbers; if one argument is
provided, then it\[aq]s assumed that at least
\f[V]CallSite.Args[EltSizeParam]\f[R] bytes will be available at the
returned pointer.
If two are provided, then it\[aq]s assumed that
\f[V]CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]\f[R]
bytes are available.
The referenced parameters must be integer types.
No assumptions are made about the contents of the returned block of
memory.
.TP
\f[V]alwaysinline\f[R]
This attribute indicates that the inliner should attempt to inline this
function into callers whenever possible, ignoring any active inlining
size threshold for this caller.
.TP
\f[V]builtin\f[R]
This indicates that the callee function at a call site should be
recognized as a built-in function, even though the function\[aq]s
declaration uses the \f[V]nobuiltin\f[R] attribute.
This is only valid at call sites for direct calls to functions that are
declared with the \f[V]nobuiltin\f[R] attribute.
.TP
\f[V]cold\f[R]
This attribute indicates that this function is rarely called.
When computing edge weights, basic blocks post-dominated by a cold
function call are also considered to be cold; and, thus, given low
weight.
.TP
\f[V]convergent\f[R]
In some parallel execution models, there exist operations that cannot be
made control-dependent on any additional values.
We call such operations \f[V]convergent\f[R], and mark them with this
attribute.
.RS
.PP
The \f[V]convergent\f[R] attribute may appear on functions or
call/invoke instructions.
When it appears on a function, it indicates that calls to this function
should not be made control-dependent on additional values.
For example, the intrinsic \f[V]llvm.nvvm.barrier0\f[R] is
\f[V]convergent\f[R], so calls to this intrinsic cannot be made
control-dependent on additional values.
.PP
When it appears on a call/invoke, the \f[V]convergent\f[R] attribute
indicates that we should treat the call as though we\[aq]re calling a
convergent function.
This is particularly useful on indirect calls; without this we may treat
such calls as though the target is non-convergent.
.PP
The optimizer may remove the \f[V]convergent\f[R] attribute on functions
when it can prove that the function does not execute any convergent
operations.
Similarly, the optimizer may remove \f[V]convergent\f[R] on
calls/invokes when it can prove that the call/invoke cannot call a
convergent function.
.RE
.TP
\f[V]disable_sanitizer_instrumentation\f[R]
When instrumenting code with sanitizers, it can be important to skip
certain functions to ensure no instrumentation is applied to them.
.RS
.PP
This attribute is not always similar to absent \f[V]sanitize_<name>\f[R]
attributes: depending on the specific sanitizer, code can be inserted
into functions regardless of the \f[V]sanitize_<name>\f[R] attribute to
prevent false positive reports.
.PP
\f[V]disable_sanitizer_instrumentation\f[R] disables all kinds of
instrumentation, taking precedence over the \f[V]sanitize_<name>\f[R]
attributes and other compiler flags.
.RE
.TP
\f[V]\[dq]dontcall-error\[dq]\f[R]
This attribute denotes that an error diagnostic should be emitted when a
call of a function with this attribute is not eliminated via
optimization.
Front ends can provide optional \f[V]srcloc\f[R] metadata nodes on call
sites of such callees to attach information about where in the source
language such a call came from.
A string value can be provided as a note.
.TP
\f[V]\[dq]dontcall-warn\[dq]\f[R]
This attribute denotes that a warning diagnostic should be emitted when
a call of a function with this attribute is not eliminated via
optimization.
Front ends can provide optional \f[V]srcloc\f[R] metadata nodes on call
sites of such callees to attach information about where in the source
language such a call came from.
A string value can be provided as a note.
.TP
\f[V]\[dq]frame-pointer\[dq]\f[R]
This attribute tells the code generator whether the function should keep
the frame pointer.
The code generator may emit the frame pointer even if this attribute
says the frame pointer can be eliminated.
The allowed string values are:
.RS
.RS
.IP \[bu] 2
\f[V]\[dq]none\[dq]\f[R] (default) - the frame pointer can be
eliminated.
.IP \[bu] 2
\f[V]\[dq]non-leaf\[dq]\f[R] - the frame pointer should be kept if the
function calls other functions.
.IP \[bu] 2
\f[V]\[dq]all\[dq]\f[R] - the frame pointer should be kept.
.RE
.RE
.TP
\f[V]hot\f[R]
This attribute indicates that this function is a hot spot of the program
execution.
The function will be optimized more aggressively and will be placed into
special subsection of the text section to improving locality.
.RS
.PP
When profile feedback is enabled, this attribute has the precedence over
the profile information.
By marking a function \f[V]hot\f[R], users can work around the cases
where the training input does not have good coverage on all the hot
functions.
.RE
.TP
\f[V]inaccessiblememonly\f[R]
This attribute indicates that the function may only access memory that
is not accessible by the module being compiled before return from the
function.
This is a weaker form of \f[V]readnone\f[R].
If the function reads or writes other memory, the behavior is undefined.
.RS
.PP
For clarity, note that such functions are allowed to return new memory
which is \f[V]noalias\f[R] with respect to memory already accessible
from the module.
That is, a function can be both \f[V]inaccessiblememonly\f[R] and have a
\f[V]noalias\f[R] return which introduces a new, potentially
initialized, allocation.
.RE
.TP
\f[V]inaccessiblemem_or_argmemonly\f[R]
This attribute indicates that the function may only access memory that
is either not accessible by the module being compiled, or is pointed to
by its pointer arguments.
This is a weaker form of \f[V]argmemonly\f[R].
If the function reads or writes other memory, the behavior is undefined.
.TP
\f[V]inlinehint\f[R]
This attribute indicates that the source code contained a hint that
inlining this function is desirable (such as the \[dq]inline\[dq]
keyword in C/C++).
It is just a hint; it imposes no requirements on the inliner.
.TP
\f[V]jumptable\f[R]
This attribute indicates that the function should be added to a
jump-instruction table at code-generation time, and that all
address-taken references to this function should be replaced with a
reference to the appropriate jump-instruction-table function pointer.
Note that this creates a new pointer for the original function, which
means that code that depends on function-pointer identity can break.
So, any function annotated with \f[V]jumptable\f[R] must also be
\f[V]unnamed_addr\f[R].
.TP
\f[V]minsize\f[R]
This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function as small as
possible and perform optimizations that may sacrifice runtime
performance in order to minimize the size of the generated code.
.TP
\f[V]naked\f[R]
This attribute disables prologue / epilogue emission for the function.
This can have very system-specific consequences.
.TP
\f[V]\[dq]no-inline-line-tables\[dq]\f[R]
When this attribute is set to true, the inliner discards source
locations when inlining code and instead uses the source location of the
call site.
Breakpoints set on code that was inlined into the current function will
not fire during the execution of the inlined call sites.
If the debugger stops inside an inlined call site, it will appear to be
stopped at the outermost inlined call site.
.TP
\f[V]no-jump-tables\f[R]
When this attribute is set to true, the jump tables and lookup tables
that can be generated from a switch case lowering are disabled.
.TP
\f[V]nobuiltin\f[R]
This indicates that the callee function at a call site is not recognized
as a built-in function.
LLVM will retain the original call and not replace it with equivalent
code based on the semantics of the built-in function, unless the call
site uses the \f[V]builtin\f[R] attribute.
This is valid at call sites and on function declarations and
definitions.
.TP
\f[V]noduplicate\f[R]
This attribute indicates that calls to the function cannot be
duplicated.
A call to a \f[V]noduplicate\f[R] function may be moved within its
parent function, but may not be duplicated within its parent function.
.RS
.PP
A function containing a \f[V]noduplicate\f[R] call may still be an
inlining candidate, provided that the call is not duplicated by
inlining.
That implies that the function has internal linkage and only has one
call site, so the original call is dead after inlining.
.RE
.TP
\f[V]nofree\f[R]
This function attribute indicates that the function does not, directly
or transitively, call a memory-deallocation function (\f[V]free\f[R],
for example) on a memory allocation which existed before the call.
.RS
.PP
As a result, uncaptured pointers that are known to be dereferenceable
prior to a call to a function with the \f[V]nofree\f[R] attribute are
still known to be dereferenceable after the call.
The capturing condition is necessary in environments where the function
might communicate the pointer to another thread which then deallocates
the memory.
Alternatively, \f[V]nosync\f[R] would ensure such communication cannot
happen and even captured pointers cannot be freed by the function.
.PP
A \f[V]nofree\f[R] function is explicitly allowed to free memory which
it allocated or (if not \f[V]nosync\f[R]) arrange for another thread to
free memory on it\[aq]s behalf.
As a result, perhaps surprisingly, a \f[V]nofree\f[R] function can
return a pointer to a previously deallocated memory object.
.RE
.TP
\f[V]noimplicitfloat\f[R]
Disallows implicit floating-point code.
This inhibits optimizations that use floating-point code and
floating-point/SIMD/vector registers for operations that are not
nominally floating-point.
LLVM instructions that perform floating-point operations or require
access to floating-point registers may still cause floating-point code
to be generated.
.TP
\f[V]noinline\f[R]
This attribute indicates that the inliner should never inline this
function in any situation.
This attribute may not be used together with the \f[V]alwaysinline\f[R]
attribute.
.TP
\f[V]nomerge\f[R]
This attribute indicates that calls to this function should never be
merged during optimization.
For example, it will prevent tail merging otherwise identical code
sequences that raise an exception or terminate the program.
Tail merging normally reduces the precision of source location
information, making stack traces less useful for debugging.
This attribute gives the user control over the tradeoff between code
size and debug information precision.
.TP
\f[V]nonlazybind\f[R]
This attribute suppresses lazy symbol binding for the function.
This may make calls to the function faster, at the cost of extra program
startup time if the function is not called during program startup.
.TP
\f[V]noprofile\f[R]
This function attribute prevents instrumentation based profiling, used
for coverage or profile based optimization, from being added to a
function, even when inlined.
.TP
\f[V]noredzone\f[R]
This attribute indicates that the code generator should not use a red
zone, even if the target-specific ABI normally permits it.
.TP
\f[V]indirect-tls-seg-refs\f[R]
This attribute indicates that the code generator should not use direct
TLS access through segment registers, even if the target-specific ABI
normally permits it.
.TP
\f[V]noreturn\f[R]
This function attribute indicates that the function never returns
normally, hence through a return instruction.
This produces undefined behavior at runtime if the function ever does
dynamically return.
Annotated functions may still raise an exception, i.a.,
\f[V]nounwind\f[R] is not implied.
.TP
\f[V]norecurse\f[R]
This function attribute indicates that the function does not call itself
either directly or indirectly down any possible call path.
This produces undefined behavior at runtime if the function ever does
recurse.
.TP
\f[V]willreturn\f[R]
This function attribute indicates that a call of this function will
either exhibit undefined behavior or comes back and continues execution
at a point in the existing call stack that includes the current
invocation.
Annotated functions may still raise an exception, i.a.,
\f[V]nounwind\f[R] is not implied.
If an invocation of an annotated function does not return control back
to a point in the call stack, the behavior is undefined.
.TP
\f[V]nosync\f[R]
This function attribute indicates that the function does not communicate
(synchronize) with another thread through memory or other well-defined
means.
Synchronization is considered possible in the presence of atomic
accesses that enforce an order, thus not \[dq]unordered\[dq] and
\[dq]monotonic\[dq], volatile accesses, as well as convergent function
calls.
Note that through convergent function calls non-memory communication,
e.g., cross-lane operations, are possible and are also considered
synchronization.
However convergent does not contradict nosync.
If an annotated function does ever synchronize with another thread, the
behavior is undefined.
.TP
\f[V]nounwind\f[R]
This function attribute indicates that the function never raises an
exception.
If the function does raise an exception, its runtime behavior is
undefined.
However, functions marked nounwind may still trap or generate
asynchronous exceptions.
Exception handling schemes that are recognized by LLVM to handle
asynchronous exceptions, such as SEH, will still provide their
implementation defined semantics.
.TP
\f[V]nosanitize_bounds\f[R]
This attribute indicates that bounds checking sanitizer instrumentation
is disabled for this function.
.TP
\f[V]nosanitize_coverage\f[R]
This attribute indicates that SanitizerCoverage instrumentation is
disabled for this function.
.TP
\f[V]null_pointer_is_valid\f[R]
If \f[V]null_pointer_is_valid\f[R] is set, then the \f[V]null\f[R]
address in address-space 0 is considered to be a valid address for
memory loads and stores.
Any analysis or optimization should not treat dereferencing a pointer to
\f[V]null\f[R] as undefined behavior in this function.
Note: Comparing address of a global variable to \f[V]null\f[R] may still
evaluate to false because of a limitation in querying this attribute
inside constant expressions.
.TP
\f[V]optforfuzzing\f[R]
This attribute indicates that this function should be optimized for
maximum fuzzing signal.
.TP
\f[V]optnone\f[R]
This function attribute indicates that most optimization passes will
skip this function, with the exception of interprocedural optimization
passes.
Code generation defaults to the \[dq]fast\[dq] instruction selector.
This attribute cannot be used together with the \f[V]alwaysinline\f[R]
attribute; this attribute is also incompatible with the
\f[V]minsize\f[R] attribute and the \f[V]optsize\f[R] attribute.
.RS
.PP
This attribute requires the \f[V]noinline\f[R] attribute to be specified
on the function as well, so the function is never inlined into any
caller.
Only functions with the \f[V]alwaysinline\f[R] attribute are valid
candidates for inlining into the body of this function.
.RE
.TP
\f[V]optsize\f[R]
This attribute suggests that optimization passes and code generator
passes make choices that keep the code size of this function low, and
otherwise do optimizations specifically to reduce code size as long as
they do not significantly impact runtime performance.
.TP
\f[V]\[dq]patchable-function\[dq]\f[R]
This attribute tells the code generator that the code generated for this
function needs to follow certain conventions that make it possible for a
runtime function to patch over it later.
The exact effect of this attribute depends on its string value, for
which there currently is one legal possibility:
.RS
.RS
.IP \[bu] 2
\f[V]\[dq]prologue-short-redirect\[dq]\f[R] - This style of patchable
function is intended to support patching a function prologue to redirect
control away from the function in a thread safe manner.
It guarantees that the first instruction of the function will be large
enough to accommodate a short jump instruction, and will be sufficiently
aligned to allow being fully changed via an atomic compare-and-swap
instruction.
While the first requirement can be satisfied by inserting large enough
NOP, LLVM can and will try to re-purpose an existing instruction (i.e.
one that would have to be emitted anyway) as the patchable instruction
larger than a short jump.
.RS 2
.PP
\f[V]\[dq]prologue-short-redirect\[dq]\f[R] is currently only supported
on x86-64.
.RE
.RE
.PP
This attribute by itself does not imply restrictions on inter-procedural
optimizations.
All of the semantic effects the patching may have to be separately
conveyed via the linkage type.
.RE
.TP
\f[V]\[dq]probe-stack\[dq]\f[R]
This attribute indicates that the function will trigger a guard region
in the end of the stack.
It ensures that accesses to the stack must be no further apart than the
size of the guard region to a previous access of the stack.
It takes one required string value, the name of the stack probing
function that will be called.
.RS
.PP
If a function that has a \f[V]\[dq]probe-stack\[dq]\f[R] attribute is
inlined into a function with another \f[V]\[dq]probe-stack\[dq]\f[R]
attribute, the resulting function has the
\f[V]\[dq]probe-stack\[dq]\f[R] attribute of the caller.
If a function that has a \f[V]\[dq]probe-stack\[dq]\f[R] attribute is
inlined into a function that has no \f[V]\[dq]probe-stack\[dq]\f[R]
attribute at all, the resulting function has the
\f[V]\[dq]probe-stack\[dq]\f[R] attribute of the callee.
.RE
.TP
\f[V]readnone\f[R]
On a function, this attribute indicates that the function computes its
result (or decides to unwind an exception) based strictly on its
arguments, without dereferencing any pointer arguments or otherwise
accessing any mutable state (e.g.
memory, control registers, etc) visible outside the \f[V]readnone\f[R]
function.
It does not write through any pointer arguments (including
\f[V]byval\f[R] arguments) and never changes any state visible to
callers.
This means while it cannot unwind exceptions by calling the
\f[V]C++\f[R] exception throwing methods (since they write to memory),
there may be non-\f[V]C++\f[R] mechanisms that throw exceptions without
writing to LLVM visible memory.
.RS
.PP
On an argument, this attribute indicates that the function does not
dereference that pointer argument, even though it may read or write the
memory that the pointer points to if accessed through other pointers.
.PP
If a readnone function reads or writes memory visible outside the
function, or has other side-effects, the behavior is undefined.
If a function reads from or writes to a readnone pointer argument, the
behavior is undefined.
.RE
.TP
\f[V]readonly\f[R]
On a function, this attribute indicates that the function does not write
through any pointer arguments (including \f[V]byval\f[R] arguments) or
otherwise modify any state (e.g.
memory, control registers, etc) visible outside the \f[V]readonly\f[R]
function.
It may dereference pointer arguments and read state that may be set in
the caller.
A readonly function always returns the same value (or unwinds an
exception identically) when called with the same set of arguments and
global state.
This means while it cannot unwind exceptions by calling the
\f[V]C++\f[R] exception throwing methods (since they write to memory),
there may be non-\f[V]C++\f[R] mechanisms that throw exceptions without
writing to LLVM visible memory.
.RS
.PP
On an argument, this attribute indicates that the function does not
write through this pointer argument, even though it may write to the
memory that the pointer points to.
.PP
If a readonly function writes memory visible outside the function, or
has other side-effects, the behavior is undefined.
If a function writes to a readonly pointer argument, the behavior is
undefined.
.RE
.TP
\f[V]\[dq]stack-probe-size\[dq]\f[R]
This attribute controls the behavior of stack probes: either the
\f[V]\[dq]probe-stack\[dq]\f[R] attribute, or ABI-required stack probes,
if any.
It defines the size of the guard region.
It ensures that if the function may use more stack space than the size
of the guard region, stack probing sequence will be emitted.
It takes one required integer value, which is 4096 by default.
.RS
.PP
If a function that has a \f[V]\[dq]stack-probe-size\[dq]\f[R] attribute
is inlined into a function with another
\f[V]\[dq]stack-probe-size\[dq]\f[R] attribute, the resulting function
has the \f[V]\[dq]stack-probe-size\[dq]\f[R] attribute that has the
lower numeric value.
If a function that has a \f[V]\[dq]stack-probe-size\[dq]\f[R] attribute
is inlined into a function that has no
\f[V]\[dq]stack-probe-size\[dq]\f[R] attribute at all, the resulting
function has the \f[V]\[dq]stack-probe-size\[dq]\f[R] attribute of the
callee.
.RE
.TP
\f[V]\[dq]no-stack-arg-probe\[dq]\f[R]
This attribute disables ABI-required stack probes, if any.
.TP
\f[V]writeonly\f[R]
On a function, this attribute indicates that the function may write to
but does not read from memory visible outside the \f[V]writeonly\f[R]
function.
.RS
.PP
On an argument, this attribute indicates that the function may write to
but does not read through this pointer argument (even though it may read
from the memory that the pointer points to).
.PP
If a writeonly function reads memory visible outside the function or has
other side-effects, the behavior is undefined.
If a function reads from a writeonly pointer argument, the behavior is
undefined.
.RE
.TP
\f[V]argmemonly\f[R]
This attribute indicates that the only memory accesses inside function
are loads and stores from objects pointed to by its pointer-typed
arguments, with arbitrary offsets.
Or in other words, all memory operations in the function can refer to
memory only using pointers based on its function arguments.
.RS
.PP
Note that \f[V]argmemonly\f[R] can be used together with
\f[V]readonly\f[R] attribute in order to specify that function reads
only from its arguments.
.PP
If an argmemonly function reads or writes memory other than the pointer
arguments, or has other side-effects, the behavior is undefined.
.RE
.TP
\f[V]returns_twice\f[R]
This attribute indicates that this function can return twice.
The C \f[V]setjmp\f[R] is an example of such a function.
The compiler disables some optimizations (like tail calls) in the caller
of these functions.
.TP
\f[V]safestack\f[R]
This attribute indicates that
SafeStack (https://clang.llvm.org/docs/SafeStack.html) protection is
enabled for this function.
.RS
.PP
If a function that has a \f[V]safestack\f[R] attribute is inlined into a
function that doesn\[aq]t have a \f[V]safestack\f[R] attribute or which
has an \f[V]ssp\f[R], \f[V]sspstrong\f[R] or \f[V]sspreq\f[R] attribute,
then the resulting function will have a \f[V]safestack\f[R] attribute.
.RE
.TP
\f[V]sanitize_address\f[R]
This attribute indicates that AddressSanitizer checks (dynamic address
safety analysis) are enabled for this function.
.TP
\f[V]sanitize_memory\f[R]
This attribute indicates that MemorySanitizer checks (dynamic detection
of accesses to uninitialized memory) are enabled for this function.
.TP
\f[V]sanitize_thread\f[R]
This attribute indicates that ThreadSanitizer checks (dynamic thread
safety analysis) are enabled for this function.
.TP
\f[V]sanitize_hwaddress\f[R]
This attribute indicates that HWAddressSanitizer checks (dynamic address
safety analysis based on tagged pointers) are enabled for this function.
.TP
\f[V]sanitize_memtag\f[R]
This attribute indicates that MemTagSanitizer checks (dynamic address
safety analysis based on Armv8 MTE) are enabled for this function.
.TP
\f[V]speculative_load_hardening\f[R]
This attribute indicates that Speculative Load
Hardening (https://llvm.org/docs/SpeculativeLoadHardening.html) should
be enabled for the function body.
.RS
.PP
Speculative Load Hardening is a best-effort mitigation against
information leak attacks that make use of control flow miss-speculation
- specifically miss-speculation of whether a branch is taken or not.
Typically vulnerabilities enabling such attacks are classified as
\[dq]Spectre variant #1\[dq].
Notably, this does not attempt to mitigate against miss-speculation of
branch target, classified as \[dq]Spectre variant #2\[dq]
vulnerabilities.
.PP
When inlining, the attribute is sticky.
Inlining a function that carries this attribute will cause the caller to
gain the attribute.
This is intended to provide a maximally conservative model where the
code in a function annotated with this attribute will always (even after
inlining) end up hardened.
.RE
.TP
\f[V]speculatable\f[R]
This function attribute indicates that the function does not have any
effects besides calculating its result and does not have undefined
behavior.
Note that \f[V]speculatable\f[R] is not enough to conclude that along
any particular execution path the number of calls to this function will
not be externally observable.
This attribute is only valid on functions and declarations, not on
individual call sites.
If a function is incorrectly marked as speculatable and really does
exhibit undefined behavior, the undefined behavior may be observed even
if the call site is dead code.
.TP
\f[V]ssp\f[R]
This attribute indicates that the function should emit a stack smashing
protector.
It is in the form of a \[dq]canary\[dq] --- a random value placed on the
stack before the local variables that\[aq]s checked upon return from the
function to see if it has been overwritten.
A heuristic is used to determine if a function needs stack protectors or
not.
The heuristic used will enable protectors for functions with:
.RS
.IP \[bu] 2
Character arrays larger than \f[V]ssp-buffer-size\f[R] (default 8).
.IP \[bu] 2
Aggregates containing character arrays larger than
\f[V]ssp-buffer-size\f[R].
.IP \[bu] 2
Calls to alloca() with variable sizes or constant sizes greater than
\f[V]ssp-buffer-size\f[R].
.PP
Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
.PP
If a function with an \f[V]ssp\f[R] attribute is inlined into a calling
function, the attribute is not carried over to the calling function.
.RE
.TP
\f[V]sspstrong\f[R]
This attribute indicates that the function should emit a stack smashing
protector.
This attribute causes a strong heuristic to be used when determining if
a function needs stack protectors.
The strong heuristic will enable protectors for functions with:
.RS
.IP \[bu] 2
Arrays of any size and type
.IP \[bu] 2
Aggregates containing an array of any size and type.
.IP \[bu] 2
Calls to alloca().
.IP \[bu] 2
Local variables that have had their address taken.
.PP
Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:
.IP "1." 3
Large arrays and structures containing large arrays
(\f[V]>= ssp-buffer-size\f[R]) are closest to the stack protector.
.IP "2." 3
Small arrays and structures containing small arrays
(\f[V]< ssp-buffer-size\f[R]) are 2nd closest to the protector.
.IP "3." 3
Variables that have had their address taken are 3rd closest to the
protector.
.PP
This overrides the \f[V]ssp\f[R] function attribute.
.PP
If a function with an \f[V]sspstrong\f[R] attribute is inlined into a
calling function which has an \f[V]ssp\f[R] attribute, the calling
function\[aq]s attribute will be upgraded to \f[V]sspstrong\f[R].
.RE
.TP
\f[V]sspreq\f[R]
This attribute indicates that the function should \f[I]always\f[R] emit
a stack smashing protector.
This overrides the \f[V]ssp\f[R] and \f[V]sspstrong\f[R] function
attributes.
.RS
.PP
Variables that are identified as requiring a protector will be arranged
on the stack such that they are adjacent to the stack protector guard.
The specific layout rules are:
.IP "1." 3
Large arrays and structures containing large arrays
(\f[V]>= ssp-buffer-size\f[R]) are closest to the stack protector.
.IP "2." 3
Small arrays and structures containing small arrays
(\f[V]< ssp-buffer-size\f[R]) are 2nd closest to the protector.
.IP "3." 3
Variables that have had their address taken are 3rd closest to the
protector.
.PP
If a function with an \f[V]sspreq\f[R] attribute is inlined into a
calling function which has an \f[V]ssp\f[R] or \f[V]sspstrong\f[R]
attribute, the calling function\[aq]s attribute will be upgraded to
\f[V]sspreq\f[R].
.RE
.TP
\f[V]strictfp\f[R]
This attribute indicates that the function was called from a scope that
requires strict floating-point semantics.
LLVM will not attempt any optimizations that require assumptions about
the floating-point rounding mode or that might alter the state of
floating-point status flags that might otherwise be set or cleared by
calling this function.
LLVM will not introduce any new floating-point instructions that may
trap.
.TP
\f[V]\[dq]denormal-fp-math\[dq]\f[R]
This indicates the denormal (subnormal) handling that may be assumed for
the default floating-point environment.
This is a comma separated pair.
The elements may be one of \f[V]\[dq]ieee\[dq]\f[R],
\f[V]\[dq]preserve-sign\[dq]\f[R], or \f[V]\[dq]positive-zero\[dq]\f[R].
The first entry indicates the flushing mode for the result of floating
point operations.
The second indicates the handling of denormal inputs to floating point
instructions.
For compatibility with older bitcode, if the second value is omitted,
both input and output modes will assume the same mode.
.RS
.PP
If this is attribute is not specified, the default is
\f[V]\[dq]ieee,ieee\[dq]\f[R].
.PP
If the output mode is \f[V]\[dq]preserve-sign\[dq]\f[R], or
\f[V]\[dq]positive-zero\[dq]\f[R], denormal outputs may be flushed to
zero by standard floating-point operations.
It is not mandated that flushing to zero occurs, but if a denormal
output is flushed to zero, it must respect the sign mode.
Not all targets support all modes.
While this indicates the expected floating point mode the function will
be executed with, this does not make any attempt to ensure the mode is
consistent.
User or platform code is expected to set the floating point mode
appropriately before function entry.
.PP
If the input mode is \f[V]\[dq]preserve-sign\[dq]\f[R], or
\f[V]\[dq]positive-zero\[dq]\f[R], a floating-point operation must treat
any input denormal value as zero.
In some situations, if an instruction does not respect this mode, the
input may need to be converted to 0 as if by
\f[V]\[at]llvm.canonicalize\f[R] during lowering for correctness.
.RE
.TP
\f[V]\[dq]denormal-fp-math-f32\[dq]\f[R]
Same as \f[V]\[dq]denormal-fp-math\[dq]\f[R], but only controls the
behavior of the 32-bit float type (or vectors of 32-bit floats).
If both are are present, this overrides
\f[V]\[dq]denormal-fp-math\[dq]\f[R].
Not all targets support separately setting the denormal mode per type,
and no attempt is made to diagnose unsupported uses.
Currently this attribute is respected by the AMDGPU and NVPTX backends.
.TP
\f[V]\[dq]thunk\[dq]\f[R]
This attribute indicates that the function will delegate to some other
function with a tail call.
The prototype of a thunk should not be used for optimization purposes.
The caller is expected to cast the thunk prototype to match the thunk
target prototype.
.TP
\f[V]\[dq]tls-load-hoist\[dq]\f[R]
This attribute indicates that the function will try to reduce redundant
tls address calculation by hoisting tls variable.
.TP
\f[V]uwtable[(sync|async)]\f[R]
This attribute indicates that the ABI being targeted requires that an
unwind table entry be produced for this function even if we can show
that no exceptions passes by it.
This is normally the case for the ELF x86-64 abi, but it can be disabled
for some compilation units.
The optional parameter describes what kind of unwind tables to generate:
\f[V]sync\f[R] for normal unwind tables, \f[V]async\f[R] for
asynchronous (instruction precise) unwind tables.
Without the parameter, the attribute \f[V]uwtable\f[R] is equivalent to
\f[V]uwtable(async)\f[R].
.TP
\f[V]nocf_check\f[R]
This attribute indicates that no control-flow check will be performed on
the attributed entity.
It disables -fcf-protection=<> for a specific entity to fine grain the
HW control flow protection mechanism.
The flag is target independent and currently appertains to a function or
function pointer.
.TP
\f[V]shadowcallstack\f[R]
This attribute indicates that the ShadowCallStack checks are enabled for
the function.
The instrumentation checks that the return address for the function has
not changed between the function prolog and epilog.
It is currently x86_64-specific.
.TP
\f[V]mustprogress\f[R]
This attribute indicates that the function is required to return,
unwind, or interact with the environment in an observable way e.g.
via a volatile memory access, I/O, or other synchronization.
The \f[V]mustprogress\f[R] attribute is intended to model the
requirements of the first section of [intro.progress] of the C++
Standard.
As a consequence, a loop in a function with the mustprogress attribute
can be assumed to terminate if it does not interact with the environment
in an observable way, and terminating loops without side-effects can be
removed.
If a mustprogress function does not satisfy this contract, the behavior
is undefined.
This attribute does not apply transitively to callees, but does apply to
call sites within the function.
Note that willreturn implies mustprogress.
.TP
\f[V]\[dq]warn-stack-size\[dq]=\[dq]<threshold>\[dq]\f[R]
This attribute sets a threshold to emit diagnostics once the frame size
is known should the frame size exceed the specified value.
It takes one required integer value, which should be a non-negative
integer, and less than UINT_MAX.
It\[aq]s unspecified which threshold will be used when duplicate
definitions are linked together with differing values.
.TP
\f[V]vscale_range(<min>[, <max>])\f[R]
This attribute indicates the minimum and maximum vscale value for the
given function.
The min must be greater than 0.
A maximum value of 0 means unbounded.
If the optional max value is omitted then max is set to the value of
min.
If the attribute is not present, no assumptions are made about the range
of vscale.
.TP
\f[V]\[dq]min-legal-vector-width\[dq]=\[dq]<size>\[dq]\f[R]
This attribute indicates the minimum legal vector width required by the
calling conversion.
It is the maximum width of vector arguments and returnings in the
function and functions called by this function.
Because all the vectors are supposed to be legal type for compatibility.
Backends are free to ignore the attribute if they don\[aq]t need to
support different maximum legal vector types or such information can be
inferred by other attributes.
.SS Call Site Attributes
.PP
In addition to function attributes the following call site only
attributes are supported:
.TP
\f[V]vector-function-abi-variant\f[R]
This attribute can be attached to a \f[V]call <i_call>\f[R] to list the
vector functions associated to the function.
Notice that the attribute cannot be attached to a
\f[V]invoke <i_invoke>\f[R] or a \f[V]callbr <i_callbr>\f[R]
instruction.
The attribute consists of a comma separated list of mangled names.
The order of the list does not imply preference (it is logically a set).
The compiler is free to pick any listed vector function of its choosing.
.RS
.PP
The syntax for the mangled names is as follows::
.IP
.nf
\f[C]
_ZGV<isa><mask><vlen><parameters>_<scalar_name>[(<vector_redirection>)]
\f[R]
.fi
.PP
When present, the attribute informs the compiler that the function
\f[V]<scalar_name>\f[R] has a corresponding vector variant that can be
used to perform the concurrent invocation of \f[V]<scalar_name>\f[R] on
vectors.
The shape of the vector function is described by the tokens between the
prefix \f[V]_ZGV\f[R] and the \f[V]<scalar_name>\f[R] token.
The standard name of the vector function is
\f[V]_ZGV<isa><mask><vlen><parameters>_<scalar_name>\f[R].
When present, the optional token \f[V](<vector_redirection>)\f[R]
informs the compiler that a custom name is provided in addition to the
standard one (custom names can be provided for example via the use of
\f[V]declare variant\f[R] in OpenMP 5.0).
The declaration of the variant must be present in the IR Module.
The signature of the vector variant is determined by the rules of the
Vector Function ABI (VFABI) specifications of the target.
For Arm and X86, the VFABI can be found at
<https://github.com/ARM-software/abi-aa> and
<https://software.intel.com/content/www/us/en/develop/download/vector-simd-function-abi.html>,
respectively.
.PP
For X86 and Arm targets, the values of the tokens in the standard name
are those that are defined in the VFABI.
LLVM has an internal \f[V]<isa>\f[R] token that can be used to create
scalar-to-vector mappings for functions that are not directly associated
to any of the target ISAs (for example, some of the mappings stored in
the TargetLibraryInfo).
Valid values for the \f[V]<isa>\f[R] token are::
.IP
.nf
\f[C]
<isa>:= b | c | d | e  -> X86 SSE, AVX, AVX2, AVX512
      | n | s          -> Armv8 Advanced SIMD, SVE
      | __LLVM__       -> Internal LLVM Vector ISA
\f[R]
.fi
.PP
For all targets currently supported (x86, Arm and Internal LLVM), the
remaining tokens can have the following values::
.IP
.nf
\f[C]
<mask>:= M | N         -> mask | no mask

<vlen>:= number        -> number of lanes
       | x             -> VLA (Vector Length Agnostic)

<parameters>:= v              -> vector
             | l | l <number> -> linear
             | R | R <number> -> linear with ref modifier
             | L | L <number> -> linear with val modifier
             | U | U <number> -> linear with uval modifier
             | ls <pos>       -> runtime linear
             | Rs <pos>       -> runtime linear with ref modifier
             | Ls <pos>       -> runtime linear with val modifier
             | Us <pos>       -> runtime linear with uval modifier
             | u              -> uniform

<scalar_name>:= name of the scalar function

<vector_redirection>:= optional, custom name of the vector function
\f[R]
.fi
.RE
.TP
\f[V]preallocated(<ty>)\f[R]
This attribute is required on calls to
\f[V]llvm.call.preallocated.arg\f[R] and cannot be used on any other
call.
See \f[V]llvm.call.preallocated.arg<int_call_preallocated_arg>\f[R] for
more details.
.SS Global Attributes
.PP
Attributes may be set to communicate additional information about a
global variable.
Unlike \f[V]function attributes <fnattrs>\f[R], attributes on a global
variable are grouped into a single \f[V]attribute group <attrgrp>\f[R].
.TP
\f[V]no_sanitize\f[R]
This attribute indicates that the global variable should not have any
sanitizers applied to it, either because it was in the sanitizer ignore
list, or it was annotated with
__attribute__((disable_sanitizer_instrumentation)).
.TP
\f[V]no_sanitize_address\f[R]
This attribute indicates that the global variable should not have
AddressSanitizer instrumentation applied to it, because it was annotated
with __attribute__((no_sanitize(\[dq]address\[dq]))).
.TP
\f[V]no_sanitize_hwaddress\f[R]
This attribute indicates that the global variable should not have
HWAddressSanitizer instrumentation applied to it, because it was
annotated with __attribute__((no_sanitize(\[dq]hwaddress\[dq]))).
.TP
\f[V]sanitize_address_dyninit\f[R]
This attribute indicates that the global variable, when instrumented
with AddressSanitizer, should be checked for ODR violations.
This attribute is applied to global variables that are dynamically
initialized according to C++ rules.
.SS Operand Bundles
.PP
Operand bundles are tagged sets of SSA values that can be associated
with certain LLVM instructions (currently only \f[V]call\f[R] s and
\f[V]invoke\f[R] s).
In a way they are like metadata, but dropping them is incorrect and will
change program semantics.
.PP
Syntax:
.IP
.nf
\f[C]
operand bundle set ::= \[aq][\[aq] operand bundle (, operand bundle )* \[aq]]\[aq]
operand bundle ::= tag \[aq](\[aq] [ bundle operand ] (, bundle operand )* \[aq])\[aq]
bundle operand ::= SSA value
tag ::= string constant
\f[R]
.fi
.PP
Operand bundles are \f[B]not\f[R] part of a function\[aq]s signature,
and a given function may be called from multiple places with different
kinds of operand bundles.
This reflects the fact that the operand bundles are conceptually a part
of the \f[V]call\f[R] (or \f[V]invoke\f[R]), not the callee being
dispatched to.
.PP
Operand bundles are a generic mechanism intended to support
runtime-introspection-like functionality for managed languages.
While the exact semantics of an operand bundle depend on the bundle tag,
there are certain limitations to how much the presence of an operand
bundle can influence the semantics of a program.
These restrictions are described as the semantics of an
\[dq]unknown\[dq] operand bundle.
As long as the behavior of an operand bundle is describable within these
restrictions, LLVM does not need to have special knowledge of the
operand bundle to not miscompile programs containing it.
.IP \[bu] 2
The bundle operands for an unknown operand bundle escape in unknown ways
before control is transferred to the callee or invokee.
.IP \[bu] 2
Calls and invokes with operand bundles have unknown read / write effect
on the heap on entry and exit (even if the call target is
\f[V]readnone\f[R] or \f[V]readonly\f[R]), unless they\[aq]re overridden
with callsite specific attributes.
.IP \[bu] 2
An operand bundle at a call site cannot change the implementation of the
called function.
Inter-procedural optimizations work as usual as long as they take into
account the first two properties.
.PP
More specific types of operand bundles are described below.
.SS Deoptimization Operand Bundles
.PP
Deoptimization operand bundles are characterized by the
\f[V]\[dq]deopt\[dq]\f[R] operand bundle tag.
These operand bundles represent an alternate \[dq]safe\[dq] continuation
for the call site they\[aq]re attached to, and can be used by a suitable
runtime to deoptimize the compiled frame at the specified call site.
There can be at most one \f[V]\[dq]deopt\[dq]\f[R] operand bundle
attached to a call site.
Exact details of deoptimization is out of scope for the language
reference, but it usually involves rewriting a compiled frame into a set
of interpreted frames.
.PP
From the compiler\[aq]s perspective, deoptimization operand bundles make
the call sites they\[aq]re attached to at least \f[V]readonly\f[R].
They read through all of their pointer typed operands (even if
they\[aq]re not otherwise escaped) and the entire visible heap.
Deoptimization operand bundles do not capture their operands except
during deoptimization, in which case control will not be returned to the
compiled frame.
.PP
The inliner knows how to inline through calls that have deoptimization
operand bundles.
Just like inlining through a normal call site involves composing the
normal and exceptional continuations, inlining through a call site with
a deoptimization operand bundle needs to appropriately compose the
\[dq]safe\[dq] deoptimization continuation.
The inliner does this by prepending the parent\[aq]s deoptimization
continuation to every deoptimization continuation in the inlined body.
E.g.
inlining \f[V]\[at]f\f[R] into \f[V]\[at]g\f[R] in the following example
.IP
.nf
\f[C]
define void \[at]f() {
  call void \[at]x()  ;; no deopt state
  call void \[at]y() [ \[dq]deopt\[dq](i32 10) ]
  call void \[at]y() [ \[dq]deopt\[dq](i32 10), \[dq]unknown\[dq](i8* null) ]
  ret void
}

define void \[at]g() {
  call void \[at]f() [ \[dq]deopt\[dq](i32 20) ]
  ret void
}
\f[R]
.fi
.PP
will result in
.IP
.nf
\f[C]
define void \[at]g() {
  call void \[at]x()  ;; still no deopt state
  call void \[at]y() [ \[dq]deopt\[dq](i32 20, i32 10) ]
  call void \[at]y() [ \[dq]deopt\[dq](i32 20, i32 10), \[dq]unknown\[dq](i8* null) ]
  ret void
}
\f[R]
.fi
.PP
It is the frontend\[aq]s responsibility to structure or encode the
deoptimization state in a way that syntactically prepending the
caller\[aq]s deoptimization state to the callee\[aq]s deoptimization
state is semantically equivalent to composing the caller\[aq]s
deoptimization continuation after the callee\[aq]s deoptimization
continuation.
.SS Funclet Operand Bundles
.PP
Funclet operand bundles are characterized by the
\f[V]\[dq]funclet\[dq]\f[R] operand bundle tag.
These operand bundles indicate that a call site is within a particular
funclet.
There can be at most one \f[V]\[dq]funclet\[dq]\f[R] operand bundle
attached to a call site and it must have exactly one bundle operand.
.PP
If any funclet EH pads have been \[dq]entered\[dq] but not
\[dq]exited\[dq] (per the description in the EH doc), it is undefined
behavior to execute a \f[V]call\f[R] or \f[V]invoke\f[R] which:
.IP \[bu] 2
does not have a \f[V]\[dq]funclet\[dq]\f[R] bundle and is not a
\f[V]call\f[R] to a nounwind intrinsic, or
.IP \[bu] 2
has a \f[V]\[dq]funclet\[dq]\f[R] bundle whose operand is not the
most-recently-entered not-yet-exited funclet EH pad.
.PP
Similarly, if no funclet EH pads have been entered-but-not-yet-exited,
executing a \f[V]call\f[R] or \f[V]invoke\f[R] with a
\f[V]\[dq]funclet\[dq]\f[R] bundle is undefined behavior.
.SS GC Transition Operand Bundles
.PP
GC transition operand bundles are characterized by the
\f[V]\[dq]gc-transition\[dq]\f[R] operand bundle tag.
These operand bundles mark a call as a transition between a function
with one GC strategy to a function with a different GC strategy.
If coordinating the transition between GC strategies requires additional
code generation at the call site, these bundles may contain any values
that are needed by the generated code.
For more details, see \f[V]GC Transitions
<gc_transition_args>\f[R].
.PP
The bundle contain an arbitrary list of Values which need to be passed
to GC transition code.
They will be lowered and passed as operands to the appropriate
GC_TRANSITION nodes in the selection DAG.
It is assumed that these arguments must be available before and after
(but not necessarily during) the execution of the callee.
.SS Assume Operand Bundles
.PP
Operand bundles on an \f[V]llvm.assume <int_assume>\f[R] allows
representing assumptions that a
\f[V]parameter attribute <paramattrs>\f[R] or a
\f[V]function attribute <fnattrs>\f[R] holds for a certain value at a
certain location.
Operand bundles enable assumptions that are either hard or impossible to
represent as a boolean argument of an
\f[V]llvm.assume <int_assume>\f[R].
.PP
An assume operand bundle has the form:
.IP
.nf
\f[C]
\[dq]<tag>\[dq]([ <holds for value> [, <attribute argument>] ])
\f[R]
.fi
.IP \[bu] 2
The tag of the operand bundle is usually the name of attribute that can
be assumed to hold.
It can also be ignore, this tag doesn\[aq]t contain any information and
should be ignored.
.IP \[bu] 2
The first argument if present is the value for which the attribute hold.
.IP \[bu] 2
The second argument if present is an argument of the attribute.
.PP
If there are no arguments the attribute is a property of the call
location.
.PP
For example:
.IP
.nf
\f[C]
call void \[at]llvm.assume(i1 true) [\[dq]align\[dq](i32* %val, i32 8)]
\f[R]
.fi
.PP
allows the optimizer to assume that at location of call to
\f[V]llvm.assume <int_assume>\f[R] \f[V]%val\f[R] has an alignment of at
least 8.
.IP
.nf
\f[C]
call void \[at]llvm.assume(i1 %cond) [\[dq]cold\[dq](), \[dq]nonnull\[dq](i64* %val)]
\f[R]
.fi
.PP
allows the optimizer to assume that the
\f[V]llvm.assume <int_assume>\f[R] call location is cold and that
\f[V]%val\f[R] may not be null.
.PP
Just like for the argument of \f[V]llvm.assume <int_assume>\f[R], if any
of the provided guarantees are violated at runtime the behavior is
undefined.
.PP
While attributes expect constant arguments, assume operand bundles may
be provided a dynamic value, for example:
.IP
.nf
\f[C]
call void \[at]llvm.assume(i1 true) [\[dq]align\[dq](i32* %val, i32 %align)]
\f[R]
.fi
.PP
If the operand bundle value violates any requirements on the attribute
value, the behavior is undefined, unless one of the following exceptions
applies:
.IP \[bu] 2
\f[V]\[dq]assume\[dq]\f[R] operand bundles may specify a
non-power-of-two alignment (including a zero alignment).
If this is the case, then the pointer value must be a null pointer,
otherwise the behavior is undefined.
.PP
Even if the assumed property can be encoded as a boolean value, like
\f[V]nonnull\f[R], using operand bundles to express the property can
still have benefits:
.IP \[bu] 2
Attributes that can be expressed via operand bundles are directly the
property that the optimizer uses and cares about.
Encoding attributes as operand bundles removes the need for an
instruction sequence that represents the property (e.g., icmp ne i32*
%p, null for nonnull) and for the optimizer to deduce the property from
that instruction sequence.
.IP \[bu] 2
Expressing the property using operand bundles makes it easy to identify
the use of the value as a use in an \f[V]llvm.assume <int_assume>\f[R].
This then simplifies and improves heuristics, e.g., for use
\[dq]use-sensitive\[dq] optimizations.
.SS Preallocated Operand Bundles
.PP
Preallocated operand bundles are characterized by the
\f[V]\[dq]preallocated\[dq]\f[R] operand bundle tag.
These operand bundles allow separation of the allocation of the call
argument memory from the call site.
This is necessary to pass non-trivially copyable objects by value in a
way that is compatible with MSVC on some targets.
There can be at most one \f[V]\[dq]preallocated\[dq]\f[R] operand bundle
attached to a call site and it must have exactly one bundle operand,
which is a token generated by
\f[V]\[at]llvm.call.preallocated.setup\f[R].
A call with this operand bundle should not adjust the stack before
entering the function, as that will have been done by one of the
\f[V]\[at]llvm.call.preallocated.*\f[R] intrinsics.
.IP
.nf
\f[C]
%foo = type { i64, i32 }

\&...

%t = call token \[at]llvm.call.preallocated.setup(i32 1)
%a = call i8* \[at]llvm.call.preallocated.arg(token %t, i32 0) preallocated(%foo)
%b = bitcast i8* %a to %foo*
; initialize %b
call void \[at]bar(i32 42, %foo* preallocated(%foo) %b) [\[dq]preallocated\[dq](token %t)]
\f[R]
.fi
.SS GC Live Operand Bundles
.PP
A \[dq]gc-live\[dq] operand bundle is only valid on a
\f[V]gc.statepoint <gc_statepoint>\f[R] intrinsic.
The operand bundle must contain every pointer to a garbage collected
object which potentially needs to be updated by the garbage collector.
.PP
When lowered, any relocated value will be recorded in the corresponding
\f[V]stackmap entry <statepoint-stackmap-format>\f[R].
See the intrinsic description for further details.
.SS ObjC ARC Attached Call Operand Bundles
.PP
A \f[V]\[dq]clang.arc.attachedcall\[dq]\f[R] operand bundle on a call
indicates the call is implicitly followed by a marker instruction and a
call to an ObjC runtime function that uses the result of the call.
The operand bundle takes a mandatory pointer to the runtime function
(\f[V]\[at]objc_retainAutoreleasedReturnValue\f[R] or
\f[V]\[at]objc_unsafeClaimAutoreleasedReturnValue\f[R]).
The return value of a call with this bundle is used by a call to
\f[V]\[at]llvm.objc.clang.arc.noop.use\f[R] unless the called
function\[aq]s return type is void, in which case the operand bundle is
ignored.
.IP
.nf
\f[C]
; The marker instruction and a runtime function call are inserted after the call
; to \[at]foo.
call i8* \[at]foo() [ \[dq]clang.arc.attachedcall\[dq](i8* (i8*)* \[at]objc_retainAutoreleasedReturnValue) ]
call i8* \[at]foo() [ \[dq]clang.arc.attachedcall\[dq](i8* (i8*)* \[at]objc_unsafeClaimAutoreleasedReturnValue) ]
\f[R]
.fi
.PP
The operand bundle is needed to ensure the call is immediately followed
by the marker instruction and the ObjC runtime call in the final output.
.SS Pointer Authentication Operand Bundles
.PP
Pointer Authentication operand bundles are characterized by the
\f[V]\[dq]ptrauth\[dq]\f[R] operand bundle tag.
They are described in the Pointer Authentication document.
.SS Module-Level Inline Assembly
.PP
Modules may contain \[dq]module-level inline asm\[dq] blocks, which
corresponds to the GCC \[dq]file scope inline asm\[dq] blocks.
These blocks are internally concatenated by LLVM and treated as a single
unit, but may be separated in the \f[V].ll\f[R] file if desired.
The syntax is very simple:
.IP
.nf
\f[C]
module asm \[dq]inline asm code goes here\[dq]
module asm \[dq]more can go here\[dq]
\f[R]
.fi
.PP
The strings can contain any character by escaping non-printable
characters.
The escape sequence used is simply \[dq]\[rs]xx\[dq] where \[dq]xx\[dq]
is the two digit hex code for the number.
.PP
Note that the assembly string \f[I]must\f[R] be parseable by LLVM\[aq]s
integrated assembler (unless it is disabled), even when emitting a
\f[V].s\f[R] file.
.SS Data Layout
.PP
A module may specify a target specific data layout string that specifies
how data is to be laid out in memory.
The syntax for the data layout is simply:
.IP
.nf
\f[C]
target datalayout = \[dq]layout specification\[dq]
\f[R]
.fi
.PP
The \f[I]layout specification\f[R] consists of a list of specifications
separated by the minus sign character (\[aq]-\[aq]).
Each specification starts with a letter and may include other
information after the letter to define some aspect of the data layout.
The specifications accepted are as follows:
.TP
\f[V]E\f[R]
Specifies that the target lays out data in big-endian form.
That is, the bits with the most significance have the lowest address
location.
.TP
\f[V]e\f[R]
Specifies that the target lays out data in little-endian form.
That is, the bits with the least significance have the lowest address
location.
.TP
\f[V]S<size>\f[R]
Specifies the natural alignment of the stack in bits.
Alignment promotion of stack variables is limited to the natural stack
alignment to avoid dynamic stack realignment.
The stack alignment must be a multiple of 8-bits.
If omitted, the natural stack alignment defaults to
\[dq]unspecified\[dq], which does not prevent any alignment promotions.
.TP
\f[V]P<address space>\f[R]
Specifies the address space that corresponds to program memory.
Harvard architectures can use this to specify what space LLVM should
place things such as functions into.
If omitted, the program memory space defaults to the default address
space of 0, which corresponds to a Von Neumann architecture that has
code and data in the same space.
.TP
\f[V]G<address space>\f[R]
Specifies the address space to be used by default when creating global
variables.
If omitted, the globals address space defaults to the default address
space 0.
Note: variable declarations without an address space are always created
in address space 0, this property only affects the default value to be
used when creating globals without additional contextual information
(e.g.
in LLVM passes).
.TP
\f[V]A<address space>\f[R]
Specifies the address space of objects created by
\[aq]\f[V]alloca\f[R]\[aq].
Defaults to the default address space of 0.
.TP
\f[V]p[n]:<size>:<abi>[:<pref>][:<idx>]\f[R]
This specifies the \f[I]size\f[R] of a pointer and its \f[V]<abi>\f[R]
and \f[V]<pref>\f[R]erred alignments for address space \f[V]n\f[R].
\f[V]<pref>\f[R] is optional and defaults to \f[V]<abi>\f[R].
The fourth parameter \f[V]<idx>\f[R] is the size of the index that used
for address calculation.
If not specified, the default index size is equal to the pointer size.
All sizes are in bits.
The address space, \f[V]n\f[R], is optional, and if not specified,
denotes the default address space 0.
The value of \f[V]n\f[R] must be in the range [1,2\[ha]23).
.TP
\f[V]i<size>:<abi>[:<pref>]\f[R]
This specifies the alignment for an integer type of a given bit
\f[V]<size>\f[R].
The value of \f[V]<size>\f[R] must be in the range [1,2\[ha]23).
\f[V]<pref>\f[R] is optional and defaults to \f[V]<abi>\f[R].
.TP
\f[V]v<size>:<abi>[:<pref>]\f[R]
This specifies the alignment for a vector type of a given bit
\f[V]<size>\f[R].
The value of \f[V]<size>\f[R] must be in the range [1,2\[ha]23).
\f[V]<pref>\f[R] is optional and defaults to \f[V]<abi>\f[R].
.TP
\f[V]f<size>:<abi>[:<pref>]\f[R]
This specifies the alignment for a floating-point type of a given bit
\f[V]<size>\f[R].
Only values of \f[V]<size>\f[R] that are supported by the target will
work.
32 (float) and 64 (double) are supported on all targets; 80 or 128
(different flavors of long double) are also supported on some targets.
The value of \f[V]<size>\f[R] must be in the range [1,2\[ha]23).
\f[V]<pref>\f[R] is optional and defaults to \f[V]<abi>\f[R].
.TP
\f[V]a:<abi>[:<pref>]\f[R]
This specifies the alignment for an object of aggregate type.
\f[V]<pref>\f[R] is optional and defaults to \f[V]<abi>\f[R].
.TP
\f[V]F<type><abi>\f[R]
This specifies the alignment for function pointers.
The options for \f[V]<type>\f[R] are:
.RS
.IP \[bu] 2
\f[V]i\f[R]: The alignment of function pointers is independent of the
alignment of functions, and is a multiple of \f[V]<abi>\f[R].
.IP \[bu] 2
\f[V]n\f[R]: The alignment of function pointers is a multiple of the
explicit alignment specified on the function, and is a multiple of
\f[V]<abi>\f[R].
.RE
.TP
\f[V]m:<mangling>\f[R]
If present, specifies that llvm names are mangled in the output.
Symbols prefixed with the mangling escape character \f[V]\[rs]01\f[R]
are passed through directly to the assembler without the escape
character.
The mangling style options are
.RS
.IP \[bu] 2
\f[V]e\f[R]: ELF mangling: Private symbols get a \f[V].L\f[R] prefix.
.IP \[bu] 2
\f[V]l\f[R]: GOFF mangling: Private symbols get a \f[V]\[at]\f[R]
prefix.
.IP \[bu] 2
\f[V]m\f[R]: Mips mangling: Private symbols get a \f[V]$\f[R] prefix.
.IP \[bu] 2
\f[V]o\f[R]: Mach-O mangling: Private symbols get \f[V]L\f[R] prefix.
Other symbols get a \f[V]_\f[R] prefix.
.IP \[bu] 2
\f[V]x\f[R]: Windows x86 COFF mangling: Private symbols get the usual
prefix.
Regular C symbols get a \f[V]_\f[R] prefix.
Functions with \f[V]__stdcall\f[R], \f[V]__fastcall\f[R], and
\f[V]__vectorcall\f[R] have custom mangling that appends
\f[V]\[at]N\f[R] where N is the number of bytes used to pass parameters.
C++ symbols starting with \f[V]?\f[R] are not mangled in any way.
.IP \[bu] 2
\f[V]w\f[R]: Windows COFF mangling: Similar to \f[V]x\f[R], except that
normal C symbols do not receive a \f[V]_\f[R] prefix.
.IP \[bu] 2
\f[V]a\f[R]: XCOFF mangling: Private symbols get a \f[V]L..\f[R] prefix.
.RE
.TP
\f[V]n<size1>:<size2>:<size3>...\f[R]
This specifies a set of native integer widths for the target CPU in
bits.
For example, it might contain \f[V]n32\f[R] for 32-bit PowerPC,
\f[V]n32:64\f[R] for PowerPC 64, or \f[V]n8:16:32:64\f[R] for X86-64.
Elements of this set are considered to support most general arithmetic
operations efficiently.
.TP
\f[V]ni:<address space0>:<address space1>:<address space2>...\f[R]
This specifies pointer types with the specified address spaces as
\f[V]Non-Integral Pointer Type <nointptrtype>\f[R] s.
The \f[V]0\f[R] address space cannot be specified as non-integral.
.PP
On every specification that takes a \f[V]<abi>:<pref>\f[R], specifying
the \f[V]<pref>\f[R] alignment is optional.
If omitted, the preceding \f[V]:\f[R] should be omitted too and
\f[V]<pref>\f[R] will be equal to \f[V]<abi>\f[R].
.PP
When constructing the data layout for a given target, LLVM starts with a
default set of specifications which are then (possibly) overridden by
the specifications in the \f[V]datalayout\f[R] keyword.
The default specifications are given in this list:
.IP \[bu] 2
\f[V]e\f[R] - little endian
.IP \[bu] 2
\f[V]p:64:64:64\f[R] - 64-bit pointers with 64-bit alignment.
.IP \[bu] 2
\f[V]p[n]:64:64:64\f[R] - Other address spaces are assumed to be the
same as the default address space.
.IP \[bu] 2
\f[V]S0\f[R] - natural stack alignment is unspecified
.IP \[bu] 2
\f[V]i1:8:8\f[R] - i1 is 8-bit (byte) aligned
.IP \[bu] 2
\f[V]i8:8:8\f[R] - i8 is 8-bit (byte) aligned
.IP \[bu] 2
\f[V]i16:16:16\f[R] - i16 is 16-bit aligned
.IP \[bu] 2
\f[V]i32:32:32\f[R] - i32 is 32-bit aligned
.IP \[bu] 2
\f[V]i64:32:64\f[R] - i64 has ABI alignment of 32-bits but preferred
alignment of 64-bits
.IP \[bu] 2
\f[V]f16:16:16\f[R] - half is 16-bit aligned
.IP \[bu] 2
\f[V]f32:32:32\f[R] - float is 32-bit aligned
.IP \[bu] 2
\f[V]f64:64:64\f[R] - double is 64-bit aligned
.IP \[bu] 2
\f[V]f128:128:128\f[R] - quad is 128-bit aligned
.IP \[bu] 2
\f[V]v64:64:64\f[R] - 64-bit vector is 64-bit aligned
.IP \[bu] 2
\f[V]v128:128:128\f[R] - 128-bit vector is 128-bit aligned
.IP \[bu] 2
\f[V]a:0:64\f[R] - aggregates are 64-bit aligned
.PP
When LLVM is determining the alignment for a given type, it uses the
following rules:
.IP "1." 3
If the type sought is an exact match for one of the specifications, that
specification is used.
.IP "2." 3
If no match is found, and the type sought is an integer type, then the
smallest integer type that is larger than the bitwidth of the sought
type is used.
If none of the specifications are larger than the bitwidth then the
largest integer type is used.
For example, given the default specifications above, the i7 type will
use the alignment of i8 (next largest) while both i65 and i256 will use
the alignment of i64 (largest specified).
.PP
The function of the data layout string may not be what you expect.
Notably, this is not a specification from the frontend of what alignment
the code generator should use.
.PP
Instead, if specified, the target data layout is required to match what
the ultimate \f[I]code generator\f[R] expects.
This string is used by the mid-level optimizers to improve code, and
this only works if it matches what the ultimate code generator uses.
There is no way to generate IR that does not embed this target-specific
detail into the IR.
If you don\[aq]t specify the string, the default specifications will be
used to generate a Data Layout and the optimization phases will operate
accordingly and introduce target specificity into the IR with respect to
these default specifications.
.SS Target Triple
.PP
A module may specify a target triple string that describes the target
host.
The syntax for the target triple is simply:
.IP
.nf
\f[C]
target triple = \[dq]x86_64-apple-macosx10.7.0\[dq]
\f[R]
.fi
.PP
The \f[I]target triple\f[R] string consists of a series of identifiers
delimited by the minus sign character (\[aq]-\[aq]).
The canonical forms are:
.IP
.nf
\f[C]
ARCHITECTURE-VENDOR-OPERATING_SYSTEM
ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
\f[R]
.fi
.PP
This information is passed along to the backend so that it generates
code for the proper architecture.
It\[aq]s possible to override this on the command line with the
\f[V]-mtriple\f[R] command line option.
.SS Object Lifetime
.PP
A memory object, or simply object, is a region of a memory space that is
reserved by a memory allocation such as \f[V]alloca <i_alloca>\f[R],
heap allocation calls, and global variable definitions.
Once it is allocated, the bytes stored in the region can only be read or
written through a pointer that is \f[V]based on <pointeraliasing>\f[R]
the allocation value.
If a pointer that is not based on the object tries to read or write to
the object, it is undefined behavior.
.PP
A lifetime of a memory object is a property that decides its
accessibility.
Unless stated otherwise, a memory object is alive since its allocation,
and dead after its deallocation.
It is undefined behavior to access a memory object that isn\[aq]t alive,
but operations that don\[aq]t dereference it such as
\f[V]getelementptr <i_getelementptr>\f[R],
\f[V]ptrtoint <i_ptrtoint>\f[R] and \f[V]icmp <i_icmp>\f[R] return a
valid result.
This explains code motion of these instructions across operations that
impact the object\[aq]s lifetime.
A stack object\[aq]s lifetime can be explicitly specified using
\f[V]llvm.lifetime.start <int_lifestart>\f[R] and
\f[V]llvm.lifetime.end <int_lifeend>\f[R] intrinsic function calls.
.SS Pointer Aliasing Rules
.PP
Any memory access must be done through a pointer value associated with
an address range of the memory access, otherwise the behavior is
undefined.
Pointer values are associated with address ranges according to the
following rules:
.IP \[bu] 2
A pointer value is associated with the addresses associated with any
value it is \f[I]based\f[R] on.
.IP \[bu] 2
An address of a global variable is associated with the address range of
the variable\[aq]s storage.
.IP \[bu] 2
The result value of an allocation instruction is associated with the
address range of the allocated storage.
.IP \[bu] 2
A null pointer in the default address-space is associated with no
address.
.IP \[bu] 2
An \f[V]undef value <undefvalues>\f[R] in \f[I]any\f[R] address-space is
associated with no address.
.IP \[bu] 2
An integer constant other than zero or a pointer value returned from a
function not defined within LLVM may be associated with address ranges
allocated through mechanisms other than those provided by LLVM.
Such ranges shall not overlap with any ranges of addresses allocated by
mechanisms provided by LLVM.
.PP
A pointer value is \f[I]based\f[R] on another pointer value according to
the following rules:
.IP \[bu] 2
A pointer value formed from a scalar \f[V]getelementptr\f[R] operation
is \f[I]based\f[R] on the pointer-typed operand of the
\f[V]getelementptr\f[R].
.IP \[bu] 2
The pointer in lane \f[I]l\f[R] of the result of a vector
\f[V]getelementptr\f[R] operation is \f[I]based\f[R] on the pointer in
lane \f[I]l\f[R] of the vector-of-pointers-typed operand of the
\f[V]getelementptr\f[R].
.IP \[bu] 2
The result value of a \f[V]bitcast\f[R] is \f[I]based\f[R] on the
operand of the \f[V]bitcast\f[R].
.IP \[bu] 2
A pointer value formed by an \f[V]inttoptr\f[R] is \f[I]based\f[R] on
all pointer values that contribute (directly or indirectly) to the
computation of the pointer\[aq]s value.
.IP \[bu] 2
The \[dq]\f[I]based\f[R] on\[dq] relationship is transitive.
.PP
Note that this definition of \f[I]\[dq]based\[dq]\f[R] is intentionally
similar to the definition of \f[I]\[dq]based\[dq]\f[R] in C99, though it
is slightly weaker.
.PP
LLVM IR does not associate types with memory.
The result type of a \f[V]load\f[R] merely indicates the size and
alignment of the memory from which to load, as well as the
interpretation of the value.
The first operand type of a \f[V]store\f[R] similarly only indicates the
size and alignment of the store.
.PP
Consequently, type-based alias analysis, aka TBAA, aka
\f[V]-fstrict-aliasing\f[R], is not applicable to general unadorned LLVM
IR.
\f[V]Metadata <metadata>\f[R] may be used to encode additional
information which specialized optimization passes may use to implement
type-based alias analysis.
.SS Pointer Capture
.PP
Given a function call and a pointer that is passed as an argument or
stored in the memory before the call, a pointer is \f[I]captured\f[R] by
the call if it makes a copy of any part of the pointer that outlives the
call.
To be precise, a pointer is captured if one or more of the following
conditions hold:
.IP "1." 3
The call stores any bit of the pointer carrying information into a
place, and the stored bits can be read from the place by the caller
after this call exits.
.IP
.nf
\f[C]
\[at]glb  = global i8* null
\[at]glb2 = global i8* null
\[at]glb3 = global i8* null
\[at]glbi = global i32 0

define i8* \[at]f(i8* %a, i8* %b, i8* %c, i8* %d, i8* %e) {
  store i8* %a, i8** \[at]glb ; %a is captured by this call

  store i8* %b,   i8** \[at]glb2 ; %b isn\[aq]t captured because the stored value is overwritten by the store below
  store i8* null, i8** \[at]glb2

  store i8* %c,   i8** \[at]glb3
  call void \[at]g() ; If \[at]g makes a copy of %c that outlives this call (\[at]f), %c is captured
  store i8* null, i8** \[at]glb3

  %i = ptrtoint i8* %d to i64
  %j = trunc i64 %i to i32
  store i32 %j, i32* \[at]glbi ; %d is captured

  ret i8* %e ; %e is captured
}
\f[R]
.fi
.IP "2." 3
The call stores any bit of the pointer carrying information into a
place, and the stored bits can be safely read from the place by another
thread via synchronization.
.IP
.nf
\f[C]
\[at]lock = global i1 true

define void \[at]f(i8* %a) {
  store i8* %a, i8** \[at]glb
  store atomic i1 false, i1* \[at]lock release ; %a is captured because another thread can safely read \[at]glb
  store i8* null, i8** \[at]glb
  ret void
}
\f[R]
.fi
.IP "3." 3
The call\[aq]s behavior depends on any bit of the pointer carrying
information.
.IP
.nf
\f[C]
\[at]glb = global i8 0

define void \[at]f(i8* %a) {
  %c = icmp eq i8* %a, \[at]glb
  br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a
BB_EXIT:
  call void \[at]exit()
  unreachable
BB_CONTINUE:
  ret void
}
\f[R]
.fi
.IP "4." 3
The pointer is used in a volatile access as its address.
.SS Volatile Memory Accesses
.PP
Certain memory accesses, such as \f[V]load <i_load>\f[R]\[aq]s,
\f[V]store <i_store>\f[R]\[aq]s, and
\f[V]llvm.memcpy <int_memcpy>\f[R]\[aq]s may be marked
\f[V]volatile\f[R].
The optimizers must not change the number of volatile operations or
change their order of execution relative to other volatile operations.
The optimizers \f[I]may\f[R] change the order of volatile operations
relative to non-volatile operations.
This is not Java\[aq]s \[dq]volatile\[dq] and has no cross-thread
synchronization behavior.
.PP
A volatile load or store may have additional target-specific semantics.
Any volatile operation can have side effects, and any volatile operation
can read and/or modify state which is not accessible via a regular load
or store in this module.
Volatile operations may use addresses which do not point to memory (like
MMIO registers).
This means the compiler may not use a volatile operation to prove a
non-volatile access to that address has defined behavior.
.PP
The allowed side-effects for volatile accesses are limited.
If a non-volatile store to a given address would be legal, a volatile
operation may modify the memory at that address.
A volatile operation may not modify any other memory accessible by the
module being compiled.
A volatile operation may not call any code in the current module.
.PP
The compiler may assume execution will continue after a volatile
operation, so operations which modify memory or may have undefined
behavior can be hoisted past a volatile operation.
.PP
As an exception to the preceding rule, the compiler may not assume
execution will continue after a volatile store operation.
This restriction is necessary to support the somewhat common pattern in
C of intentionally storing to an invalid pointer to crash the program.
In the future, it might make sense to allow frontends to control this
behavior.
.PP
IR-level volatile loads and stores cannot safely be optimized into
llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are
flagged volatile.
Likewise, the backend should never split or merge target-legal volatile
load/store instructions.
Similarly, IR-level volatile loads and stores cannot change from integer
to floating-point or vice versa.
.PP
Rationale
.PP
Platforms may rely on volatile loads and stores of natively supported
data width to be executed as single instruction.
For example, in C this holds for an l-value of volatile primitive type
with native hardware support, but not necessarily for aggregate types.
The frontend upholds these expectations, which are intentionally
unspecified in the IR.
The rules above ensure that IR transformations do not violate the
frontend\[aq]s contract with the language.
.SS Memory Model for Concurrent Operations
.PP
The LLVM IR does not define any way to start parallel threads of
execution or to register signal handlers.
Nonetheless, there are platform-specific ways to create them, and we
define LLVM IR\[aq]s behavior in their presence.
This model is inspired by the C++0x memory model.
.PP
For a more informal introduction to this model, see the
\f[V]Atomics\f[R].
.PP
We define a \f[I]happens-before\f[R] partial order as the least partial
order that
.IP \[bu] 2
Is a superset of single-thread program order, and
.IP \[bu] 2
When a \f[I]synchronizes-with\f[R] \f[V]b\f[R], includes an edge from
\f[V]a\f[R] to \f[V]b\f[R].
\f[I]Synchronizes-with\f[R] pairs are introduced by platform-specific
techniques, like pthread locks, thread creation, thread joining, etc.,
and by atomic instructions.
(See also \f[V]Atomic Memory Ordering
Constraints <ordering>\f[R]).
.PP
Note that program order does not introduce \f[I]happens-before\f[R]
edges between a thread and signals executing inside that thread.
.PP
Every (defined) read operation (load instructions, memcpy, atomic
loads/read-modify-writes, etc.)
R reads a series of bytes written by (defined) write operations (store
instructions, atomic stores/read-modify-writes, memcpy, etc.).
For the purposes of this section, initialized globals are considered to
have a write of the initializer which is atomic and happens before any
other read or write of the memory in question.
For each byte of a read R, R~byte~ may see any write to the same byte,
except:
.IP \[bu] 2
If write~1~ happens before write~2~, and write~2~ happens before
R~byte~, then R~byte~ does not see write~1~.
.IP \[bu] 2
If R~byte~ happens before write~3~, then R~byte~ does not see write~3~.
.PP
Given that definition, R~byte~ is defined as follows:
.IP \[bu] 2
If R is volatile, the result is target-dependent.
(Volatile is supposed to give guarantees which can support
\f[V]sig_atomic_t\f[R] in C/C++, and may be used for accesses to
addresses that do not behave like normal memory.
It does not generally provide cross-thread synchronization.)
.IP \[bu] 2
Otherwise, if there is no write to the same byte that happens before
R~byte~, R~byte~ returns \f[V]undef\f[R] for that byte.
.IP \[bu] 2
Otherwise, if R~byte~ may see exactly one write, R~byte~ returns the
value written by that write.
.IP \[bu] 2
Otherwise, if R is atomic, and all the writes R~byte~ may see are
atomic, it chooses one of the values written.
See the \f[V]Atomic
Memory Ordering Constraints <ordering>\f[R] section for additional
constraints on how the choice is made.
.IP \[bu] 2
Otherwise R~byte~ returns \f[V]undef\f[R].
.PP
R returns the value composed of the series of bytes it read.
This implies that some bytes within the value may be \f[V]undef\f[R]
\f[B]without\f[R] the entire value being \f[V]undef\f[R].
Note that this only defines the semantics of the operation; it
doesn\[aq]t mean that targets will emit more than one instruction to
read the series of bytes.
.PP
Note that in cases where none of the atomic intrinsics are used, this
model places only one restriction on IR transformations on top of what
is required for single-threaded execution: introducing a store to a byte
which might not otherwise be stored is not allowed in general.
(Specifically, in the case where another thread might write to and read
from an address, introducing a store can change a load that may see
exactly one write into a load that may see multiple writes.)
.SS Atomic Memory Ordering Constraints
.PP
Atomic instructions (\f[V]cmpxchg <i_cmpxchg>\f[R],
\f[V]atomicrmw <i_atomicrmw>\f[R], \f[V]fence <i_fence>\f[R],
\f[V]atomic load <i_load>\f[R], and \f[V]atomic store <i_store>\f[R])
take ordering parameters that determine which other atomic instructions
on the same address they \f[I]synchronize with\f[R].
These semantics are borrowed from Java and C++0x, but are somewhat more
colloquial.
If these descriptions aren\[aq]t precise enough, check those specs (see
spec references in the \f[V]atomics guide <Atomics>\f[R]).
\f[V]fence <i_fence>\f[R] instructions treat these orderings somewhat
differently since they don\[aq]t take an address.
See that instruction\[aq]s documentation for details.
.PP
For a simpler introduction to the ordering constraints, see the
\f[V]Atomics\f[R].
.TP
\f[V]unordered\f[R]
The set of values that can be read is governed by the happens-before
partial order.
A value cannot be read unless some operation wrote it.
This is intended to provide a guarantee strong enough to model
Java\[aq]s non-volatile shared variables.
This ordering cannot be specified for read-modify-write operations; it
is not strong enough to make them atomic in any interesting way.
.TP
\f[V]monotonic\f[R]
In addition to the guarantees of \f[V]unordered\f[R], there is a single
total order for modifications by \f[V]monotonic\f[R] operations on each
address.
All modification orders must be compatible with the happens-before
order.
There is no guarantee that the modification orders can be combined to a
global total order for the whole program (and this often will not be
possible).
The read in an atomic read-modify-write operation
(\f[V]cmpxchg <i_cmpxchg>\f[R] and \f[V]atomicrmw <i_atomicrmw>\f[R])
reads the value in the modification order immediately before the value
it writes.
If one atomic read happens before another atomic read of the same
address, the later read must see the same value or a later value in the
address\[aq]s modification order.
This disallows reordering of \f[V]monotonic\f[R] (or stronger)
operations on the same address.
If an address is written \f[V]monotonic\f[R]-ally by one thread, and
other threads \f[V]monotonic\f[R]-ally read that address repeatedly, the
other threads must eventually see the write.
This corresponds to the C++0x/C1x \f[V]memory_order_relaxed\f[R].
.TP
\f[V]acquire\f[R]
In addition to the guarantees of \f[V]monotonic\f[R], a
\f[I]synchronizes-with\f[R] edge may be formed with a \f[V]release\f[R]
operation.
This is intended to model C++\[aq]s \f[V]memory_order_acquire\f[R].
.TP
\f[V]release\f[R]
In addition to the guarantees of \f[V]monotonic\f[R], if this operation
writes a value which is subsequently read by an \f[V]acquire\f[R]
operation, it \f[I]synchronizes-with\f[R] that operation.
(This isn\[aq]t a complete description; see the C++0x definition of a
release sequence.)
This corresponds to the C++0x/C1x \f[V]memory_order_release\f[R].
.TP
\f[V]acq_rel\f[R] (acquire+release)
Acts as both an \f[V]acquire\f[R] and \f[V]release\f[R] operation on its
address.
This corresponds to the C++0x/C1x \f[V]memory_order_acq_rel\f[R].
.TP
\f[V]seq_cst\f[R] (sequentially consistent)
In addition to the guarantees of \f[V]acq_rel\f[R] (\f[V]acquire\f[R]
for an operation that only reads, \f[V]release\f[R] for an operation
that only writes), there is a global total order on all
sequentially-consistent operations on all addresses, which is consistent
with the \f[I]happens-before\f[R] partial order and with the
modification orders of all the affected addresses.
Each sequentially-consistent read sees the last preceding write to the
same address in this global order.
This corresponds to the C++0x/C1x \f[V]memory_order_seq_cst\f[R] and
Java volatile.
.PP
If an atomic operation is marked
\f[V]syncscope(\[dq]singlethread\[dq])\f[R], it only \f[I]synchronizes
with\f[R] and only participates in the seq_cst total orderings of other
operations running in the same thread (for example, in signal handlers).
.PP
If an atomic operation is marked
\f[V]syncscope(\[dq]<target-scope>\[dq])\f[R], where
\f[V]<target-scope>\f[R] is a target specific synchronization scope,
then it is target dependent if it \f[I]synchronizes with\f[R] and
participates in the seq_cst total orderings of other operations.
.PP
Otherwise, an atomic operation that is not marked
\f[V]syncscope(\[dq]singlethread\[dq])\f[R] or
\f[V]syncscope(\[dq]<target-scope>\[dq])\f[R] \f[I]synchronizes
with\f[R] and participates in the seq_cst total orderings of other
operations that are not marked
\f[V]syncscope(\[dq]singlethread\[dq])\f[R] or
\f[V]syncscope(\[dq]<target-scope>\[dq])\f[R].
.SS Floating-Point Environment
.PP
The default LLVM floating-point environment assumes that floating-point
instructions do not have side effects.
Results assume the round-to-nearest rounding mode.
No floating-point exception state is maintained in this environment.
Therefore, there is no attempt to create or preserve invalid operation
(SNaN) or division-by-zero exceptions.
.PP
The benefit of this exception-free assumption is that floating-point
operations may be speculated freely without any other fast-math
relaxations to the floating-point model.
.PP
Code that requires different behavior than this should use the
\f[V]Constrained Floating-Point Intrinsics <constrainedfp>\f[R].
.SS Fast-Math Flags
.PP
LLVM IR floating-point operations (\f[V]fneg <i_fneg>\f[R],
\f[V]fadd <i_fadd>\f[R], \f[V]fsub <i_fsub>\f[R],
\f[V]fmul <i_fmul>\f[R], \f[V]fdiv <i_fdiv>\f[R],
\f[V]frem <i_frem>\f[R], \f[V]fcmp <i_fcmp>\f[R]),
\f[V]phi <i_phi>\f[R], \f[V]select <i_select>\f[R] and
\f[V]call <i_call>\f[R] may use the following flags to enable otherwise
unsafe floating-point transformations.
.TP
\f[V]nnan\f[R]
No NaNs - Allow optimizations to assume the arguments and result are not
NaN.
If an argument is a nan, or the result would be a nan, it produces a
\f[V]poison value <poisonvalues>\f[R] instead.
.TP
\f[V]ninf\f[R]
No Infs - Allow optimizations to assume the arguments and result are not
+/-Inf.
If an argument is +/-Inf, or the result would be +/-Inf, it produces a
\f[V]poison value <poisonvalues>\f[R] instead.
.TP
\f[V]nsz\f[R]
No Signed Zeros - Allow optimizations to treat the sign of a zero
argument or result as insignificant.
This does not imply that -0.0 is poison and/or guaranteed to not exist
in the operation.
.TP
\f[V]arcp\f[R]
Allow Reciprocal - Allow optimizations to use the reciprocal of an
argument rather than perform division.
.TP
\f[V]contract\f[R]
Allow floating-point contraction (e.g.
fusing a multiply followed by an addition into a fused
multiply-and-add).
This does not enable reassociating to form arbitrary contractions.
For example, \f[V](a*b) + (c*d) + e\f[R] can not be transformed into
\f[V](a*b) + ((c*d) + e)\f[R] to create two fma operations.
.TP
\f[V]afn\f[R]
Approximate functions - Allow substitution of approximate calculations
for functions (sin, log, sqrt, etc).
See floating-point intrinsic definitions for places where this can apply
to LLVM\[aq]s intrinsic math functions.
.TP
\f[V]reassoc\f[R]
Allow reassociation transformations for floating-point instructions.
This may dramatically change results in floating-point.
.TP
\f[V]fast\f[R]
This flag implies all of the others.
.SS Use-list Order Directives
.PP
Use-list directives encode the in-memory order of each use-list,
allowing the order to be recreated.
\f[V]<order-indexes>\f[R] is a comma-separated list of indexes that are
assigned to the referenced value\[aq]s uses.
The referenced value\[aq]s use-list is immediately sorted by these
indexes.
.PP
Use-list directives may appear at function scope or global scope.
They are not instructions, and have no effect on the semantics of the
IR.
When they\[aq]re at function scope, they must appear after the
terminator of the final basic block.
.PP
If basic blocks have their address taken via \f[V]blockaddress()\f[R]
expressions, \f[V]uselistorder_bb\f[R] can be used to reorder their
use-lists from outside their function\[aq]s scope.
.TP
Syntax
.IP
.nf
\f[C]
uselistorder <ty> <value>, { <order-indexes> }
uselistorder_bb \[at]function, %block { <order-indexes> }
\f[R]
.fi
.TP
Examples
.IP
.nf
\f[C]
define void \[at]foo(i32 %arg1, i32 %arg2) {
entry:
  ; ... instructions ...
bb:
  ; ... instructions ...

  ; At function scope.
  uselistorder i32 %arg1, { 1, 0, 2 }
  uselistorder label %bb, { 1, 0 }
}

; At global scope.
uselistorder i32* \[at]global, { 1, 2, 0 }
uselistorder i32 7, { 1, 0 }
uselistorder i32 (i32) \[at]bar, { 1, 0 }
uselistorder_bb \[at]foo, %bb, { 5, 1, 3, 2, 0, 4 }
\f[R]
.fi
.SS Source Filename
.PP
The \f[I]source filename\f[R] string is set to the original module
identifier, which will be the name of the compiled source file when
compiling from source through the clang front end, for example.
It is then preserved through the IR and bitcode.
.PP
This is currently necessary to generate a consistent unique global
identifier for local functions used in profile data, which prepends the
source file name to the local function name.
.PP
The syntax for the source file name is simply:
.IP
.nf
\f[C]
source_filename = \[dq]/path/to/source.c\[dq]
\f[R]
.fi
.SH Type System
.PP
The LLVM type system is one of the most important features of the
intermediate representation.
Being typed enables a number of optimizations to be performed on the
intermediate representation directly, without having to do extra
analyses on the side before the transformation.
A strong type system makes it easier to read the generated code and
enables novel analyses and transformations that are not feasible to
perform on normal three address code representations.
.SS Void Type
.TP
Overview
.PP
The void type does not represent any value and has no size.
.TP
Syntax
.IP
.nf
\f[C]
void
\f[R]
.fi
.SS Function Type
.TP
Overview
.PP
The function type can be thought of as a function signature.
It consists of a return type and a list of formal parameter types.
The return type of a function type is a void type or first class type
--- except for \f[V]label <t_label>\f[R] and
\f[V]metadata <t_metadata>\f[R] types.
.TP
Syntax
.IP
.nf
\f[C]
<returntype> (<parameter list>)
\f[R]
.fi
.PP
\&...where \[aq]\f[V]<parameter list>\f[R]\[aq] is a comma-separated
list of type specifiers.
Optionally, the parameter list may include a type \f[V]...\f[R], which
indicates that the function takes a variable number of arguments.
Variable argument functions can access their arguments with the
\f[V]variable argument
handling intrinsic <int_varargs>\f[R] functions.
\[aq]\f[V]<returntype>\f[R]\[aq] is any type except
\f[V]label <t_label>\f[R] and \f[V]metadata <t_metadata>\f[R].
.TP
Examples
.PP
.TS
tab(@);
lw(11.9n) lw(58.1n).
T{
\f[V]i32 (i32)\f[R]
T}@T{
function taking an \f[V]i32\f[R], returning an \f[V]i32\f[R]
T}
T{
\f[V]float (i16, i32 *) *\f[R]
T}@T{
\f[V]Pointer <t_pointer>\f[R] to a function that takes an \f[V]i16\f[R]
and a \f[V]pointer <t_pointer>\f[R] to \f[V]i32\f[R], returning
\f[V]float\f[R].
T}
T{
\f[V]i32 (i8*, ...)\f[R]
T}@T{
A vararg function that takes at least one \f[V]pointer <t_pointer>\f[R]
to \f[V]i8\f[R] (char in C), which returns an integer.
This is the signature for \f[V]printf\f[R] in LLVM.
T}
T{
\f[V]{i32, i32} (i32)\f[R]
T}@T{
A function taking an \f[V]i32\f[R], returning a
\f[V]structure <t_struct>\f[R] containing two \f[V]i32\f[R] values
T}
.TE
.SS First Class Types
.PP
The \f[V]first class <t_firstclass>\f[R] types are perhaps the most
important.
Values of these types are the only ones which can be produced by
instructions.
.SS Single Value Types
.PP
These are the types that are valid in registers from CodeGen\[aq]s
perspective.
.SS Integer Type
.TP
Overview
.PP
The integer type is a very simple type that simply specifies an
arbitrary bit width for the integer type desired.
Any bit width from 1 bit to 2^23^(about 8 million) can be specified.
.TP
Syntax
.IP
.nf
\f[C]
iN
\f[R]
.fi
.PP
The number of bits the integer will occupy is specified by the
\f[V]N\f[R] value.
.SS Examples:
.PP
.TS
tab(@);
lw(16.5n) lw(47.6n).
T{
\f[V]i1\f[R]
T}@T{
a single-bit integer.
T}
T{
\f[V]i32\f[R]
T}@T{
a 32-bit integer.
T}
T{
\f[V]i1942652\f[R]
T}@T{
a really big integer of over 1 million bits.
T}
.TE
.SS Floating-Point Types
.PP
.TS
tab(@);
l l.
T{
Type
T}@T{
Description
T}
_
T{
\f[V]half\f[R]
T}@T{
16-bit floating-point value
T}
T{
\f[V]bfloat\f[R]
T}@T{
16-bit \[dq]brain\[dq] floating-point value (7-bit significand).
Provides the same number of exponent bits as \f[V]float\f[R], so that it
matches its dynamic range, but with greatly reduced precision.
Used in Intel\[aq]s AVX-512 BF16 extensions and Arm\[aq]s ARMv8.6-A
extensions, among others.
T}
T{
\f[V]float\f[R]
T}@T{
32-bit floating-point value
T}
T{
\f[V]double\f[R]
T}@T{
64-bit floating-point value
T}
T{
\f[V]fp128\f[R]
T}@T{
128-bit floating-point value (113-bit significand)
T}
T{
\f[V]x86_fp80\f[R]
T}@T{
80-bit floating-point value (X87)
T}
T{
\f[V]ppc_fp128\f[R]
T}@T{
128-bit floating-point value (two 64-bits)
T}
.TE
.PP
The binary format of half, float, double, and fp128 correspond to the
IEEE-754-2008 specifications for binary16, binary32, binary64, and
binary128 respectively.
.SS X86_amx Type
.TP
Overview
.PP
The x86_amx type represents a value held in an AMX tile register on an
x86 machine.
The operations allowed on it are quite limited.
Only few intrinsics are allowed: stride load and store, zero and dot
product.
No instruction is allowed for this type.
There are no arguments, arrays, pointers, vectors or constants of this
type.
.TP
Syntax
.IP
.nf
\f[C]
x86_amx
\f[R]
.fi
.SS X86_mmx Type
.TP
Overview
.PP
The x86_mmx type represents a value held in an MMX register on an x86
machine.
The operations allowed on it are quite limited: parameters and return
values, load and store, and bitcast.
User-specified MMX instructions are represented as intrinsic or asm
calls with arguments and/or results of this type.
There are no arrays, vectors or constants of this type.
.TP
Syntax
.IP
.nf
\f[C]
x86_mmx
\f[R]
.fi
.SS Pointer Type
.TP
Overview
.PP
The pointer type is used to specify memory locations.
Pointers are commonly used to reference objects in memory.
.PP
Pointer types may have an optional address space attribute defining the
numbered address space where the pointed-to object resides.
The default address space is number zero.
The semantics of non-zero address spaces are target-specific.
.PP
Note that LLVM does not permit pointers to void (\f[V]void*\f[R]) nor
does it permit pointers to labels (\f[V]label*\f[R]).
Use \f[V]i8*\f[R] instead.
.PP
LLVM is in the process of transitioning to opaque pointers.
Opaque pointers do not have a pointee type.
Rather, instructions interacting through pointers specify the type of
the underlying memory they are interacting with.
Opaque pointers are still in the process of being worked on and are not
complete.
.TP
Syntax
.IP
.nf
\f[C]
<type> *
ptr
\f[R]
.fi
.TP
Examples
.PP
.TS
tab(@);
lw(13.3n) lw(56.7n).
T{
\f[V][4 x i32]*\f[R]
T}@T{
A \f[V]pointer <t_pointer>\f[R] to \f[V]array <t_array>\f[R] of four
\f[V]i32\f[R] values.
T}
T{
\f[V]i32 (i32*) *\f[R]
T}@T{
A \f[V]pointer <t_pointer>\f[R] to a \f[V]function <t_function>\f[R]
that takes an \f[V]i32*\f[R], returning an \f[V]i32\f[R].
T}
T{
\f[V]i32 addrspace(5)*\f[R]
T}@T{
A \f[V]pointer <t_pointer>\f[R] to an \f[V]i32\f[R] value that resides
in address space 5.
T}
T{
\f[V]ptr\f[R]
T}@T{
An opaque pointer type to a value that resides in address space 0.
T}
T{
\f[V]ptr addrspace(5)\f[R]
T}@T{
An opaque pointer type to a value that resides in address space 5.
T}
.TE
.SS Vector Type
.TP
Overview
.PP
A vector type is a simple derived type that represents a vector of
elements.
Vector types are used when multiple primitive data are operated in
parallel using a single instruction (SIMD).
A vector type requires a size (number of elements), an underlying
primitive data type, and a scalable property to represent vectors where
the exact hardware vector length is unknown at compile time.
Vector types are considered \f[V]first class <t_firstclass>\f[R].
.TP
Memory Layout
.PP
In general vector elements are laid out in memory in the same way as
\f[V]array types <t_array>\f[R].
Such an analogy works fine as long as the vector elements are byte
sized.
However, when the elements of the vector aren\[aq]t byte sized it gets a
bit more complicated.
One way to describe the layout is by describing what happens when a
vector such as <N x iM> is bitcasted to an integer type with N*M bits,
and then following the rules for storing such an integer to memory.
.PP
A bitcast from a vector type to a scalar integer type will see the
elements being packed together (without padding).
The order in which elements are inserted in the integer depends on
endianess.
For little endian element zero is put in the least significant bits of
the integer, and for big endian element zero is put in the most
significant bits.
.PP
Using a vector such as \f[V]<i4 1, i4 2, i4 3, i4 5>\f[R] as an example,
together with the analogy that we can replace a vector store by a
bitcast followed by an integer store, we get this for big endian:
.IP
.nf
\f[C]
%val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16

; Bitcasting from a vector to an integral type can be seen as
; concatenating the values:
;   %val now has the hexadecimal value 0x1235.

store i16 %val, i16* %ptr

; In memory the content will be (8-bit addressing):
;
;    [%ptr + 0]: 00010010  (0x12)
;    [%ptr + 1]: 00110101  (0x35)
\f[R]
.fi
.PP
The same example for little endian:
.IP
.nf
\f[C]
%val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16

; Bitcasting from a vector to an integral type can be seen as
; concatenating the values:
;   %val now has the hexadecimal value 0x5321.

store i16 %val, i16* %ptr

; In memory the content will be (8-bit addressing):
;
;    [%ptr + 0]: 01010011  (0x53)
;    [%ptr + 1]: 00100001  (0x21)
\f[R]
.fi
.PP
When \f[V]<N*M>\f[R] isn\[aq]t evenly divisible by the byte size the
exact memory layout is unspecified (just like it is for an integral type
of the same size).
This is because different targets could put the padding at different
positions when the type size is smaller than the type\[aq]s store size.
.TP
Syntax
.IP
.nf
\f[C]
< <# elements> x <elementtype> >          ; Fixed-length vector
< vscale x <# elements> x <elementtype> > ; Scalable vector
\f[R]
.fi
.PP
The number of elements is a constant integer value larger than 0;
elementtype may be any integer, floating-point or pointer type.
Vectors of size zero are not allowed.
For scalable vectors, the total number of elements is a constant
multiple (called vscale) of the specified number of elements; vscale is
a positive integer that is unknown at compile time and the same
hardware-dependent constant for all scalable vectors at run time.
The size of a specific scalable vector type is thus constant within IR,
even if the exact size in bytes cannot be determined until run time.
.TP
Examples
.PP
.TS
tab(@);
lw(22.4n) lw(47.6n).
T{
\f[V]<4 x i32>\f[R]
T}@T{
Vector of 4 32-bit integer values.
T}
T{
\f[V]<8 x float>\f[R]
T}@T{
Vector of 8 32-bit floating-point values.
T}
T{
\f[V]<2 x i64>\f[R]
T}@T{
Vector of 2 64-bit integer values.
T}
T{
\f[V]<4 x i64*>\f[R]
T}@T{
Vector of 4 pointers to 64-bit integer values.
T}
T{
\f[V]<vscale x 4 x i32>\f[R]
T}@T{
Vector with a multiple of 4 32-bit integer values.
T}
.TE
.SS Label Type
.TP
Overview
.PP
The label type represents code labels.
.TP
Syntax
.IP
.nf
\f[C]
label
\f[R]
.fi
.SS Token Type
.TP
Overview
.PP
The token type is used when a value is associated with an instruction
but all uses of the value must not attempt to introspect or obscure it.
As such, it is not appropriate to have a \f[V]phi <i_phi>\f[R] or
\f[V]select <i_select>\f[R] of type token.
.TP
Syntax
.IP
.nf
\f[C]
token
\f[R]
.fi
.SS Metadata Type
.TP
Overview
.PP
The metadata type represents embedded metadata.
No derived types may be created from metadata except for
\f[V]function <t_function>\f[R] arguments.
.TP
Syntax
.IP
.nf
\f[C]
metadata
\f[R]
.fi
.SS Aggregate Types
.PP
Aggregate Types are a subset of derived types that can contain multiple
member types.
\f[V]Arrays <t_array>\f[R] and \f[V]structs <t_struct>\f[R] are
aggregate types.
\f[V]Vectors <t_vector>\f[R] are not considered to be aggregate types.
.SS Array Type
.TP
Overview
.PP
The array type is a very simple derived type that arranges elements
sequentially in memory.
The array type requires a size (number of elements) and an underlying
data type.
.TP
Syntax
.IP
.nf
\f[C]
[<# elements> x <elementtype>]
\f[R]
.fi
.PP
The number of elements is a constant integer value;
\f[V]elementtype\f[R] may be any type with a size.
.TP
Examples
.PP
.TS
tab(@);
lw(18.5n) lw(37.9n).
T{
\f[V][40 x i32]\f[R]
T}@T{
Array of 40 32-bit integer values.
T}
T{
\f[V][41 x i32]\f[R]
T}@T{
Array of 41 32-bit integer values.
T}
T{
\f[V][4 x i8]\f[R]
T}@T{
Array of 4 8-bit integer values.
T}
.TE
.PP
Here are some examples of multidimensional arrays:
.PP
.TS
tab(@);
lw(23.6n) lw(46.4n).
T{
\f[V][3 x [4 x i32]]\f[R]
T}@T{
3x4 array of 32-bit integer values.
T}
T{
\f[V][12 x [10 x float]]\f[R]
T}@T{
12x10 array of single precision floating-point values.
T}
T{
\f[V][2 x [3 x [4 x i16]]]\f[R]
T}@T{
2x3x4 array of 16-bit integer values.
T}
.TE
.PP
There is no restriction on indexing beyond the end of the array implied
by a static type (though there are restrictions on indexing beyond the
bounds of an allocated object in some cases).
This means that single-dimension \[aq]variable sized array\[aq]
addressing can be implemented in LLVM with a zero length array type.
An implementation of \[aq]pascal style arrays\[aq] in LLVM could use the
type \[dq]\f[V]{ i32, [0 x float]}\f[R]\[dq], for example.
.SS Structure Type
.TP
Overview
.PP
The structure type is used to represent a collection of data members
together in memory.
The elements of a structure may be any type that has a size.
.PP
Structures in memory are accessed using \[aq]\f[V]load\f[R]\[aq] and
\[aq]\f[V]store\f[R]\[aq] by getting a pointer to a field with the
\[aq]\f[V]getelementptr\f[R]\[aq] instruction.
Structures in registers are accessed using the
\[aq]\f[V]extractvalue\f[R]\[aq] and \[aq]\f[V]insertvalue\f[R]\[aq]
instructions.
.PP
Structures may optionally be \[dq]packed\[dq] structures, which indicate
that the alignment of the struct is one byte, and that there is no
padding between the elements.
In non-packed structs, padding between field types is inserted as
defined by the DataLayout string in the module, which is required to
match what the underlying code generator expects.
.PP
Structures can either be \[dq]literal\[dq] or \[dq]identified\[dq].
A literal structure is defined inline with other types (e.g.
\f[V]{i32, i32}*\f[R]) whereas identified types are always defined at
the top level with a name.
Literal types are uniqued by their contents and can never be recursive
or opaque since there is no way to write one.
Identified types can be recursive, can be opaqued, and are never
uniqued.
.TP
Syntax
.IP
.nf
\f[C]
%T1 = type { <type list> }     ; Identified normal struct type
%T2 = type <{ <type list> }>   ; Identified packed struct type
\f[R]
.fi
.TP
Examples
.PP
.TS
tab(@);
lw(10.1n) lw(59.9n).
T{
\f[V]{ i32, i32, i32 }\f[R]
T}@T{
A triple of three \f[V]i32\f[R] values
T}
T{
\f[V]{ float, i32 (i32) * }\f[R]
T}@T{
A pair, where the first element is a \f[V]float\f[R] and the second
element is a \f[V]pointer <t_pointer>\f[R] to a
\f[V]function <t_function>\f[R] that takes an \f[V]i32\f[R], returning
an \f[V]i32\f[R].
T}
T{
\f[V]<{ i8, i32 }>\f[R]
T}@T{
A packed struct known to be 5 bytes in size.
T}
.TE
.SS Opaque Structure Types
.TP
Overview
.PP
Opaque structure types are used to represent structure types that do not
have a body specified.
This corresponds (for example) to the C notion of a forward declared
structure.
They can be named (\f[V]%X\f[R]) or unnamed (\f[V]%52\f[R]).
.TP
Syntax
.IP
.nf
\f[C]
%X = type opaque
%52 = type opaque
\f[R]
.fi
.TP
Examples
.PP
.TS
tab(@);
lw(14.6n) lw(19.4n).
T{
\f[V]opaque\f[R]
T}@T{
An opaque type.
T}
.TE
.SH Constants
.PP
LLVM has several different basic types of constants.
This section describes them all and their syntax.
.SS Simple Constants
.TP
\f[B]Boolean constants\f[R]
The two strings \[aq]\f[V]true\f[R]\[aq] and \[aq]\f[V]false\f[R]\[aq]
are both valid constants of the \f[V]i1\f[R] type.
.TP
\f[B]Integer constants\f[R]
Standard integers (such as \[aq]4\[aq]) are constants of the
\f[V]integer <t_integer>\f[R] type.
Negative numbers may be used with integer types.
.TP
\f[B]Floating-point constants\f[R]
Floating-point constants use standard decimal notation (e.g.
123.421), exponential notation (e.g.
1.23421e+2), or a more precise hexadecimal notation (see below).
The assembler requires the exact decimal value of a floating-point
constant.
For example, the assembler accepts 1.25 but rejects 1.3 because 1.3 is a
repeating decimal in binary.
Floating-point constants must have a
\f[V]floating-point <t_floating>\f[R] type.
.TP
\f[B]Null pointer constants\f[R]
The identifier \[aq]\f[V]null\f[R]\[aq] is recognized as a null pointer
constant and must be of \f[V]pointer type <t_pointer>\f[R].
.TP
\f[B]Token constants\f[R]
The identifier \[aq]\f[V]none\f[R]\[aq] is recognized as an empty token
constant and must be of \f[V]token type <t_token>\f[R].
.PP
The one non-intuitive notation for constants is the hexadecimal form of
floating-point constants.
For example, the form \[aq]\f[V]double    0x432ff973cafa8000\f[R]\[aq]
is equivalent to (but harder to read than)
\[aq]\f[V]double 4.5e+15\f[R]\[aq].
The only time hexadecimal floating-point constants are required (and the
only time that they are generated by the disassembler) is when a
floating-point constant must be emitted but it cannot be represented as
a decimal floating-point number in a reasonable number of digits.
For example, NaN\[aq]s, infinities, and other special values are
represented in their IEEE hexadecimal format so that assembly and
disassembly do not cause any bits to change in the constants.
.PP
When using the hexadecimal form, constants of types bfloat, half, float,
and double are represented using the 16-digit form shown above (which
matches the IEEE754 representation for double); bfloat, half and float
values must, however, be exactly representable as bfloat, IEEE 754 half,
and IEEE 754 single precision respectively.
Hexadecimal format is always used for long double, and there are three
forms of long double.
The 80-bit format used by x86 is represented as \f[V]0xK\f[R] followed
by 20 hexadecimal digits.
The 128-bit format used by PowerPC (two adjacent doubles) is represented
by \f[V]0xM\f[R] followed by 32 hexadecimal digits.
The IEEE 128-bit format is represented by \f[V]0xL\f[R] followed by 32
hexadecimal digits.
Long doubles will only work if they match the long double format on your
target.
The IEEE 16-bit format (half precision) is represented by \f[V]0xH\f[R]
followed by 4 hexadecimal digits.
The bfloat 16-bit format is represented by \f[V]0xR\f[R] followed by 4
hexadecimal digits.
All hexadecimal formats are big-endian (sign bit at the left).
.PP
There are no constants of type x86_mmx and x86_amx.
.SS Complex Constants
.PP
Complex constants are a (potentially recursive) combination of simple
constants and smaller complex constants.
.TP
\f[B]Structure constants\f[R]
Structure constants are represented with notation similar to structure
type definitions (a comma separated list of elements, surrounded by
braces (\f[V]{}\f[R])).
For example: \[dq]\f[V]{ i32 4, float 17.0, i32* \[at]G }\f[R]\[dq],
where \[dq]\f[V]\[at]G\f[R]\[dq] is declared as
\[dq]\f[V]\[at]G = external global i32\f[R]\[dq].
Structure constants must have \f[V]structure type <t_struct>\f[R], and
the number and types of elements must match those specified by the type.
.TP
\f[B]Array constants\f[R]
Array constants are represented with notation similar to array type
definitions (a comma separated list of elements, surrounded by square
brackets (\f[V][]\f[R])).
For example: \[dq]\f[V][ i32 42, i32 11, i32 74 ]\f[R]\[dq].
Array constants must have \f[V]array type <t_array>\f[R], and the number
and types of elements must match those specified by the type.
As a special case, character array constants may also be represented as
a double-quoted string using the \f[V]c\f[R] prefix.
For example: \[dq]\f[V]c\[dq]Hello World\[rs]0A\[rs]00\[dq]\f[R]\[dq].
.TP
\f[B]Vector constants\f[R]
Vector constants are represented with notation similar to vector type
definitions (a comma separated list of elements, surrounded by
less-than/greater-than\[aq]s (\f[V]<>\f[R])).
For example: \[dq]\f[V]< i32 42, i32 11, i32 74, i32 100 >\f[R]\[dq].
Vector constants must have \f[V]vector type <t_vector>\f[R], and the
number and types of elements must match those specified by the type.
.TP
\f[B]Zero initialization\f[R]
The string \[aq]\f[V]zeroinitializer\f[R]\[aq] can be used to zero
initialize a value to zero of \f[I]any\f[R] type, including scalar and
\f[V]aggregate <t_aggregate>\f[R] types.
This is often used to avoid having to print large zero initializers
(e.g.
for large arrays) and is always exactly equivalent to using explicit
zero initializers.
.TP
\f[B]Metadata node\f[R]
A metadata node is a constant tuple without types.
For example: \[dq]\f[V]!{!0, !{!2, !0}, !\[dq]test\[dq]}\f[R]\[dq].
Metadata can reference constant values, for example:
\[dq]\f[V]!{!0, i32 0, i8* \[at]global, i64 (i64)* \[at]function, !\[dq]str\[dq]}\f[R]\[dq].
Unlike other typed constants that are meant to be interpreted as part of
the instruction stream, metadata is a place to attach additional
information such as debug info.
.SS Global Variable and Function Addresses
.PP
The addresses of \f[V]global variables <globalvars>\f[R] and
\f[V]functions <functionstructure>\f[R] are always implicitly valid
(link-time) constants.
These constants are explicitly referenced when the
\f[V]identifier for the global <identifiers>\f[R] is used and always
have \f[V]pointer <t_pointer>\f[R] type.
For example, the following is a legal LLVM file:
.IP
.nf
\f[C]
\[at]X = global i32 17
\[at]Y = global i32 42
\[at]Z = global [2 x i32*] [ i32* \[at]X, i32* \[at]Y ]
\f[R]
.fi
.SS Undefined Values
.PP
The string \[aq]\f[V]undef\f[R]\[aq] can be used anywhere a constant is
expected, and indicates that the user of the value may receive an
unspecified bit-pattern.
Undefined values may be of any type (other than
\[aq]\f[V]label\f[R]\[aq] or \[aq]\f[V]void\f[R]\[aq]) and be used
anywhere a constant is permitted.
.PP
Note
.PP
A \[aq]\f[V]poison\f[R]\[aq] value (decribed in the next section) should
be used instead of \[aq]\f[V]undef\f[R]\[aq] whenever possible.
Poison values are stronger than undef, and enable more optimizations.
Just the existence of \[aq]\f[V]undef\f[R]\[aq] blocks certain
optimizations (see the examples below).
.PP
Undefined values are useful because they indicate to the compiler that
the program is well defined no matter what value is used.
This gives the compiler more freedom to optimize.
Here are some examples of (potentially surprising) transformations that
are valid (in pseudo IR):
.IP
.nf
\f[C]
%A = add %X, undef
%B = sub %X, undef
%C = xor %X, undef
Safe:
%A = undef
%B = undef
%C = undef
\f[R]
.fi
.PP
This is safe because all of the output bits are affected by the undef
bits.
Any output bit can have a zero or one depending on the input bits.
.IP
.nf
\f[C]
%A = or %X, undef
%B = and %X, undef
Safe:
%A = -1
%B = 0
Safe:
%A = %X  ;; By choosing undef as 0
%B = %X  ;; By choosing undef as -1
Unsafe:
%A = undef
%B = undef
\f[R]
.fi
.PP
These logical operations have bits that are not always affected by the
input.
For example, if \f[V]%X\f[R] has a zero bit, then the output of the
\[aq]\f[V]and\f[R]\[aq] operation will always be a zero for that bit, no
matter what the corresponding bit from the \[aq]\f[V]undef\f[R]\[aq] is.
As such, it is unsafe to optimize or assume that the result of the
\[aq]\f[V]and\f[R]\[aq] is \[aq]\f[V]undef\f[R]\[aq].
However, it is safe to assume that all bits of the
\[aq]\f[V]undef\f[R]\[aq] could be 0, and optimize the
\[aq]\f[V]and\f[R]\[aq] to 0.
Likewise, it is safe to assume that all the bits of the
\[aq]\f[V]undef\f[R]\[aq] operand to the \[aq]\f[V]or\f[R]\[aq] could be
set, allowing the \[aq]\f[V]or\f[R]\[aq] to be folded to -1.
.IP
.nf
\f[C]
%A = select undef, %X, %Y
%B = select undef, 42, %Y
%C = select %X, %Y, undef
Safe:
%A = %X     (or %Y)
%B = 42     (or %Y)
%C = %Y     (if %Y is provably not poison; unsafe otherwise)
Unsafe:
%A = undef
%B = undef
%C = undef
\f[R]
.fi
.PP
This set of examples shows that undefined \[aq]\f[V]select\f[R]\[aq]
(and conditional branch) conditions can go \f[I]either way\f[R], but
they have to come from one of the two operands.
In the \f[V]%A\f[R] example, if \f[V]%X\f[R] and \f[V]%Y\f[R] were both
known to have a clear low bit, then \f[V]%A\f[R] would have to have a
cleared low bit.
However, in the \f[V]%C\f[R] example, the optimizer is allowed to assume
that the \[aq]\f[V]undef\f[R]\[aq] operand could be the same as
\f[V]%Y\f[R] if \f[V]%Y\f[R] is provably not \[aq]\f[V]poison\f[R]\[aq],
allowing the whole \[aq]\f[V]select\f[R]\[aq] to be eliminated.
This is because \[aq]\f[V]poison\f[R]\[aq] is stronger than
\[aq]\f[V]undef\f[R]\[aq].
.IP
.nf
\f[C]
%A = xor undef, undef

%B = undef
%C = xor %B, %B

%D = undef
%E = icmp slt %D, 4
%F = icmp gte %D, 4

Safe:
%A = undef
%B = undef
%C = undef
%D = undef
%E = undef
%F = undef
\f[R]
.fi
.PP
This example points out that two \[aq]\f[V]undef\f[R]\[aq] operands are
not necessarily the same.
This can be surprising to people (and also matches C semantics) where
they assume that \[dq]\f[V]X\[ha]X\f[R]\[dq] is always zero, even if
\f[V]X\f[R] is undefined.
This isn\[aq]t true for a number of reasons, but the short answer is
that an \[aq]\f[V]undef\f[R]\[aq] \[dq]variable\[dq] can arbitrarily
change its value over its \[dq]live range\[dq].
This is true because the variable doesn\[aq]t actually \f[I]have a live
range\f[R].
Instead, the value is logically read from arbitrary registers that
happen to be around when needed, so the value is not necessarily
consistent over time.
In fact, \f[V]%A\f[R] and \f[V]%C\f[R] need to have the same semantics
or the core LLVM \[dq]replace all uses with\[dq] concept would not hold.
.PP
To ensure all uses of a given register observe the same value (even if
\[aq]\f[V]undef\f[R]\[aq]), the \f[V]freeze instruction <i_freeze>\f[R]
can be used.
.IP
.nf
\f[C]
%A = sdiv undef, %X
%B = sdiv %X, undef
Safe:
%A = 0
b: unreachable
\f[R]
.fi
.PP
These examples show the crucial difference between an \f[I]undefined
value\f[R] and \f[I]undefined behavior\f[R].
An undefined value (like \[aq]\f[V]undef\f[R]\[aq]) is allowed to have
an arbitrary bit-pattern.
This means that the \f[V]%A\f[R] operation can be constant folded to
\[aq]\f[V]0\f[R]\[aq], because the \[aq]\f[V]undef\f[R]\[aq] could be
zero, and zero divided by any value is zero.
However, in the second example, we can make a more aggressive
assumption: because the \f[V]undef\f[R] is allowed to be an arbitrary
value, we are allowed to assume that it could be zero.
Since a divide by zero has \f[I]undefined behavior\f[R], we are allowed
to assume that the operation does not execute at all.
This allows us to delete the divide and all code after it.
Because the undefined operation \[dq]can\[aq]t happen\[dq], the
optimizer can assume that it occurs in dead code.
.IP
.nf
\f[C]
a:  store undef -> %X
b:  store %X -> undef
Safe:
a: <deleted>     (if the stored value in %X is provably not poison)
b: unreachable
\f[R]
.fi
.PP
A store \f[I]of\f[R] an undefined value can be assumed to not have any
effect; we can assume that the value is overwritten with bits that
happen to match what was already there.
This argument is only valid if the stored value is provably not
\f[V]poison\f[R].
However, a store \f[I]to\f[R] an undefined location could clobber
arbitrary memory, therefore, it has undefined behavior.
.PP
Branching on an undefined value is undefined behavior.
This explains optimizations that depend on branch conditions to
construct predicates, such as Correlated Value Propagation and Global
Value Numbering.
In case of switch instruction, the branch condition should be frozen,
otherwise it is undefined behavior.
.IP
.nf
\f[C]
Unsafe:
  br undef, BB1, BB2 ; UB

  %X = and i32 undef, 255
  switch %X, label %ret [ .. ] ; UB

  store undef, i8* %ptr
  %X = load i8* %ptr ; %X is undef
  switch i8 %X, label %ret [ .. ] ; UB

Safe:
  %X = or i8 undef, 255 ; always 255
  switch i8 %X, label %ret [ .. ] ; Well-defined

  %X = freeze i1 undef
  br %X, BB1, BB2 ; Well-defined (non-deterministic jump)
\f[R]
.fi
.SS Poison Values
.PP
A poison value is a result of an erroneous operation.
In order to facilitate speculative execution, many instructions do not
invoke immediate undefined behavior when provided with illegal operands,
and return a poison value instead.
The string \[aq]\f[V]poison\f[R]\[aq] can be used anywhere a constant is
expected, and operations such as \f[V]add <i_add>\f[R] with the
\f[V]nsw\f[R] flag can produce a poison value.
.PP
Most instructions return \[aq]\f[V]poison\f[R]\[aq] when one of their
arguments is \[aq]\f[V]poison\f[R]\[aq].
A notable exception is the \f[V]select instruction <i_select>\f[R].
Propagation of poison can be stopped with the
\f[V]freeze instruction <i_freeze>\f[R].
.PP
It is correct to replace a poison value with an
\f[V]undef value <undefvalues>\f[R] or any value of the type.
.PP
This means that immediate undefined behavior occurs if a poison value is
used as an instruction operand that has any values that trigger
undefined behavior.
Notably this includes (but is not limited to):
.IP \[bu] 2
The pointer operand of a \f[V]load <i_load>\f[R],
\f[V]store <i_store>\f[R] or any other pointer dereferencing instruction
(independent of address space).
.IP \[bu] 2
The divisor operand of a \f[V]udiv\f[R], \f[V]sdiv\f[R], \f[V]urem\f[R]
or \f[V]srem\f[R] instruction.
.IP \[bu] 2
The condition operand of a \f[V]br <i_br>\f[R] instruction.
.IP \[bu] 2
The callee operand of a \f[V]call <i_call>\f[R] or
\f[V]invoke <i_invoke>\f[R] instruction.
.IP \[bu] 2
The parameter operand of a \f[V]call <i_call>\f[R] or
\f[V]invoke <i_invoke>\f[R] instruction, when the function or invoking
call site has a \f[V]noundef\f[R] attribute in the corresponding
position.
.IP \[bu] 2
The operand of a \f[V]ret <i_ret>\f[R] instruction if the function or
invoking call site has a noundef attribute in the return value position.
.PP
Here are some examples:
.IP
.nf
\f[C]
entry:
  %poison = sub nuw i32 0, 1           ; Results in a poison value.
  %poison2 = sub i32 poison, 1         ; Also results in a poison value.
  %still_poison = and i32 %poison, 0   ; 0, but also poison.
  %poison_yet_again = getelementptr i32, i32* \[at]h, i32 %still_poison
  store i32 0, i32* %poison_yet_again  ; Undefined behavior due to
                                       ; store to poison.

  store i32 %poison, i32* \[at]g           ; Poison value stored to memory.
  %poison3 = load i32, i32* \[at]g         ; Poison value loaded back from memory.

  %narrowaddr = bitcast i32* \[at]g to i16*
  %wideaddr = bitcast i32* \[at]g to i64*
  %poison4 = load i16, i16* %narrowaddr ; Returns a poison value.
  %poison5 = load i64, i64* %wideaddr   ; Returns a poison value.

  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.
  br i1 %cmp, label %end, label %end   ; undefined behavior

end:
\f[R]
.fi
.SS Well-Defined Values
.PP
Given a program execution, a value is \f[I]well defined\f[R] if the
value does not have an undef bit and is not poison in the execution.
An aggregate value or vector is well defined if its elements are well
defined.
The padding of an aggregate isn\[aq]t considered, since it isn\[aq]t
visible without storing it into memory and loading it with a different
type.
.PP
A constant of a \f[V]single value <t_single_value>\f[R], non-vector type
is well defined if it is neither \[aq]\f[V]undef\f[R]\[aq] constant nor
\[aq]\f[V]poison\f[R]\[aq] constant.
The result of \f[V]freeze instruction <i_freeze>\f[R] is well defined
regardless of its operand.
.SS Addresses of Basic Blocks
.PP
\f[V]blockaddress(\[at]function, %block)\f[R]
.PP
The \[aq]\f[V]blockaddress\f[R]\[aq] constant computes the address of
the specified basic block in the specified function.
.PP
It always has an \f[V]i8 addrspace(P)*\f[R] type, where \f[V]P\f[R] is
the address space of the function containing \f[V]%block\f[R] (usually
\f[V]addrspace(0)\f[R]).
.PP
Taking the address of the entry block is illegal.
.PP
This value only has defined behavior when used as an operand to the
\[aq]\f[V]indirectbr <i_indirectbr>\f[R]\[aq] or
\[aq]\f[V]callbr <i_callbr>\f[R]\[aq]instruction, or for comparisons
against null.
Pointer equality tests between labels addresses results in undefined
behavior --- though, again, comparison against null is ok, and no label
is equal to the null pointer.
This may be passed around as an opaque pointer sized value as long as
the bits are not inspected.
This allows \f[V]ptrtoint\f[R] and arithmetic to be performed on these
values so long as the original value is reconstituted before the
\f[V]indirectbr\f[R] or \f[V]callbr\f[R] instruction.
.PP
Finally, some targets may provide defined semantics when using the value
as the operand to an inline assembly, but that is target specific.
.SS DSO Local Equivalent
.PP
\f[V]dso_local_equivalent \[at]func\f[R]
.PP
A \[aq]\f[V]dso_local_equivalent\f[R]\[aq] constant represents a
function which is functionally equivalent to a given function, but is
always defined in the current linkage unit.
The resulting pointer has the same type as the underlying function.
The resulting pointer is permitted, but not required, to be different
from a pointer to the function, and it may have different values in
different translation units.
.PP
The target function may not have \f[V]extern_weak\f[R] linkage.
.PP
\f[V]dso_local_equivalent\f[R] can be implemented as such:
.IP \[bu] 2
If the function has local linkage, hidden visibility, or is
\f[V]dso_local\f[R], \f[V]dso_local_equivalent\f[R] can be implemented
as simply a pointer to the function.
.IP \[bu] 2
\f[V]dso_local_equivalent\f[R] can be implemented with a stub that
tail-calls the function.
Many targets support relocations that resolve at link time to either a
function or a stub for it, depending on if the function is defined
within the linkage unit; LLVM will use this when available.
(This is commonly called a \[dq]PLT stub\[dq].)
On other targets, the stub may need to be emitted explicitly.
.PP
This can be used wherever a \f[V]dso_local\f[R] instance of a function
is needed without needing to explicitly make the original function
\f[V]dso_local\f[R].
An instance where this can be used is for static offset calculations
between a function and some other \f[V]dso_local\f[R] symbol.
This is especially useful for the Relative VTables C++ ABI, where
dynamic relocations for function pointers in VTables can be replaced
with static relocations for offsets between the VTable and virtual
functions which may not be \f[V]dso_local\f[R].
.PP
This is currently only supported for ELF binary formats.
.SS No CFI
.PP
\f[V]no_cfi \[at]func\f[R]
.PP
With Control-Flow Integrity
(CFI) (https://clang.llvm.org/docs/ControlFlowIntegrity.html), a
\[aq]\f[V]no_cfi\f[R]\[aq] constant represents a function reference that
does not get replaced with a reference to the CFI jump table in the
\f[V]LowerTypeTests\f[R] pass.
These constants may be useful in low-level programs, such as operating
system kernels, which need to refer to the actual function body.
.SS Constant Expressions
.PP
Constant expressions are used to allow expressions involving other
constants to be used as constants.
Constant expressions may be of any \f[V]first class <t_firstclass>\f[R]
type and may involve any LLVM operation that does not have side effects
(e.g.
load and call are not supported).
The following is the syntax for constant expressions:
.TP
\f[V]trunc (CST to TYPE)\f[R]
Perform the \f[V]trunc operation <i_trunc>\f[R] on constants.
.TP
\f[V]zext (CST to TYPE)\f[R]
Perform the \f[V]zext operation <i_zext>\f[R] on constants.
.TP
\f[V]sext (CST to TYPE)\f[R]
Perform the \f[V]sext operation <i_sext>\f[R] on constants.
.TP
\f[V]fptrunc (CST to TYPE)\f[R]
Truncate a floating-point constant to another floating-point type.
The size of CST must be larger than the size of TYPE.
Both types must be floating-point.
.TP
\f[V]fpext (CST to TYPE)\f[R]
Floating-point extend a constant to another type.
The size of CST must be smaller or equal to the size of TYPE.
Both types must be floating-point.
.TP
\f[V]fptoui (CST to TYPE)\f[R]
Convert a floating-point constant to the corresponding unsigned integer
constant.
TYPE must be a scalar or vector integer type.
CST must be of scalar or vector floating-point type.
Both CST and TYPE must be scalars, or vectors of the same number of
elements.
If the value won\[aq]t fit in the integer type, the result is a
\f[V]poison value <poisonvalues>\f[R].
.TP
\f[V]fptosi (CST to TYPE)\f[R]
Convert a floating-point constant to the corresponding signed integer
constant.
TYPE must be a scalar or vector integer type.
CST must be of scalar or vector floating-point type.
Both CST and TYPE must be scalars, or vectors of the same number of
elements.
If the value won\[aq]t fit in the integer type, the result is a
\f[V]poison value <poisonvalues>\f[R].
.TP
\f[V]uitofp (CST to TYPE)\f[R]
Convert an unsigned integer constant to the corresponding floating-point
constant.
TYPE must be a scalar or vector floating-point type.
CST must be of scalar or vector integer type.
Both CST and TYPE must be scalars, or vectors of the same number of
elements.
.TP
\f[V]sitofp (CST to TYPE)\f[R]
Convert a signed integer constant to the corresponding floating-point
constant.
TYPE must be a scalar or vector floating-point type.
CST must be of scalar or vector integer type.
Both CST and TYPE must be scalars, or vectors of the same number of
elements.
.TP
\f[V]ptrtoint (CST to TYPE)\f[R]
Perform the \f[V]ptrtoint operation <i_ptrtoint>\f[R] on constants.
.TP
\f[V]inttoptr (CST to TYPE)\f[R]
Perform the \f[V]inttoptr operation <i_inttoptr>\f[R] on constants.
This one is \f[I]really\f[R] dangerous!
.TP
\f[V]bitcast (CST to TYPE)\f[R]
Convert a constant, CST, to another TYPE.
The constraints of the operands are the same as those for the
\f[V]bitcast instruction <i_bitcast>\f[R].
.TP
\f[V]addrspacecast (CST to TYPE)\f[R]
Convert a constant pointer or constant vector of pointer, CST, to
another TYPE in a different address space.
The constraints of the operands are the same as those for the
\f[V]addrspacecast instruction <i_addrspacecast>\f[R].
.TP
\f[V]getelementptr (TY, CSTPTR, IDX0, IDX1, ...)\f[R], \f[V]getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)\f[R]
Perform the \f[V]getelementptr operation <i_getelementptr>\f[R] on
constants.
As with the \f[V]getelementptr <i_getelementptr>\f[R] instruction, the
index list may have one or more indexes, which are required to make
sense for the type of \[dq]pointer to TY\[dq].
.TP
\f[V]select (COND, VAL1, VAL2)\f[R]
Perform the \f[V]select operation <i_select>\f[R] on constants.
.TP
\f[V]icmp COND (VAL1, VAL2)\f[R]
Perform the \f[V]icmp operation <i_icmp>\f[R] on constants.
.TP
\f[V]fcmp COND (VAL1, VAL2)\f[R]
Perform the \f[V]fcmp operation <i_fcmp>\f[R] on constants.
.TP
\f[V]extractelement (VAL, IDX)\f[R]
Perform the \f[V]extractelement operation <i_extractelement>\f[R] on
constants.
.TP
\f[V]insertelement (VAL, ELT, IDX)\f[R]
Perform the \f[V]insertelement operation <i_insertelement>\f[R] on
constants.
.TP
\f[V]shufflevector (VEC1, VEC2, IDXMASK)\f[R]
Perform the \f[V]shufflevector operation <i_shufflevector>\f[R] on
constants.
.TP
\f[V]extractvalue (VAL, IDX0, IDX1, ...)\f[R]
Perform the \f[V]extractvalue operation <i_extractvalue>\f[R] on
constants.
The index list is interpreted in a similar manner as indices in a
\[aq]\f[V]getelementptr <i_getelementptr>\f[R]\[aq] operation.
At least one index value must be specified.
.TP
\f[V]insertvalue (VAL, ELT, IDX0, IDX1, ...)\f[R]
Perform the \f[V]insertvalue operation <i_insertvalue>\f[R] on
constants.
The index list is interpreted in a similar manner as indices in a
\[aq]\f[V]getelementptr <i_getelementptr>\f[R]\[aq] operation.
At least one index value must be specified.
.TP
\f[V]OPCODE (LHS, RHS)\f[R]
Perform the specified operation of the LHS and RHS constants.
OPCODE may be any of the \f[V]binary <binaryops>\f[R] or \f[V]bitwise
binary <bitwiseops>\f[R] operations.
The constraints on operands are the same as those for the corresponding
instruction (e.g.
no bitwise operations on floating-point values are allowed).
.SH Other Values
.SS Inline Assembler Expressions
.PP
LLVM supports inline assembler expressions (as opposed to
\f[V]Module-Level
Inline Assembly <moduleasm>\f[R]) through the use of a special value.
This value represents the inline assembler as a template string
(containing the instructions to emit), a list of operand constraints
(stored as a string), a flag that indicates whether or not the inline
asm expression has side effects, and a flag indicating whether the
function containing the asm needs to align its stack conservatively.
.PP
The template string supports argument substitution of the operands using
\[dq]\f[V]$\f[R]\[dq] followed by a number, to indicate substitution of
the given register/memory location, as specified by the constraint
string.
\[dq]\f[V]${NUM:MODIFIER}\f[R]\[dq] may also be used, where
\f[V]MODIFIER\f[R] is a target-specific annotation for how to print the
operand (See \f[V]inline-asm-modifiers\f[R]).
.PP
A literal \[dq]\f[V]$\f[R]\[dq] may be included by using
\[dq]\f[V]$$\f[R]\[dq] in the template.
To include other special characters into the output, the usual
\[dq]\f[V]\[rs]XX\f[R]\[dq] escapes may be used, just as in other
strings.
Note that after template substitution, the resulting assembly string is
parsed by LLVM\[aq]s integrated assembler unless it is disabled -- even
when emitting a \f[V].s\f[R] file -- and thus must contain assembly
syntax known to LLVM.
.PP
LLVM also supports a few more substitutions useful for writing inline
assembly:
.IP \[bu] 2
\f[V]${:uid}\f[R]: Expands to a decimal integer unique to this inline
assembly blob.
This substitution is useful when declaring a local label.
Many standard compiler optimizations, such as inlining, may duplicate an
inline asm blob.
Adding a blob-unique identifier ensures that the two labels will not
conflict during assembly.
This is used to implement GCC\[aq]s %= special format
string (https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html).
.IP \[bu] 2
\f[V]${:comment}\f[R]: Expands to the comment character of the current
target\[aq]s assembly dialect.
This is usually \f[V]#\f[R], but many targets use other strings, such as
\f[V];\f[R], \f[V]//\f[R], or \f[V]!\f[R].
.IP \[bu] 2
\f[V]${:private}\f[R]: Expands to the assembler private label prefix.
Labels with this prefix will not appear in the symbol table of the
assembled object.
Typically the prefix is \f[V]L\f[R], but targets may use other strings.
\f[V].L\f[R] is relatively popular.
.PP
LLVM\[aq]s support for inline asm is modeled closely on the requirements
of Clang\[aq]s GCC-compatible inline-asm support.
Thus, the feature-set and the constraint and modifier codes listed here
are similar or identical to those in GCC\[aq]s inline asm support.
However, to be clear, the syntax of the template and constraint strings
described here is \f[I]not\f[R] the same as the syntax accepted by GCC
and Clang, and, while most constraint letters are passed through as-is
by Clang, some get translated to other codes when converting from the C
source to the LLVM assembly.
.PP
An example inline assembler expression is:
.IP
.nf
\f[C]
i32 (i32) asm \[dq]bswap $0\[dq], \[dq]=r,r\[dq]
\f[R]
.fi
.PP
Inline assembler expressions may \f[B]only\f[R] be used as the callee
operand of a \f[V]call <i_call>\f[R] or an \f[V]invoke <i_invoke>\f[R]
instruction.
Thus, typically we have:
.IP
.nf
\f[C]
%X = call i32 asm \[dq]bswap $0\[dq], \[dq]=r,r\[dq](i32 %Y)
\f[R]
.fi
.PP
Inline asms with side effects not visible in the constraint list must be
marked as having side effects.
This is done through the use of the \[aq]\f[V]sideeffect\f[R]\[aq]
keyword, like so:
.IP
.nf
\f[C]
call void asm sideeffect \[dq]eieio\[dq], \[dq]\[dq]()
\f[R]
.fi
.PP
In some cases inline asms will contain code that will not work unless
the stack is aligned in some way, such as calls or SSE instructions on
x86, yet will not contain code that does that alignment within the asm.
The compiler should make conservative assumptions about what the asm
might contain and should generate its usual stack alignment code in the
prologue if the \[aq]\f[V]alignstack\f[R]\[aq] keyword is present:
.IP
.nf
\f[C]
call void asm alignstack \[dq]eieio\[dq], \[dq]\[dq]()
\f[R]
.fi
.PP
Inline asms also support using non-standard assembly dialects.
The assumed dialect is ATT.
When the \[aq]\f[V]inteldialect\f[R]\[aq] keyword is present, the inline
asm is using the Intel dialect.
Currently, ATT and Intel are the only supported dialects.
An example is:
.IP
.nf
\f[C]
call void asm inteldialect \[dq]eieio\[dq], \[dq]\[dq]()
\f[R]
.fi
.PP
In the case that the inline asm might unwind the stack, the
\[aq]\f[V]unwind\f[R]\[aq] keyword must be used, so that the compiler
emits unwinding information:
.IP
.nf
\f[C]
call void asm unwind \[dq]call func\[dq], \[dq]\[dq]()
\f[R]
.fi
.PP
If the inline asm unwinds the stack and isn\[aq]t marked with the
\[aq]\f[V]unwind\f[R]\[aq] keyword, the behavior is undefined.
.PP
If multiple keywords appear, the \[aq]\f[V]sideeffect\f[R]\[aq] keyword
must come first, the \[aq]\f[V]alignstack\f[R]\[aq] keyword second, the
\[aq]\f[V]inteldialect\f[R]\[aq] keyword third and the
\[aq]\f[V]unwind\f[R]\[aq] keyword last.
.SS Inline Asm Constraint String
.PP
The constraint list is a comma-separated string, each element containing
one or more constraint codes.
.PP
For each element in the constraint list an appropriate register or
memory operand will be chosen, and it will be made available to assembly
template string expansion as \f[V]$0\f[R] for the first constraint in
the list, \f[V]$1\f[R] for the second, etc.
.PP
There are three different types of constraints, which are distinguished
by a prefix symbol in front of the constraint code: Output, Input, and
Clobber.
The constraints must always be given in that order: outputs first, then
inputs, then clobbers.
They cannot be intermingled.
.PP
There are also three different categories of constraint codes:
.IP \[bu] 2
Register constraint.
This is either a register class, or a fixed physical register.
This kind of constraint will allocate a register, and if necessary,
bitcast the argument or result to the appropriate type.
.IP \[bu] 2
Memory constraint.
This kind of constraint is for use with an instruction taking a memory
operand.
Different constraints allow for different addressing modes used by the
target.
.IP \[bu] 2
Immediate value constraint.
This kind of constraint is for an integer or other immediate value which
can be rendered directly into an instruction.
The various target-specific constraints allow the selection of a value
in the proper range for the instruction you wish to use it with.
.SS Output constraints
.PP
Output constraints are specified by an \[dq]\f[V]=\f[R]\[dq] prefix
(e.g.
\[dq]\f[V]=r\f[R]\[dq]).
This indicates that the assembly will write to this operand, and the
operand will then be made available as a return value of the
\f[V]asm\f[R] expression.
Output constraints do not consume an argument from the call instruction.
(Except, see below about indirect outputs).
.PP
Normally, it is expected that no output locations are written to by the
assembly expression until \f[I]all\f[R] of the inputs have been read.
As such, LLVM may assign the same register to an output and an input.
If this is not safe (e.g.
if the assembly contains two instructions, where the first writes to one
output, and the second reads an input and writes to a second output),
then the \[dq]\f[V]&\f[R]\[dq] modifier must be used (e.g.
\[dq]\f[V]=&r\f[R]\[dq]) to specify that the output is an
\[dq]early-clobber\[dq] output.
Marking an output as \[dq]early-clobber\[dq] ensures that LLVM will not
use the same register for any inputs (other than an input tied to this
output).
.SS Input constraints
.PP
Input constraints do not have a prefix -- just the constraint codes.
Each input constraint will consume one argument from the call
instruction.
It is not permitted for the asm to write to any input register or memory
location (unless that input is tied to an output).
Note also that multiple inputs may all be assigned to the same register,
if LLVM can determine that they necessarily all contain the same value.
.PP
Instead of providing a Constraint Code, input constraints may also
\[dq]tie\[dq] themselves to an output constraint, by providing an
integer as the constraint string.
Tied inputs still consume an argument from the call instruction, and
take up a position in the asm template numbering as is usual -- they
will simply be constrained to always use the same register as the output
they\[aq]ve been tied to.
For example, a constraint string of \[dq]\f[V]=r,0\f[R]\[dq] says to
assign a register for output, and use that register as an input as well
(it being the 0\[aq]th constraint).
.PP
It is permitted to tie an input to an \[dq]early-clobber\[dq] output.
In that case, no \f[I]other\f[R] input may share the same register as
the input tied to the early-clobber (even when the other input has the
same value).
.PP
You may only tie an input to an output which has a register constraint,
not a memory constraint.
Only a single input may be tied to an output.
.PP
There is also an \[dq]interesting\[dq] feature which deserves a bit of
explanation: if a register class constraint allocates a register which
is too small for the value type operand provided as input, the input
value will be split into multiple registers, and all of them passed to
the inline asm.
.PP
However, this feature is often not as useful as you might think.
.PP
Firstly, the registers are \f[I]not\f[R] guaranteed to be consecutive.
So, on those architectures that have instructions which operate on
multiple consecutive instructions, this is not an appropriate way to
support them.
(e.g.
the 32-bit SparcV8 has a 64-bit load, which instruction takes a single
32-bit register.
The hardware then loads into both the named register, and the next
register.
This feature of inline asm would not be useful to support that.)
.PP
A few of the targets provide a template string modifier allowing
explicit access to the second register of a two-register operand (e.g.
MIPS \f[V]L\f[R], \f[V]M\f[R], and \f[V]D\f[R]).
On such an architecture, you can actually access the second allocated
register (yet, still, not any subsequent ones).
But, in that case, you\[aq]re still probably better off simply splitting
the value into two separate operands, for clarity.
(e.g.
see the description of the \f[V]A\f[R] constraint on X86, which, despite
existing only for use with this feature, is not really a good idea to
use)
.SS Indirect inputs and outputs
.PP
Indirect output or input constraints can be specified by the
\[dq]\f[V]*\f[R]\[dq] modifier (which goes after the
\[dq]\f[V]=\f[R]\[dq] in case of an output).
This indicates that the asm will write to or read from the contents of
an \f[I]address\f[R] provided as an input argument.
(Note that in this way, indirect outputs act more like an
\f[I]input\f[R] than an output: just like an input, they consume an
argument of the call expression, rather than producing a return value.
An indirect output constraint is an \[dq]output\[dq] only in that the
asm is expected to write to the contents of the input memory location,
instead of just read from it).
.PP
This is most typically used for memory constraint, e.g.
\[dq]\f[V]=*m\f[R]\[dq], to pass the address of a variable as a value.
.PP
It is also possible to use an indirect \f[I]register\f[R] constraint,
but only on output (e.g.
\[dq]\f[V]=*r\f[R]\[dq]).
This will cause LLVM to allocate a register for an output value
normally, and then, separately emit a store to the address provided as
input, after the provided inline asm.
(It\[aq]s not clear what value this functionality provides, compared to
writing the store explicitly after the asm statement, and it can only
produce worse code, since it bypasses many optimization passes.
I would recommend not using it.)
.PP
Call arguments for indirect constraints must have pointer type and must
specify the \f[V]elementtype <attr_elementtype>\f[R] attribute to
indicate the pointer element type.
.SS Clobber constraints
.PP
A clobber constraint is indicated by a \[dq]\f[V]\[ti]\f[R]\[dq] prefix.
A clobber does not consume an input operand, nor generate an output.
Clobbers cannot use any of the general constraint code letters -- they
may use only explicit register constraints, e.g.
\[dq]\f[V]\[ti]{eax}\f[R]\[dq].
The one exception is that a clobber string of
\[dq]\f[V]\[ti]{memory}\f[R]\[dq] indicates that the assembly writes to
arbitrary undeclared memory locations -- not only the memory pointed to
by a declared indirect output.
.PP
Note that clobbering named registers that are also present in output
constraints is not legal.
.SS Constraint Codes
.PP
After a potential prefix comes constraint code, or codes.
.PP
A Constraint Code is either a single letter (e.g.
\[dq]\f[V]r\f[R]\[dq]), a \[dq]\f[V]\[ha]\f[R]\[dq] character followed
by two letters (e.g.
\[dq]\f[V]\[ha]wc\f[R]\[dq]), or \[dq]\f[V]{\f[R]\[dq] register-name
\[dq]\f[V]}\f[R]\[dq] (e.g.
\[dq]\f[V]{eax}\f[R]\[dq]).
.PP
The one and two letter constraint codes are typically chosen to be the
same as GCC\[aq]s constraint codes.
.PP
A single constraint may include one or more than constraint code in it,
leaving it up to LLVM to choose which one to use.
This is included mainly for compatibility with the translation of GCC
inline asm coming from clang.
.PP
There are two ways to specify alternatives, and either or both may be
used in an inline asm constraint list:
.IP "1)" 3
Append the codes to each other, making a constraint code set.
E.g.
\[dq]\f[V]im\f[R]\[dq] or \[dq]\f[V]{eax}m\f[R]\[dq].
This means \[dq]choose any of the options in the set\[dq].
The choice of constraint is made independently for each constraint in
the constraint list.
.IP "2)" 3
Use \[dq]\f[V]|\f[R]\[dq] between constraint code sets, creating
alternatives.
Every constraint in the constraint list must have the same number of
alternative sets.
With this syntax, the same alternative in \f[I]all\f[R] of the items in
the constraint list will be chosen together.
.PP
Putting those together, you might have a two operand constraint string
like \f[V]\[dq]rm|r,ri|rm\[dq]\f[R].
This indicates that if operand 0 is \f[V]r\f[R] or \f[V]m\f[R], then
operand 1 may be one of \f[V]r\f[R] or \f[V]i\f[R].
If operand 0 is \f[V]r\f[R], then operand 1 may be one of \f[V]r\f[R] or
\f[V]m\f[R].
But, operand 0 and 1 cannot both be of type m.
.PP
However, the use of either of the alternatives features is \f[I]NOT\f[R]
recommended, as LLVM is not able to make an intelligent choice about
which one to use.
(At the point it currently needs to choose, not enough information is
available to do so in a smart way.)
Thus, it simply tries to make a choice that\[aq]s most likely to
compile, not one that will be optimal performance.
(e.g., given \[dq]\f[V]rm\f[R]\[dq], it\[aq]ll always choose to use
memory, not registers).
And, if given multiple registers, or multiple register classes, it will
simply choose the first one.
(In fact, it doesn\[aq]t currently even ensure explicitly specified
physical registers are unique, so specifying multiple physical registers
as alternatives, like \f[V]{r11}{r12},{r11}{r12}\f[R], will assign r11
to both operands, not at all what was intended.)
.SS Supported Constraint Code List
.PP
The constraint codes are, in general, expected to behave the same way
they do in GCC.
LLVM\[aq]s support is often implemented on an \[aq]as-needed\[aq] basis,
to support C inline asm code which was supported by GCC.
A mismatch in behavior between LLVM and GCC likely indicates a bug in
LLVM.
.PP
Some constraint codes are typically supported by all targets:
.IP \[bu] 2
\f[V]r\f[R]: A register in the target\[aq]s general purpose register
class.
.IP \[bu] 2
\f[V]m\f[R]: A memory address operand.
It is target-specific what addressing modes are supported, typical
examples are register, or register + register offset, or register +
immediate offset (of some target-specific size).
.IP \[bu] 2
\f[V]p\f[R]: An address operand.
Similar to \f[V]m\f[R], but used by \[dq]load address\[dq] type
instructions without touching memory.
.IP \[bu] 2
\f[V]i\f[R]: An integer constant (of target-specific width).
Allows either a simple immediate, or a relocatable value.
.IP \[bu] 2
\f[V]n\f[R]: An integer constant -- \f[I]not\f[R] including relocatable
values.
.IP \[bu] 2
\f[V]s\f[R]: An integer constant, but allowing \f[I]only\f[R]
relocatable values.
.IP \[bu] 2
\f[V]X\f[R]: Allows an operand of any kind, no constraint whatsoever.
Typically useful to pass a label for an asm branch or call.
.IP \[bu] 2
\f[V]{register-name}\f[R]: Requires exactly the named physical register.
.PP
Other constraints are target-specific:
.PP
AArch64:
.IP \[bu] 2
\f[V]z\f[R]: An immediate integer 0.
Outputs \f[V]WZR\f[R] or \f[V]XZR\f[R], as appropriate.
.IP \[bu] 2
\f[V]I\f[R]: An immediate integer valid for an \f[V]ADD\f[R] or
\f[V]SUB\f[R] instruction, i.e.
0 to 4095 with optional shift by 12.
.IP \[bu] 2
\f[V]J\f[R]: An immediate integer that, when negated, is valid for an
\f[V]ADD\f[R] or \f[V]SUB\f[R] instruction, i.e.
-1 to -4095 with optional left shift by 12.
.IP \[bu] 2
\f[V]K\f[R]: An immediate integer that is valid for the \[aq]bitmask
immediate 32\[aq] of a logical instruction like \f[V]AND\f[R],
\f[V]EOR\f[R], or \f[V]ORR\f[R] with a 32-bit register.
.IP \[bu] 2
\f[V]L\f[R]: An immediate integer that is valid for the \[aq]bitmask
immediate 64\[aq] of a logical instruction like \f[V]AND\f[R],
\f[V]EOR\f[R], or \f[V]ORR\f[R] with a 64-bit register.
.IP \[bu] 2
\f[V]M\f[R]: An immediate integer for use with the \f[V]MOV\f[R]
assembly alias on a 32-bit register.
This is a superset of \f[V]K\f[R]: in addition to the bitmask immediate,
also allows immediate integers which can be loaded with a single
\f[V]MOVZ\f[R] or \f[V]MOVL\f[R] instruction.
.IP \[bu] 2
\f[V]N\f[R]: An immediate integer for use with the \f[V]MOV\f[R]
assembly alias on a 64-bit register.
This is a superset of \f[V]L\f[R].
.IP \[bu] 2
\f[V]Q\f[R]: Memory address operand must be in a single register (no
offsets).
(However, LLVM currently does this for the \f[V]m\f[R] constraint as
well.)
.IP \[bu] 2
\f[V]r\f[R]: A 32 or 64-bit integer register (W* or X*).
.IP \[bu] 2
\f[V]w\f[R]: A 32, 64, or 128-bit floating-point, SIMD or SVE vector
register.
.IP \[bu] 2
\f[V]x\f[R]: Like w, but restricted to registers 0 to 15 inclusive.
.IP \[bu] 2
\f[V]y\f[R]: Like w, but restricted to SVE vector registers Z0 to Z7
inclusive.
.IP \[bu] 2
\f[V]Upl\f[R]: One of the low eight SVE predicate registers (P0 to P7)
.IP \[bu] 2
\f[V]Upa\f[R]: Any of the SVE predicate registers (P0 to P15)
.PP
AMDGPU:
.IP \[bu] 2
\f[V]r\f[R]: A 32 or 64-bit integer register.
.IP \[bu] 2
\f[V][0-9]v\f[R]: The 32-bit VGPR register, number 0-9.
.IP \[bu] 2
\f[V][0-9]s\f[R]: The 32-bit SGPR register, number 0-9.
.IP \[bu] 2
\f[V][0-9]a\f[R]: The 32-bit AGPR register, number 0-9.
.IP \[bu] 2
\f[V]I\f[R]: An integer inline constant in the range from -16 to 64.
.IP \[bu] 2
\f[V]J\f[R]: A 16-bit signed integer constant.
.IP \[bu] 2
\f[V]A\f[R]: An integer or a floating-point inline constant.
.IP \[bu] 2
\f[V]B\f[R]: A 32-bit signed integer constant.
.IP \[bu] 2
\f[V]C\f[R]: A 32-bit unsigned integer constant or an integer inline
constant in the range from -16 to 64.
.IP \[bu] 2
\f[V]DA\f[R]: A 64-bit constant that can be split into two \[dq]A\[dq]
constants.
.IP \[bu] 2
\f[V]DB\f[R]: A 64-bit constant that can be split into two \[dq]B\[dq]
constants.
.PP
All ARM modes:
.IP \[bu] 2
\f[V]Q\f[R], \f[V]Um\f[R], \f[V]Un\f[R], \f[V]Uq\f[R], \f[V]Us\f[R],
\f[V]Ut\f[R], \f[V]Uv\f[R], \f[V]Uy\f[R]: Memory address operand.
Treated the same as operand \f[V]m\f[R], at the moment.
.IP \[bu] 2
\f[V]Te\f[R]: An even general-purpose 32-bit integer register:
\f[V]r0,r2,...,r12,r14\f[R]
.IP \[bu] 2
\f[V]To\f[R]: An odd general-purpose 32-bit integer register:
\f[V]r1,r3,...,r11\f[R]
.PP
ARM and ARM\[aq]s Thumb2 mode:
.IP \[bu] 2
\f[V]j\f[R]: An immediate integer between 0 and 65535 (valid for
\f[V]MOVW\f[R])
.IP \[bu] 2
\f[V]I\f[R]: An immediate integer valid for a data-processing
instruction.
.IP \[bu] 2
\f[V]J\f[R]: An immediate integer between -4095 and 4095.
.IP \[bu] 2
\f[V]K\f[R]: An immediate integer whose bitwise inverse is valid for a
data-processing instruction.
(Can be used with template modifier \[dq]\f[V]B\f[R]\[dq] to print the
inverted value).
.IP \[bu] 2
\f[V]L\f[R]: An immediate integer whose negation is valid for a
data-processing instruction.
(Can be used with template modifier \[dq]\f[V]n\f[R]\[dq] to print the
negated value).
.IP \[bu] 2
\f[V]M\f[R]: A power of two or an integer between 0 and 32.
.IP \[bu] 2
\f[V]N\f[R]: Invalid immediate constraint.
.IP \[bu] 2
\f[V]O\f[R]: Invalid immediate constraint.
.IP \[bu] 2
\f[V]r\f[R]: A general-purpose 32-bit integer register
(\f[V]r0-r15\f[R]).
.IP \[bu] 2
\f[V]l\f[R]: In Thumb2 mode, low 32-bit GPR registers (\f[V]r0-r7\f[R]).
In ARM mode, same as \f[V]r\f[R].
.IP \[bu] 2
\f[V]h\f[R]: In Thumb2 mode, a high 32-bit GPR register
(\f[V]r8-r15\f[R]).
In ARM mode, invalid.
.IP \[bu] 2
\f[V]w\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s31\f[R], \f[V]d0-d31\f[R], or \f[V]q0-q15\f[R],
respectively.
.IP \[bu] 2
\f[V]t\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s31\f[R], \f[V]d0-d15\f[R], or \f[V]q0-q7\f[R],
respectively.
.IP \[bu] 2
\f[V]x\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s15\f[R], \f[V]d0-d7\f[R], or \f[V]q0-q3\f[R],
respectively.
.PP
ARM\[aq]s Thumb1 mode:
.IP \[bu] 2
\f[V]I\f[R]: An immediate integer between 0 and 255.
.IP \[bu] 2
\f[V]J\f[R]: An immediate integer between -255 and -1.
.IP \[bu] 2
\f[V]K\f[R]: An immediate integer between 0 and 255, with optional
left-shift by some amount.
.IP \[bu] 2
\f[V]L\f[R]: An immediate integer between -7 and 7.
.IP \[bu] 2
\f[V]M\f[R]: An immediate integer which is a multiple of 4 between 0 and
1020.
.IP \[bu] 2
\f[V]N\f[R]: An immediate integer between 0 and 31.
.IP \[bu] 2
\f[V]O\f[R]: An immediate integer which is a multiple of 4 between -508
and 508.
.IP \[bu] 2
\f[V]r\f[R]: A low 32-bit GPR register (\f[V]r0-r7\f[R]).
.IP \[bu] 2
\f[V]l\f[R]: A low 32-bit GPR register (\f[V]r0-r7\f[R]).
.IP \[bu] 2
\f[V]h\f[R]: A high GPR register (\f[V]r0-r7\f[R]).
.IP \[bu] 2
\f[V]w\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s31\f[R], \f[V]d0-d31\f[R], or \f[V]q0-q15\f[R],
respectively.
.IP \[bu] 2
\f[V]t\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s31\f[R], \f[V]d0-d15\f[R], or \f[V]q0-q7\f[R],
respectively.
.IP \[bu] 2
\f[V]x\f[R]: A 32, 64, or 128-bit floating-point/SIMD register in the
ranges \f[V]s0-s15\f[R], \f[V]d0-d7\f[R], or \f[V]q0-q3\f[R],
respectively.
.PP
Hexagon:
.IP \[bu] 2
\f[V]o\f[R], \f[V]v\f[R]: A memory address operand, treated the same as
constraint \f[V]m\f[R], at the moment.
.IP \[bu] 2
\f[V]r\f[R]: A 32 or 64-bit register.
.PP
MSP430:
.IP \[bu] 2
\f[V]r\f[R]: An 8 or 16-bit register.
.PP
MIPS:
.IP \[bu] 2
\f[V]I\f[R]: An immediate signed 16-bit integer.
.IP \[bu] 2
\f[V]J\f[R]: An immediate integer zero.
.IP \[bu] 2
\f[V]K\f[R]: An immediate unsigned 16-bit integer.
.IP \[bu] 2
\f[V]L\f[R]: An immediate 32-bit integer, where the lower 16 bits are 0.
.IP \[bu] 2
\f[V]N\f[R]: An immediate integer between -65535 and -1.
.IP \[bu] 2
\f[V]O\f[R]: An immediate signed 15-bit integer.
.IP \[bu] 2
\f[V]P\f[R]: An immediate integer between 1 and 65535.
.IP \[bu] 2
\f[V]m\f[R]: A memory address operand.
In MIPS-SE mode, allows a base address register plus 16-bit immediate
offset.
In MIPS mode, just a base register.
.IP \[bu] 2
\f[V]R\f[R]: A memory address operand.
In MIPS-SE mode, allows a base address register plus a 9-bit signed
offset.
In MIPS mode, the same as constraint \f[V]m\f[R].
.IP \[bu] 2
\f[V]ZC\f[R]: A memory address operand, suitable for use in a
\f[V]pref\f[R], \f[V]ll\f[R], or \f[V]sc\f[R] instruction on the given
subtarget (details vary).
.IP \[bu] 2
\f[V]r\f[R], \f[V]d\f[R], \f[V]y\f[R]: A 32 or 64-bit GPR register.
.IP \[bu] 2
\f[V]f\f[R]: A 32 or 64-bit FPU register (\f[V]F0-F31\f[R]), or a
128-bit MSA register (\f[V]W0-W31\f[R]).
In the case of MSA registers, it is recommended to use the \f[V]w\f[R]
argument modifier for compatibility with GCC.
.IP \[bu] 2
\f[V]c\f[R]: A 32-bit or 64-bit GPR register suitable for indirect jump
(always \f[V]25\f[R]).
.IP \[bu] 2
\f[V]l\f[R]: The \f[V]lo\f[R] register, 32 or 64-bit.
.IP \[bu] 2
\f[V]x\f[R]: Invalid.
.PP
NVPTX:
.IP \[bu] 2
\f[V]b\f[R]: A 1-bit integer register.
.IP \[bu] 2
\f[V]c\f[R] or \f[V]h\f[R]: A 16-bit integer register.
.IP \[bu] 2
\f[V]r\f[R]: A 32-bit integer register.
.IP \[bu] 2
\f[V]l\f[R] or \f[V]N\f[R]: A 64-bit integer register.
.IP \[bu] 2
\f[V]f\f[R]: A 32-bit float register.
.IP \[bu] 2
\f[V]d\f[R]: A 64-bit float register.
.PP
PowerPC:
.IP \[bu] 2
\f[V]I\f[R]: An immediate signed 16-bit integer.
.IP \[bu] 2
\f[V]J\f[R]: An immediate unsigned 16-bit integer, shifted left 16 bits.
.IP \[bu] 2
\f[V]K\f[R]: An immediate unsigned 16-bit integer.
.IP \[bu] 2
\f[V]L\f[R]: An immediate signed 16-bit integer, shifted left 16 bits.
.IP \[bu] 2
\f[V]M\f[R]: An immediate integer greater than 31.
.IP \[bu] 2
\f[V]N\f[R]: An immediate integer that is an exact power of 2.
.IP \[bu] 2
\f[V]O\f[R]: The immediate integer constant 0.
.IP \[bu] 2
\f[V]P\f[R]: An immediate integer constant whose negation is a signed
16-bit constant.
.IP \[bu] 2
\f[V]es\f[R], \f[V]o\f[R], \f[V]Q\f[R], \f[V]Z\f[R], \f[V]Zy\f[R]: A
memory address operand, currently treated the same as \f[V]m\f[R].
.IP \[bu] 2
\f[V]r\f[R]: A 32 or 64-bit integer register.
.IP \[bu] 2
\f[V]b\f[R]: A 32 or 64-bit integer register, excluding \f[V]R0\f[R]
(that is: \f[V]R1-R31\f[R]).
.IP \[bu] 2
\f[V]f\f[R]: A 32 or 64-bit float register (\f[V]F0-F31\f[R]),
\[bu] .RS 2
.TP
\f[V]v\f[R]: For \f[V]4 x f32\f[R] or \f[V]4 x f64\f[R] types, a 128-bit altivec vector
register (\f[V]V0-V31\f[R]).
.RE
.IP \[bu] 2
\f[V]y\f[R]: Condition register (\f[V]CR0-CR7\f[R]).
.IP \[bu] 2
\f[V]wc\f[R]: An individual CR bit in a CR register.
.IP \[bu] 2
\f[V]wa\f[R], \f[V]wd\f[R], \f[V]wf\f[R]: Any 128-bit VSX vector
register, from the full VSX register set (overlapping both the
floating-point and vector register files).
.IP \[bu] 2
\f[V]ws\f[R]: A 32 or 64-bit floating-point register, from the full VSX
register set.
.PP
RISC-V:
.IP \[bu] 2
\f[V]A\f[R]: An address operand (using a general-purpose register,
without an offset).
.IP \[bu] 2
\f[V]I\f[R]: A 12-bit signed integer immediate operand.
.IP \[bu] 2
\f[V]J\f[R]: A zero integer immediate operand.
.IP \[bu] 2
\f[V]K\f[R]: A 5-bit unsigned integer immediate operand.
.IP \[bu] 2
\f[V]f\f[R]: A 32- or 64-bit floating-point register (requires F or D
extension).
.IP \[bu] 2
\f[V]r\f[R]: A 32- or 64-bit general-purpose register (depending on the
platform \f[V]XLEN\f[R]).
.IP \[bu] 2
\f[V]vr\f[R]: A vector register.
(requires V extension).
.IP \[bu] 2
\f[V]vm\f[R]: A vector register for masking operand.
(requires V extension).
.PP
Sparc:
.IP \[bu] 2
\f[V]I\f[R]: An immediate 13-bit signed integer.
.IP \[bu] 2
\f[V]r\f[R]: A 32-bit integer register.
.IP \[bu] 2
\f[V]f\f[R]: Any floating-point register on SparcV8, or a floating-point
register in the \[dq]low\[dq] half of the registers on SparcV9.
.IP \[bu] 2
\f[V]e\f[R]: Any floating-point register.
(Same as \f[V]f\f[R] on SparcV8.)
.PP
SystemZ:
.IP \[bu] 2
\f[V]I\f[R]: An immediate unsigned 8-bit integer.
.IP \[bu] 2
\f[V]J\f[R]: An immediate unsigned 12-bit integer.
.IP \[bu] 2
\f[V]K\f[R]: An immediate signed 16-bit integer.
.IP \[bu] 2
\f[V]L\f[R]: An immediate signed 20-bit integer.
.IP \[bu] 2
\f[V]M\f[R]: An immediate integer 0x7fffffff.
.IP \[bu] 2
\f[V]Q\f[R]: A memory address operand with a base address and a 12-bit
immediate unsigned displacement.
.IP \[bu] 2
\f[V]R\f[R]: A memory address operand with a base address, a 12-bit
immediate unsigned displacement, and an index register.
.IP \[bu] 2
\f[V]S\f[R]: A memory address operand with a base address and a 20-bit
immediate signed displacement.
.IP \[bu] 2
\f[V]T\f[R]: A memory address operand with a base address, a 20-bit
immediate signed displacement, and an index register.
.IP \[bu] 2
\f[V]r\f[R] or \f[V]d\f[R]: A 32, 64, or 128-bit integer register.
.IP \[bu] 2
\f[V]a\f[R]: A 32, 64, or 128-bit integer address register (excludes R0,
which in an address context evaluates as zero).
.IP \[bu] 2
\f[V]h\f[R]: A 32-bit value in the high part of a 64bit data register
(LLVM-specific)
.IP \[bu] 2
\f[V]f\f[R]: A 32, 64, or 128-bit floating-point register.
.PP
X86:
.IP \[bu] 2
\f[V]I\f[R]: An immediate integer between 0 and 31.
.IP \[bu] 2
\f[V]J\f[R]: An immediate integer between 0 and 64.
.IP \[bu] 2
\f[V]K\f[R]: An immediate signed 8-bit integer.
.IP \[bu] 2
\f[V]L\f[R]: An immediate integer, 0xff or 0xffff or (in 64-bit mode
only) 0xffffffff.
.IP \[bu] 2
\f[V]M\f[R]: An immediate integer between 0 and 3.
.IP \[bu] 2
\f[V]N\f[R]: An immediate unsigned 8-bit integer.
.IP \[bu] 2
\f[V]O\f[R]: An immediate integer between 0 and 127.
.IP \[bu] 2
\f[V]e\f[R]: An immediate 32-bit signed integer.
.IP \[bu] 2
\f[V]Z\f[R]: An immediate 32-bit unsigned integer.
.IP \[bu] 2
\f[V]o\f[R], \f[V]v\f[R]: Treated the same as \f[V]m\f[R], at the
moment.
.IP \[bu] 2
\f[V]q\f[R]: An 8, 16, 32, or 64-bit register which can be accessed as
an 8-bit \f[V]l\f[R] integer register.
On X86-32, this is the \f[V]a\f[R], \f[V]b\f[R], \f[V]c\f[R], and
\f[V]d\f[R] registers, and on X86-64, it is all of the integer
registers.
.IP \[bu] 2
\f[V]Q\f[R]: An 8, 16, 32, or 64-bit register which can be accessed as
an 8-bit \f[V]h\f[R] integer register.
This is the \f[V]a\f[R], \f[V]b\f[R], \f[V]c\f[R], and \f[V]d\f[R]
registers.
.IP \[bu] 2
\f[V]r\f[R] or \f[V]l\f[R]: An 8, 16, 32, or 64-bit integer register.
.IP \[bu] 2
\f[V]R\f[R]: An 8, 16, 32, or 64-bit \[dq]legacy\[dq] integer register
-- one which has existed since i386, and can be accessed without the REX
prefix.
.IP \[bu] 2
\f[V]f\f[R]: A 32, 64, or 80-bit \[aq]387 FPU stack pseudo-register.
.IP \[bu] 2
\f[V]y\f[R]: A 64-bit MMX register, if MMX is enabled.
.IP \[bu] 2
\f[V]x\f[R]: If SSE is enabled: a 32 or 64-bit scalar operand, or
128-bit vector operand in a SSE register.
If AVX is also enabled, can also be a 256-bit vector operand in an AVX
register.
If AVX-512 is also enabled, can also be a 512-bit vector operand in an
AVX512 register, Otherwise, an error.
.IP \[bu] 2
\f[V]Y\f[R]: The same as \f[V]x\f[R], if \f[I]SSE2\f[R] is enabled,
otherwise an error.
.IP \[bu] 2
\f[V]A\f[R]: Special case: allocates EAX first, then EDX, for a single
operand (in 32-bit mode, a 64-bit integer operand will get split into
two registers).
It is not recommended to use this constraint, as in 64-bit mode, the
64-bit operand will get allocated only to RAX -- if two 32-bit operands
are needed, you\[aq]re better off splitting it yourself, before passing
it to the asm statement.
.PP
XCore:
.IP \[bu] 2
\f[V]r\f[R]: A 32-bit integer register.
.SS Asm template argument modifiers
.PP
In the asm template string, modifiers can be used on the operand
reference, like \[dq]\f[V]${0:n}\f[R]\[dq].
.PP
The modifiers are, in general, expected to behave the same way they do
in GCC.
LLVM\[aq]s support is often implemented on an \[aq]as-needed\[aq] basis,
to support C inline asm code which was supported by GCC.
A mismatch in behavior between LLVM and GCC likely indicates a bug in
LLVM.
.PP
Target-independent:
.IP \[bu] 2
\f[V]c\f[R]: Print an immediate integer constant unadorned, without the
target-specific immediate punctuation (e.g.
no \f[V]$\f[R] prefix).
.IP \[bu] 2
\f[V]n\f[R]: Negate and print immediate integer constant unadorned,
without the target-specific immediate punctuation (e.g.
no \f[V]$\f[R] prefix).
.IP \[bu] 2
\f[V]l\f[R]: Print as an unadorned label, without the target-specific
label punctuation (e.g.
no \f[V]$\f[R] prefix).
.PP
AArch64:
.IP \[bu] 2
\f[V]w\f[R]: Print a GPR register with a \f[V]w*\f[R] name instead of
\f[V]x*\f[R] name.
E.g., instead of \f[V]x30\f[R], print \f[V]w30\f[R].
.IP \[bu] 2
\f[V]x\f[R]: Print a GPR register with a \f[V]x*\f[R] name.
(this is the default, anyhow).
.IP \[bu] 2
\f[V]b\f[R], \f[V]h\f[R], \f[V]s\f[R], \f[V]d\f[R], \f[V]q\f[R]: Print a
floating-point/SIMD register with a \f[V]b*\f[R], \f[V]h*\f[R],
\f[V]s*\f[R], \f[V]d*\f[R], or \f[V]q*\f[R] name, rather than the
default of \f[V]v*\f[R].
.PP
AMDGPU:
.IP \[bu] 2
\f[V]r\f[R]: No effect.
.PP
ARM:
.IP \[bu] 2
\f[V]a\f[R]: Print an operand as an address (with \f[V][\f[R] and
\f[V]]\f[R] surrounding a register).
.IP \[bu] 2
\f[V]P\f[R]: No effect.
.IP \[bu] 2
\f[V]q\f[R]: No effect.
.IP \[bu] 2
\f[V]y\f[R]: Print a VFP single-precision register as an indexed double
(e.g.
print as \f[V]d4[1]\f[R] instead of \f[V]s9\f[R])
.IP \[bu] 2
\f[V]B\f[R]: Bitwise invert and print an immediate integer constant
without \f[V]#\f[R] prefix.
.IP \[bu] 2
\f[V]L\f[R]: Print the low 16-bits of an immediate integer constant.
.IP \[bu] 2
\f[V]M\f[R]: Print as a register set suitable for ldm/stm.
Also prints \f[I]all\f[R] register operands subsequent to the specified
one (!), so use carefully.
.IP \[bu] 2
\f[V]Q\f[R]: Print the low-order register of a register-pair, or the
low-order register of a two-register operand.
.IP \[bu] 2
\f[V]R\f[R]: Print the high-order register of a register-pair, or the
high-order register of a two-register operand.
.IP \[bu] 2
\f[V]H\f[R]: Print the second register of a register-pair.
(On a big-endian system, \f[V]H\f[R] is equivalent to \f[V]Q\f[R], and
on little-endian system, \f[V]H\f[R] is equivalent to \f[V]R\f[R].)
.IP \[bu] 2
\f[V]e\f[R]: Print the low doubleword register of a NEON quad register.
.IP \[bu] 2
\f[V]f\f[R]: Print the high doubleword register of a NEON quad register.
.IP \[bu] 2
\f[V]m\f[R]: Print the base register of a memory operand without the
\f[V][\f[R] and \f[V]]\f[R] adornment.
.PP
Hexagon:
.IP \[bu] 2
\f[V]L\f[R]: Print the second register of a two-register operand.
Requires that it has been allocated consecutively to the first.
.IP \[bu] 2
\f[V]I\f[R]: Print the letter \[aq]i\[aq] if the operand is an integer
constant, otherwise nothing.
Used to print \[aq]addi\[aq] vs \[aq]add\[aq] instructions.
.PP
MSP430:
.PP
No additional modifiers.
.PP
MIPS:
.IP \[bu] 2
\f[V]X\f[R]: Print an immediate integer as hexadecimal
.IP \[bu] 2
\f[V]x\f[R]: Print the low 16 bits of an immediate integer as
hexadecimal.
.IP \[bu] 2
\f[V]d\f[R]: Print an immediate integer as decimal.
.IP \[bu] 2
\f[V]m\f[R]: Subtract one and print an immediate integer as decimal.
.IP \[bu] 2
\f[V]z\f[R]: Print $0 if an immediate zero, otherwise print normally.
.IP \[bu] 2
\f[V]L\f[R]: Print the low-order register of a two-register operand, or
prints the address of the low-order word of a double-word memory
operand.
.IP \[bu] 2
\f[V]M\f[R]: Print the high-order register of a two-register operand, or
prints the address of the high-order word of a double-word memory
operand.
.IP \[bu] 2
\f[V]D\f[R]: Print the second register of a two-register operand, or
prints the second word of a double-word memory operand.
(On a big-endian system, \f[V]D\f[R] is equivalent to \f[V]L\f[R], and
on little-endian system, \f[V]D\f[R] is equivalent to \f[V]M\f[R].)
.IP \[bu] 2
\f[V]w\f[R]: No effect.
Provided for compatibility with GCC which requires this modifier in
order to print MSA registers (\f[V]W0-W31\f[R]) with the \f[V]f\f[R]
constraint.
.PP
NVPTX:
.IP \[bu] 2
\f[V]r\f[R]: No effect.
.PP
PowerPC:
.IP \[bu] 2
\f[V]L\f[R]: Print the second register of a two-register operand.
Requires that it has been allocated consecutively to the first.
.IP \[bu] 2
\f[V]I\f[R]: Print the letter \[aq]i\[aq] if the operand is an integer
constant, otherwise nothing.
Used to print \[aq]addi\[aq] vs \[aq]add\[aq] instructions.
.IP \[bu] 2
\f[V]y\f[R]: For a memory operand, prints formatter for a two-register
X-form instruction.
(Currently always prints \f[V]r0,OPERAND\f[R]).
.IP \[bu] 2
\f[V]U\f[R]: Prints \[aq]u\[aq] if the memory operand is an update form,
and nothing otherwise.
(NOTE: LLVM does not support update form, so this will currently always
print nothing)
.IP \[bu] 2
\f[V]X\f[R]: Prints \[aq]x\[aq] if the memory operand is an indexed
form.
(NOTE: LLVM does not support indexed form, so this will currently always
print nothing)
.PP
RISC-V:
.IP \[bu] 2
\f[V]i\f[R]: Print the letter \[aq]i\[aq] if the operand is not a
register, otherwise print nothing.
Used to print \[aq]addi\[aq] vs \[aq]add\[aq] instructions, etc.
.IP \[bu] 2
\f[V]z\f[R]: Print the register \f[V]zero\f[R] if an immediate zero,
otherwise print normally.
.PP
Sparc:
.IP \[bu] 2
\f[V]r\f[R]: No effect.
.PP
SystemZ:
.PP
SystemZ implements only \f[V]n\f[R], and does \f[I]not\f[R] support any
of the other target-independent modifiers.
.PP
X86:
.IP \[bu] 2
\f[V]c\f[R]: Print an unadorned integer or symbol name.
(The latter is target-specific behavior for this typically
target-independent modifier).
.IP \[bu] 2
\f[V]A\f[R]: Print a register name with a \[aq]\f[V]*\f[R]\[aq] before
it.
.IP \[bu] 2
\f[V]b\f[R]: Print an 8-bit register name (e.g.
\f[V]al\f[R]); do nothing on a memory operand.
.IP \[bu] 2
\f[V]h\f[R]: Print the upper 8-bit register name (e.g.
\f[V]ah\f[R]); do nothing on a memory operand.
.IP \[bu] 2
\f[V]w\f[R]: Print the 16-bit register name (e.g.
\f[V]ax\f[R]); do nothing on a memory operand.
.IP \[bu] 2
\f[V]k\f[R]: Print the 32-bit register name (e.g.
\f[V]eax\f[R]); do nothing on a memory operand.
.IP \[bu] 2
\f[V]q\f[R]: Print the 64-bit register name (e.g.
\f[V]rax\f[R]), if 64-bit registers are available, otherwise the 32-bit
register name; do nothing on a memory operand.
.IP \[bu] 2
\f[V]n\f[R]: Negate and print an unadorned integer, or, for operands
other than an immediate integer (e.g.
a relocatable symbol expression), print a \[aq]-\[aq] before the
operand.
(The behavior for relocatable symbol expressions is a target-specific
behavior for this typically target-independent modifier)
.IP \[bu] 2
\f[V]H\f[R]: Print a memory reference with additional offset +8.
.IP \[bu] 2
\f[V]P\f[R]: Print a memory reference used as the argument of a call
instruction or used with explicit base reg and index reg as its offset.
So it can not use additional regs to present the memory reference.
(E.g.
omit \f[V](rip)\f[R], even though it\[aq]s PC-relative.)
.PP
XCore:
.PP
No additional modifiers.
.SS Inline Asm Metadata
.PP
The call instructions that wrap inline asm nodes may have a
\[dq]\f[V]!srcloc\f[R]\[dq] MDNode attached to it that contains a list
of constant integers.
If present, the code generator will use the integer as the location
cookie value when report errors through the \f[V]LLVMContext\f[R] error
reporting mechanisms.
This allows a front-end to correlate backend errors that occur with
inline asm back to the source code that produced it.
For example:
.IP
.nf
\f[C]
call void asm sideeffect \[dq]something bad\[dq], \[dq]\[dq](), !srcloc !42
\&...
!42 = !{ i32 1234567 }
\f[R]
.fi
.PP
It is up to the front-end to make sense of the magic numbers it places
in the IR.
If the MDNode contains multiple constants, the code generator will use
the one that corresponds to the line of the asm that the error occurs
on.
.SH Metadata
.PP
LLVM IR allows metadata to be attached to instructions and global
objects in the program that can convey extra information about the code
to the optimizers and code generator.
One example application of metadata is source-level debug information.
There are two metadata primitives: strings and nodes.
.PP
Metadata does not have a type, and is not a value.
If referenced from a \f[V]call\f[R] instruction, it uses the
\f[V]metadata\f[R] type.
.PP
All metadata are identified in syntax by an exclamation point
(\[aq]\f[V]!\f[R]\[aq]).
.SS Metadata Nodes and Metadata Strings
.PP
A metadata string is a string surrounded by double quotes.
It can contain any character by escaping non-printable characters with
\[dq]\f[V]\[rs]xx\f[R]\[dq] where \[dq]\f[V]xx\f[R]\[dq] is the two
digit hex code.
For example: \[dq]\f[V]!\[dq]test\[rs]00\[dq]\f[R]\[dq].
.PP
Metadata nodes are represented with notation similar to structure
constants (a comma separated list of elements, surrounded by braces and
preceded by an exclamation point).
Metadata nodes can have any values as their operand.
For example:
.IP
.nf
\f[C]
!{ !\[dq]test\[rs]00\[dq], i32 10}
\f[R]
.fi
.PP
Metadata nodes that aren\[aq]t uniqued use the \f[V]distinct\f[R]
keyword.
For example:
.IP
.nf
\f[C]
!0 = distinct !{!\[dq]test\[rs]00\[dq], i32 10}
\f[R]
.fi
.PP
\f[V]distinct\f[R] nodes are useful when nodes shouldn\[aq]t be merged
based on their content.
They can also occur when transformations cause uniquing collisions when
metadata operands change.
.PP
A \f[V]named metadata <namedmetadatastructure>\f[R] is a collection of
metadata nodes, which can be looked up in the module symbol table.
For example:
.IP
.nf
\f[C]
!foo = !{!4, !3}
\f[R]
.fi
.PP
Metadata can be used as function arguments.
Here the \f[V]llvm.dbg.value\f[R] intrinsic is using three metadata
arguments:
.IP
.nf
\f[C]
call void \[at]llvm.dbg.value(metadata !24, metadata !25, metadata !26)
\f[R]
.fi
.PP
Metadata can be attached to an instruction.
Here metadata \f[V]!21\f[R] is attached to the \f[V]add\f[R] instruction
using the \f[V]!dbg\f[R] identifier:
.IP
.nf
\f[C]
%indvar.next = add i64 %indvar, 1, !dbg !21
\f[R]
.fi
.PP
Instructions may not have multiple metadata attachments with the same
identifier.
.PP
Metadata can also be attached to a function or a global variable.
Here metadata \f[V]!22\f[R] is attached to the \f[V]f1\f[R] and
\f[V]f2\f[R] functions, and the globals \f[V]g1\f[R] and \f[V]g2\f[R]
using the \f[V]!dbg\f[R] identifier:
.IP
.nf
\f[C]
declare !dbg !22 void \[at]f1()
define void \[at]f2() !dbg !22 {
  ret void
}

\[at]g1 = global i32 0, !dbg !22
\[at]g2 = external global i32, !dbg !22
\f[R]
.fi
.PP
Unlike instructions, global objects (functions and global variables) may
have multiple metadata attachments with the same identifier.
.PP
A transformation is required to drop any metadata attachment that it
does not know or know it can\[aq]t preserve.
Currently there is an exception for metadata attachment to globals for
\f[V]!func_sanitize\f[R], \f[V]!type\f[R] and \f[V]!absolute_symbol\f[R]
which can\[aq]t be unconditionally dropped unless the global is itself
deleted.
.PP
Metadata attached to a module using named metadata may not be dropped,
with the exception of debug metadata (named metadata with the name
\f[V]!llvm.dbg.*\f[R]).
.PP
More information about specific metadata nodes recognized by the
optimizers and code generator is found below.
.SS Specialized Metadata Nodes
.PP
Specialized metadata nodes are custom data structures in metadata (as
opposed to generic tuples).
Their fields are labelled, and can be specified in any order.
.PP
These aren\[aq]t inherently debug info centric, but currently all the
specialized metadata nodes are related to debug info.
.SS DICompileUnit
.PP
\f[V]DICompileUnit\f[R] nodes represent a compile unit.
The \f[V]enums:\f[R], \f[V]retainedTypes:\f[R], \f[V]globals:\f[R],
\f[V]imports:\f[R] and \f[V]macros:\f[R] fields are tuples containing
the debug info to be emitted along with the compile unit, regardless of
code optimizations (some nodes are only emitted if there are references
to them from instructions).
The \f[V]debugInfoForProfiling:\f[R] field is a boolean indicating
whether or not line-table discriminators are updated to provide
more-accurate debug info for profiling results.
.IP
.nf
\f[C]
!0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \[dq]clang\[dq],
                    isOptimized: true, flags: \[dq]-O2\[dq], runtimeVersion: 2,
                    splitDebugFilename: \[dq]abc.debug\[dq], emissionKind: FullDebug,
                    enums: !2, retainedTypes: !3, globals: !4, imports: !5,
                    macros: !6, dwoId: 0x0abcd)
\f[R]
.fi
.PP
Compile unit descriptors provide the root scope for objects declared in
a specific compilation unit.
File descriptors are defined using this scope.
These descriptors are collected by a named metadata node
\f[V]!llvm.dbg.cu\f[R].
They keep track of global variables, type information, and imported
entities (declarations and namespaces).
.SS DIFile
.PP
\f[V]DIFile\f[R] nodes represent files.
The \f[V]filename:\f[R] can include slashes.
.IP
.nf
\f[C]
!0 = !DIFile(filename: \[dq]path/to/file\[dq], directory: \[dq]/path/to/dir\[dq],
             checksumkind: CSK_MD5,
             checksum: \[dq]000102030405060708090a0b0c0d0e0f\[dq])
\f[R]
.fi
.PP
Files are sometimes used in \f[V]scope:\f[R] fields, and are the only
valid target for \f[V]file:\f[R] fields.
Valid values for \f[V]checksumkind:\f[R] field are: {CSK_None, CSK_MD5,
CSK_SHA1, CSK_SHA256}
.SS DIBasicType
.PP
\f[V]DIBasicType\f[R] nodes represent primitive types, such as
\f[V]int\f[R], \f[V]bool\f[R] and \f[V]float\f[R].
\f[V]tag:\f[R] defaults to \f[V]DW_TAG_base_type\f[R].
.IP
.nf
\f[C]
!0 = !DIBasicType(name: \[dq]unsigned char\[dq], size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: \[dq]decltype(nullptr)\[dq])
\f[R]
.fi
.PP
The \f[V]encoding:\f[R] describes the details of the type.
Usually it\[aq]s one of the following:
.IP
.nf
\f[C]
DW_ATE_address       = 1
DW_ATE_boolean       = 2
DW_ATE_float         = 4
DW_ATE_signed        = 5
DW_ATE_signed_char   = 6
DW_ATE_unsigned      = 7
DW_ATE_unsigned_char = 8
\f[R]
.fi
.SS DISubroutineType
.PP
\f[V]DISubroutineType\f[R] nodes represent subroutine types.
Their \f[V]types:\f[R] field refers to a tuple; the first operand is the
return type, while the rest are the types of the formal arguments in
order.
If the first operand is \f[V]null\f[R], that represents a function with
no return value (such as \f[V]void foo() {}\f[R] in C++).
.IP
.nf
\f[C]
!0 = !BasicType(name: \[dq]int\[dq], size: 32, align: 32, DW_ATE_signed)
!1 = !BasicType(name: \[dq]char\[dq], size: 8, align: 8, DW_ATE_signed_char)
!2 = !DISubroutineType(types: !{null, !0, !1}) ; void (int, char)
\f[R]
.fi
.SS DIDerivedType
.PP
\f[V]DIDerivedType\f[R] nodes represent types derived from other types,
such as qualified types.
.IP
.nf
\f[C]
!0 = !DIBasicType(name: \[dq]unsigned char\[dq], size: 8, align: 8,
                  encoding: DW_ATE_unsigned_char)
!1 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !0, size: 32,
                    align: 32)
\f[R]
.fi
.PP
The following \f[V]tag:\f[R] values are valid:
.IP
.nf
\f[C]
DW_TAG_member             = 13
DW_TAG_pointer_type       = 15
DW_TAG_reference_type     = 16
DW_TAG_typedef            = 22
DW_TAG_inheritance        = 28
DW_TAG_ptr_to_member_type = 31
DW_TAG_const_type         = 38
DW_TAG_friend             = 42
DW_TAG_volatile_type      = 53
DW_TAG_restrict_type      = 55
DW_TAG_atomic_type        = 71
DW_TAG_immutable_type     = 75
\f[R]
.fi
.PP
\f[V]DW_TAG_member\f[R] is used to define a member of a
\f[V]composite type
<DICompositeType>\f[R].
The type of the member is the \f[V]baseType:\f[R].
The \f[V]offset:\f[R] is the member\[aq]s bit offset.
If the composite type has an ODR \f[V]identifier:\f[R] and does not set
\f[V]flags: DIFwdDecl\f[R], then the member is uniqued based only on its
\f[V]name:\f[R] and \f[V]scope:\f[R].
.PP
\f[V]DW_TAG_inheritance\f[R] and \f[V]DW_TAG_friend\f[R] are used in the
\f[V]elements:\f[R] field of \f[V]composite types <DICompositeType>\f[R]
to describe parents and friends.
.PP
\f[V]DW_TAG_typedef\f[R] is used to provide a name for the
\f[V]baseType:\f[R].
.PP
\f[V]DW_TAG_pointer_type\f[R], \f[V]DW_TAG_reference_type\f[R],
\f[V]DW_TAG_const_type\f[R], \f[V]DW_TAG_volatile_type\f[R],
\f[V]DW_TAG_restrict_type\f[R], \f[V]DW_TAG_atomic_type\f[R] and
\f[V]DW_TAG_immutable_type\f[R] are used to qualify the
\f[V]baseType:\f[R].
.PP
Note that the \f[V]void *\f[R] type is expressed as a type derived from
NULL.
.SS DICompositeType
.PP
\f[V]DICompositeType\f[R] nodes represent types composed of other types,
like structures and unions.
\f[V]elements:\f[R] points to a tuple of the composed types.
.PP
If the source language supports ODR, the \f[V]identifier:\f[R] field
gives the unique identifier used for type merging between modules.
When specified,
\f[V]subprogram declarations <DISubprogramDeclaration>\f[R] and
\f[V]member
derived types <DIDerivedTypeMember>\f[R] that reference the ODR-type in
their \f[V]scope:\f[R] change uniquing rules.
.PP
For a given \f[V]identifier:\f[R], there should only be a single
composite type that does not have \f[V]flags: DIFlagFwdDecl\f[R] set.
LLVM tools that link modules together will unique such definitions at
parse time via the \f[V]identifier:\f[R] field, even if the nodes are
\f[V]distinct\f[R].
.IP
.nf
\f[C]
!0 = !DIEnumerator(name: \[dq]SixKind\[dq], value: 7)
!1 = !DIEnumerator(name: \[dq]SevenKind\[dq], value: 7)
!2 = !DIEnumerator(name: \[dq]NegEightKind\[dq], value: -8)
!3 = !DICompositeType(tag: DW_TAG_enumeration_type, name: \[dq]Enum\[dq], file: !12,
                      line: 2, size: 32, align: 32, identifier: \[dq]_M4Enum\[dq],
                      elements: !{!0, !1, !2})
\f[R]
.fi
.PP
The following \f[V]tag:\f[R] values are valid:
.IP
.nf
\f[C]
DW_TAG_array_type       = 1
DW_TAG_class_type       = 2
DW_TAG_enumeration_type = 4
DW_TAG_structure_type   = 19
DW_TAG_union_type       = 23
\f[R]
.fi
.PP
For \f[V]DW_TAG_array_type\f[R], the \f[V]elements:\f[R] should be
\f[V]subrange
descriptors <DISubrange>\f[R], each representing the range of subscripts
at that level of indexing.
The \f[V]DIFlagVector\f[R] flag to \f[V]flags:\f[R] indicates that an
array type is a native packed vector.
The optional \f[V]dataLocation\f[R] is a DIExpression that describes how
to get from an object\[aq]s address to the actual raw data, if they
aren\[aq]t equivalent.
This is only supported for array types, particularly to describe Fortran
arrays, which have an array descriptor in addition to the array data.
Alternatively it can also be DIVariable which has the address of the
actual raw data.
The Fortran language supports pointer arrays which can be attached to
actual arrays, this attachment between pointer and pointee is called
association.
The optional \f[V]associated\f[R] is a DIExpression that describes
whether the pointer array is currently associated.
The optional \f[V]allocated\f[R] is a DIExpression that describes
whether the allocatable array is currently allocated.
The optional \f[V]rank\f[R] is a DIExpression that describes the rank
(number of dimensions) of fortran assumed rank array (rank is known at
runtime).
.PP
For \f[V]DW_TAG_enumeration_type\f[R], the \f[V]elements:\f[R] should be
\f[V]enumerator
descriptors <DIEnumerator>\f[R], each representing the definition of an
enumeration value for the set.
All enumeration type descriptors are collected in the \f[V]enums:\f[R]
field of the \f[V]compile unit <DICompileUnit>\f[R].
.PP
For \f[V]DW_TAG_structure_type\f[R], \f[V]DW_TAG_class_type\f[R], and
\f[V]DW_TAG_union_type\f[R], the \f[V]elements:\f[R] should be
\f[V]derived types
<DIDerivedType>\f[R] with \f[V]tag: DW_TAG_member\f[R],
\f[V]tag: DW_TAG_inheritance\f[R], or \f[V]tag: DW_TAG_friend\f[R]; or
\f[V]subprograms <DISubprogram>\f[R] with \f[V]isDefinition: false\f[R].
.SS DISubrange
.PP
\f[V]DISubrange\f[R] nodes are the elements for
\f[V]DW_TAG_array_type\f[R] variants of \f[V]DICompositeType\f[R].
.IP \[bu] 2
\f[V]count: -1\f[R] indicates an empty array.
.IP \[bu] 2
\f[V]count: !10\f[R] describes the count with a
\f[V]DILocalVariable\f[R].
.IP \[bu] 2
\f[V]count: !12\f[R] describes the count with a
\f[V]DIGlobalVariable\f[R].
.IP
.nf
\f[C]
!0 = !DISubrange(count: 5, lowerBound: 0) ; array counting from 0
!1 = !DISubrange(count: 5, lowerBound: 1) ; array counting from 1
!2 = !DISubrange(count: -1) ; empty array.

; Scopes used in rest of example
!6 = !DIFile(filename: \[dq]vla.c\[dq], directory: \[dq]/path/to/file\[dq])
!7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !6)
!8 = distinct !DISubprogram(name: \[dq]foo\[dq], scope: !7, file: !6, line: 5)

; Use of local variable as count value
!9 = !DIBasicType(name: \[dq]int\[dq], size: 32, encoding: DW_ATE_signed)
!10 = !DILocalVariable(name: \[dq]count\[dq], scope: !8, file: !6, line: 42, type: !9)
!11 = !DISubrange(count: !10, lowerBound: 0)

; Use of global variable as count value
!12 = !DIGlobalVariable(name: \[dq]count\[dq], scope: !8, file: !6, line: 22, type: !9)
!13 = !DISubrange(count: !12, lowerBound: 0)
\f[R]
.fi
.SS DIEnumerator
.PP
\f[V]DIEnumerator\f[R] nodes are the elements for
\f[V]DW_TAG_enumeration_type\f[R] variants of \f[V]DICompositeType\f[R].
.IP
.nf
\f[C]
!0 = !DIEnumerator(name: \[dq]SixKind\[dq], value: 7)
!1 = !DIEnumerator(name: \[dq]SevenKind\[dq], value: 7)
!2 = !DIEnumerator(name: \[dq]NegEightKind\[dq], value: -8)
\f[R]
.fi
.SS DITemplateTypeParameter
.PP
\f[V]DITemplateTypeParameter\f[R] nodes represent type parameters to
generic source language constructs.
They are used (optionally) in \f[V]DICompositeType\f[R] and
\f[V]DISubprogram\f[R] \f[V]templateParams:\f[R] fields.
.IP
.nf
\f[C]
!0 = !DITemplateTypeParameter(name: \[dq]Ty\[dq], type: !1)
\f[R]
.fi
.SS DITemplateValueParameter
.PP
\f[V]DITemplateValueParameter\f[R] nodes represent value parameters to
generic source language constructs.
\f[V]tag:\f[R] defaults to \f[V]DW_TAG_template_value_parameter\f[R],
but if specified can also be set to
\f[V]DW_TAG_GNU_template_template_param\f[R] or
\f[V]DW_TAG_GNU_template_param_pack\f[R].
They are used (optionally) in \f[V]DICompositeType\f[R] and
\f[V]DISubprogram\f[R] \f[V]templateParams:\f[R] fields.
.IP
.nf
\f[C]
!0 = !DITemplateValueParameter(name: \[dq]Ty\[dq], type: !1, value: i32 7)
\f[R]
.fi
.SS DINamespace
.PP
\f[V]DINamespace\f[R] nodes represent namespaces in the source language.
.IP
.nf
\f[C]
!0 = !DINamespace(name: \[dq]myawesomeproject\[dq], scope: !1, file: !2, line: 7)
\f[R]
.fi
.SS DIGlobalVariable
.PP
\f[V]DIGlobalVariable\f[R] nodes represent global variables in the
source language.
.IP
.nf
\f[C]
\[at]foo = global i32, !dbg !0
!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
!1 = !DIGlobalVariable(name: \[dq]foo\[dq], linkageName: \[dq]foo\[dq], scope: !2,
                       file: !3, line: 7, type: !4, isLocal: true,
                       isDefinition: false, declaration: !5)
\f[R]
.fi
.SS DIGlobalVariableExpression
.PP
\f[V]DIGlobalVariableExpression\f[R] nodes tie a
\f[V]DIGlobalVariable\f[R] together with a \f[V]DIExpression\f[R].
.IP
.nf
\f[C]
\[at]lower = global i32, !dbg !0
\[at]upper = global i32, !dbg !1
!0 = !DIGlobalVariableExpression(
         var: !2,
         expr: !DIExpression(DW_OP_LLVM_fragment, 0, 32)
         )
!1 = !DIGlobalVariableExpression(
         var: !2,
         expr: !DIExpression(DW_OP_LLVM_fragment, 32, 32)
         )
!2 = !DIGlobalVariable(name: \[dq]split64\[dq], linkageName: \[dq]split64\[dq], scope: !3,
                       file: !4, line: 8, type: !5, declaration: !6)
\f[R]
.fi
.PP
All global variable expressions should be referenced by the globals:
field of a \f[V]compile unit <DICompileUnit>\f[R].
.SS DISubprogram
.PP
\f[V]DISubprogram\f[R] nodes represent functions from the source
language.
A distinct \f[V]DISubprogram\f[R] may be attached to a function
definition using \f[V]!dbg\f[R] metadata.
A unique \f[V]DISubprogram\f[R] may be attached to a function
declaration used for call site debug info.
The \f[V]retainedNodes:\f[R] field is a list of
\f[V]variables <DILocalVariable>\f[R] and \f[V]labels <DILabel>\f[R]
that must be retained, even if their IR counterparts are optimized out
of the IR.
The \f[V]type:\f[R] field must point at an \f[V]DISubroutineType\f[R].
.PP
When \f[V]isDefinition: false\f[R], subprograms describe a declaration
in the type tree as opposed to a definition of a function.
If the scope is a composite type with an ODR \f[V]identifier:\f[R] and
that does not set \f[V]flags: DIFwdDecl\f[R], then the subprogram
declaration is uniqued based only on its \f[V]linkageName:\f[R] and
\f[V]scope:\f[R].
.IP
.nf
\f[C]
define void \[at]_Z3foov() !dbg !0 {
  ...
}

!0 = distinct !DISubprogram(name: \[dq]foo\[dq], linkageName: \[dq]_Zfoov\[dq], scope: !1,
                            file: !2, line: 7, type: !3, isLocal: true,
                            isDefinition: true, scopeLine: 8,
                            containingType: !4,
                            virtuality: DW_VIRTUALITY_pure_virtual,
                            virtualIndex: 10, flags: DIFlagPrototyped,
                            isOptimized: true, unit: !5, templateParams: !6,
                            declaration: !7, retainedNodes: !8,
                            thrownTypes: !9)
\f[R]
.fi
.SS DILexicalBlock
.PP
\f[V]DILexicalBlock\f[R] nodes describe nested blocks within a
\f[V]subprogram
<DISubprogram>\f[R].
The line number and column numbers are used to distinguish two lexical
blocks at same depth.
They are valid targets for \f[V]scope:\f[R] fields.
.IP
.nf
\f[C]
!0 = distinct !DILexicalBlock(scope: !1, file: !2, line: 7, column: 35)
\f[R]
.fi
.PP
Usually lexical blocks are \f[V]distinct\f[R] to prevent node merging
based on operands.
.SS DILexicalBlockFile
.PP
\f[V]DILexicalBlockFile\f[R] nodes are used to discriminate between
sections of a \f[V]lexical block <DILexicalBlock>\f[R].
The \f[V]file:\f[R] field can be changed to indicate textual inclusion,
or the \f[V]discriminator:\f[R] field can be used to discriminate
between control flow within a single block in the source language.
.IP
.nf
\f[C]
!0 = !DILexicalBlock(scope: !3, file: !4, line: 7, column: 35)
!1 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 0)
!2 = !DILexicalBlockFile(scope: !0, file: !4, discriminator: 1)
\f[R]
.fi
.SS DILocation
.PP
\f[V]DILocation\f[R] nodes represent source debug locations.
The \f[V]scope:\f[R] field is mandatory, and points at an
\f[V]DILexicalBlockFile\f[R], an \f[V]DILexicalBlock\f[R], or an
\f[V]DISubprogram\f[R].
.IP
.nf
\f[C]
!0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2)
\f[R]
.fi
.SS DILocalVariable
.PP
\f[V]DILocalVariable\f[R] nodes represent local variables in the source
language.
If the \f[V]arg:\f[R] field is set to non-zero, then this variable is a
subprogram parameter, and it will be included in the
\f[V]retainedNodes:\f[R] field of its \f[V]DISubprogram\f[R].
.IP
.nf
\f[C]
!0 = !DILocalVariable(name: \[dq]this\[dq], arg: 1, scope: !3, file: !2, line: 7,
                      type: !3, flags: DIFlagArtificial)
!1 = !DILocalVariable(name: \[dq]x\[dq], arg: 2, scope: !4, file: !2, line: 7,
                      type: !3)
!2 = !DILocalVariable(name: \[dq]y\[dq], scope: !5, file: !2, line: 7, type: !3)
\f[R]
.fi
.SS DIExpression
.PP
\f[V]DIExpression\f[R] nodes represent expressions that are inspired by
the DWARF expression language.
They are used in \f[V]debug intrinsics<dbg_intrinsics>\f[R] (such as
\f[V]llvm.dbg.declare\f[R] and \f[V]llvm.dbg.value\f[R]) to describe how
the referenced LLVM variable relates to the source language variable.
Debug intrinsics are interpreted left-to-right: start by pushing the
value/address operand of the intrinsic onto a stack, then repeatedly
push and evaluate opcodes from the DIExpression until the final variable
description is produced.
.PP
The current supported opcode vocabulary is limited:
.IP \[bu] 2
\f[V]DW_OP_deref\f[R] dereferences the top of the expression stack.
.IP \[bu] 2
\f[V]DW_OP_plus\f[R] pops the last two entries from the expression
stack, adds them together and appends the result to the expression
stack.
.IP \[bu] 2
\f[V]DW_OP_minus\f[R] pops the last two entries from the expression
stack, subtracts the last entry from the second last entry and appends
the result to the expression stack.
.IP \[bu] 2
\f[V]DW_OP_plus_uconst, 93\f[R] adds \f[V]93\f[R] to the working
expression.
.IP \[bu] 2
\f[V]DW_OP_LLVM_fragment, 16, 8\f[R] specifies the offset and size
(\f[V]16\f[R] and \f[V]8\f[R] here, respectively) of the variable
fragment from the working expression.
Note that contrary to DW_OP_bit_piece, the offset is describing the
location within the described source variable.
.IP \[bu] 2
\f[V]DW_OP_LLVM_convert, 16, DW_ATE_signed\f[R] specifies a bit size and
encoding (\f[V]16\f[R] and \f[V]DW_ATE_signed\f[R] here, respectively)
to which the top of the expression stack is to be converted.
Maps into a \f[V]DW_OP_convert\f[R] operation that references a base
type constructed from the supplied values.
.IP \[bu] 2
\f[V]DW_OP_LLVM_tag_offset, tag_offset\f[R] specifies that a memory tag
should be optionally applied to the pointer.
The memory tag is derived from the given tag offset in an
implementation-defined manner.
.IP \[bu] 2
\f[V]DW_OP_swap\f[R] swaps top two stack entries.
.IP \[bu] 2
\f[V]DW_OP_xderef\f[R] provides extended dereference mechanism.
The entry at the top of the stack is treated as an address.
The second stack entry is treated as an address space identifier.
.IP \[bu] 2
\f[V]DW_OP_stack_value\f[R] marks a constant value.
.IP \[bu] 2
\f[V]DW_OP_LLVM_entry_value, N\f[R] may only appear in MIR and at the
beginning of a \f[V]DIExpression\f[R].
In DWARF a \f[V]DBG_VALUE\f[R] instruction binding a
\f[V]DIExpression(DW_OP_LLVM_entry_value\f[R] to a register is lowered
to a \f[V]DW_OP_entry_value [reg]\f[R], pushing the value the register
had upon function entry onto the stack.
The next \f[V](N - 1)\f[R] operations will be part of the
\f[V]DW_OP_entry_value\f[R] block argument.
For example,
\f[V]!DIExpression(DW_OP_LLVM_entry_value, 1, DW_OP_plus_uconst, 123, DW_OP_stack_value)\f[R]
specifies an expression where the entry value of the debug value
instruction\[aq]s value/address operand is pushed to the stack, and is
added with 123.
Due to framework limitations \f[V]N\f[R] can currently only be 1.
.RS 2
.PP
The operation is introduced by the \f[V]LiveDebugValues\f[R] pass, which
applies it only to function parameters that are unmodified throughout
the function.
Support is limited to simple register location descriptions, or as
indirect locations (e.g., when a struct is passed-by-value to a callee
via a pointer to a temporary copy made in the caller).
The entry value op is also introduced by the \f[V]AsmPrinter\f[R] pass
when a call site parameter value
(\f[V]DW_AT_call_site_parameter_value\f[R]) is represented as entry
value of the parameter.
.RE
.IP \[bu] 2
\f[V]DW_OP_LLVM_arg, N\f[R] is used in debug intrinsics that refer to
more than one value, such as one that calculates the sum of two
registers.
This is always used in combination with an ordered list of values, such
that \f[V]DW_OP_LLVM_arg, N\f[R] refers to the \f[V]N\f[R]th element in
that list.
For example,
\f[V]!DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_stack_value)\f[R]
used with the list \f[V](%reg1, %reg2)\f[R] would evaluate to
\f[V]%reg1 - reg2\f[R].
This list of values should be provided by the containing
intrinsic/instruction.
.IP \[bu] 2
\f[V]DW_OP_breg\f[R] (or \f[V]DW_OP_bregx\f[R]) represents a content on
the provided signed offset of the specified register.
The opcode is only generated by the \f[V]AsmPrinter\f[R] pass to
describe call site parameter value which requires an expression over two
registers.
.IP \[bu] 2
\f[V]DW_OP_push_object_address\f[R] pushes the address of the object
which can then serve as a descriptor in subsequent calculation.
This opcode can be used to calculate bounds of fortran allocatable array
which has array descriptors.
.IP \[bu] 2
\f[V]DW_OP_over\f[R] duplicates the entry currently second in the stack
at the top of the stack.
This opcode can be used to calculate bounds of fortran assumed rank
array which has rank known at run time and current dimension number is
implicitly first element of the stack.
.IP \[bu] 2
\f[V]DW_OP_LLVM_implicit_pointer\f[R] It specifies the dereferenced
value.
It can be used to represent pointer variables which are optimized out
but the value it points to is known.
This operator is required as it is different than DWARF operator
DW_OP_implicit_pointer in representation and specification (number and
types of operands) and later can not be used as multiple level.
.IP
.nf
\f[C]
IR for \[dq]*ptr = 4;\[dq]
--------------
call void \[at]llvm.dbg.value(metadata i32 4, metadata !17, metadata !20)
!17 = !DILocalVariable(name: \[dq]ptr1\[dq], scope: !12, file: !3, line: 5,
                       type: !18)
!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64)
!19 = !DIBasicType(name: \[dq]int\[dq], size: 32, encoding: DW_ATE_signed)
!20 = !DIExpression(DW_OP_LLVM_implicit_pointer))

IR for \[dq]**ptr = 4;\[dq]
--------------
call void \[at]llvm.dbg.value(metadata i32 4, metadata !17, metadata !21)
!17 = !DILocalVariable(name: \[dq]ptr1\[dq], scope: !12, file: !3, line: 5,
                       type: !18)
!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64)
!19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64)
!20 = !DIBasicType(name: \[dq]int\[dq], size: 32, encoding: DW_ATE_signed)
!21 = !DIExpression(DW_OP_LLVM_implicit_pointer,
                    DW_OP_LLVM_implicit_pointer))
\f[R]
.fi
.PP
DWARF specifies three kinds of simple location descriptions: Register,
memory, and implicit location descriptions.
Note that a location description is defined over certain ranges of a
program, i.e the location of a variable may change over the course of
the program.
Register and memory location descriptions describe the \f[I]concrete
location\f[R] of a source variable (in the sense that a debugger might
modify its value), whereas \f[I]implicit locations\f[R] describe merely
the actual \f[I]value\f[R] of a source variable which might not exist in
registers or in memory (see \f[V]DW_OP_stack_value\f[R]).
.PP
A \f[V]llvm.dbg.addr\f[R] or \f[V]llvm.dbg.declare\f[R] intrinsic
describes an indirect value (the address) of a source variable.
The first operand of the intrinsic must be an address of some kind.
A DIExpression attached to the intrinsic refines this address to produce
a concrete location for the source variable.
.PP
A \f[V]llvm.dbg.value\f[R] intrinsic describes the direct value of a
source variable.
The first operand of the intrinsic may be a direct or indirect value.
A DIExpression attached to the intrinsic refines the first operand to
produce a direct value.
For example, if the first operand is an indirect value, it may be
necessary to insert \f[V]DW_OP_deref\f[R] into the DIExpression in order
to produce a valid debug intrinsic.
.PP
Note
.PP
A DIExpression is interpreted in the same way regardless of which kind
of debug intrinsic it\[aq]s attached to.
.IP
.nf
\f[C]
!0 = !DIExpression(DW_OP_deref)
!1 = !DIExpression(DW_OP_plus_uconst, 3)
!1 = !DIExpression(DW_OP_constu, 3, DW_OP_plus)
!2 = !DIExpression(DW_OP_bit_piece, 3, 7)
!3 = !DIExpression(DW_OP_deref, DW_OP_constu, 3, DW_OP_plus, DW_OP_LLVM_fragment, 3, 7)
!4 = !DIExpression(DW_OP_constu, 2, DW_OP_swap, DW_OP_xderef)
!5 = !DIExpression(DW_OP_constu, 42, DW_OP_stack_value)
\f[R]
.fi
.SS DIArgList
.PP
\f[V]DIArgList\f[R] nodes hold a list of constant or SSA value
references.
These are used in \f[V]debug intrinsics<dbg_intrinsics>\f[R] (currently
only in \f[V]llvm.dbg.value\f[R]) in combination with a
\f[V]DIExpression\f[R] that uses the \f[V]DW_OP_LLVM_arg\f[R] operator.
Because a DIArgList may refer to local values within a function, it must
only be used as a function argument, must always be inlined, and cannot
appear in named metadata.
.IP
.nf
\f[C]
llvm.dbg.value(metadata !DIArgList(i32 %a, i32 %b),
               metadata !16,
               metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus))
\f[R]
.fi
.SS DIFlags
.PP
These flags encode various properties of DINodes.
.PP
The ExportSymbols flag marks a class, struct or union whose members may
be referenced as if they were defined in the containing class or union.
This flag is used to decide whether the DW_AT_export_symbols can be used
for the structure type.
.SS DIObjCProperty
.PP
\f[V]DIObjCProperty\f[R] nodes represent Objective-C property nodes.
.IP
.nf
\f[C]
!3 = !DIObjCProperty(name: \[dq]foo\[dq], file: !1, line: 7, setter: \[dq]setFoo\[dq],
                     getter: \[dq]getFoo\[dq], attributes: 7, type: !2)
\f[R]
.fi
.SS DIImportedEntity
.PP
\f[V]DIImportedEntity\f[R] nodes represent entities (such as modules)
imported into a compile unit.
The \f[V]elements\f[R] field is a list of renamed entities (such as
variables and subprograms) in the imported entity (such as module).
.IP
.nf
\f[C]
!2 = !DIImportedEntity(tag: DW_TAG_imported_module, name: \[dq]foo\[dq], scope: !0,
                       entity: !1, line: 7, elements: !3)
!3 = !{!4}
!4 = !DIImportedEntity(tag: DW_TAG_imported_declaration, name: \[dq]bar\[dq], scope: !0,
                       entity: !5, line: 7)
\f[R]
.fi
.SS DIMacro
.PP
\f[V]DIMacro\f[R] nodes represent definition or undefinition of a macro
identifiers.
The \f[V]name:\f[R] field is the macro identifier, followed by macro
parameters when defining a function-like macro, and the \f[V]value\f[R]
field is the token-string used to expand the macro identifier.
.IP
.nf
\f[C]
!2 = !DIMacro(macinfo: DW_MACINFO_define, line: 7, name: \[dq]foo(x)\[dq],
              value: \[dq]((x) + 1)\[dq])
!3 = !DIMacro(macinfo: DW_MACINFO_undef, line: 30, name: \[dq]foo\[dq])
\f[R]
.fi
.SS DIMacroFile
.PP
\f[V]DIMacroFile\f[R] nodes represent inclusion of source files.
The \f[V]nodes:\f[R] field is a list of \f[V]DIMacro\f[R] and
\f[V]DIMacroFile\f[R] nodes that appear in the included source file.
.IP
.nf
\f[C]
!2 = !DIMacroFile(macinfo: DW_MACINFO_start_file, line: 7, file: !2,
                  nodes: !3)
\f[R]
.fi
.SS DILabel
.PP
\f[V]DILabel\f[R] nodes represent labels within a
\f[V]DISubprogram\f[R].
All fields of a \f[V]DILabel\f[R] are mandatory.
The \f[V]scope:\f[R] field must be one of either a
\f[V]DILexicalBlockFile\f[R], a \f[V]DILexicalBlock\f[R], or a
\f[V]DISubprogram\f[R].
The \f[V]name:\f[R] field is the label identifier.
The \f[V]file:\f[R] field is the \f[V]DIFile\f[R] the label is present
in.
The \f[V]line:\f[R] field is the source line within the file where the
label is declared.
.IP
.nf
\f[C]
!2 = !DILabel(scope: !0, name: \[dq]foo\[dq], file: !1, line: 7)
\f[R]
.fi
.SS \[aq]\f[V]tbaa\f[R]\[aq] Metadata
.PP
In LLVM IR, memory does not have types, so LLVM\[aq]s own type system is
not suitable for doing type based alias analysis (TBAA).
Instead, metadata is added to the IR to describe a type system of a
higher level language.
This can be used to implement C/C++ strict type aliasing rules, but it
can also be used to implement custom alias analysis behavior for other
languages.
.PP
This description of LLVM\[aq]s TBAA system is broken into two parts:
\f[V]Semantics<tbaa_node_semantics>\f[R] talks about high level issues,
and \f[V]Representation<tbaa_node_representation>\f[R] talks about the
metadata encoding of various entities.
.PP
It is always possible to trace any TBAA node to a \[dq]root\[dq] TBAA
node (details in the \f[V]Representation<tbaa_node_representation>\f[R]
section).
TBAA nodes with different roots have an unknown aliasing relationship,
and LLVM conservatively infers \f[V]MayAlias\f[R] between them.
The rules mentioned in this section only pertain to TBAA nodes living
under the same root.
.SS Semantics
.PP
The TBAA metadata system, referred to as \[dq]struct path TBAA\[dq] (not
to be confused with \f[V]tbaa.struct\f[R]), consists of the following
high level concepts: \f[I]Type Descriptors\f[R], further subdivided into
scalar type descriptors and struct type descriptors; and \f[I]Access
Tags\f[R].
.PP
\f[B]Type descriptors\f[R] describe the type system of the higher level
language being compiled.
\f[B]Scalar type descriptors\f[R] describe types that do not contain
other types.
Each scalar type has a parent type, which must also be a scalar type or
the TBAA root.
Via this parent relation, scalar types within a TBAA root form a tree.
\f[B]Struct type descriptors\f[R] denote types that contain a sequence
of other type descriptors, at known offsets.
These contained type descriptors can either be struct type descriptors
themselves or scalar type descriptors.
.PP
\f[B]Access tags\f[R] are metadata nodes attached to load and store
instructions.
Access tags use type descriptors to describe the \f[I]location\f[R]
being accessed in terms of the type system of the higher level language.
Access tags are tuples consisting of a base type, an access type and an
offset.
The base type is a scalar type descriptor or a struct type descriptor,
the access type is a scalar type descriptor, and the offset is a
constant integer.
.PP
The access tag \f[V](BaseTy, AccessTy, Offset)\f[R] can describe one of
two things:
.RS
.IP \[bu] 2
If \f[V]BaseTy\f[R] is a struct type, the tag describes a memory access
(load or store) of a value of type \f[V]AccessTy\f[R] contained in the
struct type \f[V]BaseTy\f[R] at offset \f[V]Offset\f[R].
.IP \[bu] 2
If \f[V]BaseTy\f[R] is a scalar type, \f[V]Offset\f[R] must be 0 and
\f[V]BaseTy\f[R] and \f[V]AccessTy\f[R] must be the same; and the access
tag describes a scalar access with scalar type \f[V]AccessTy\f[R].
.RE
.PP
We first define an \f[V]ImmediateParent\f[R] relation on
\f[V](BaseTy, Offset)\f[R] tuples this way:
.RS
.IP \[bu] 2
If \f[V]BaseTy\f[R] is a scalar type then
\f[V]ImmediateParent(BaseTy, 0)\f[R] is \f[V](ParentTy, 0)\f[R] where
\f[V]ParentTy\f[R] is the parent of the scalar type as described in the
TBAA metadata.
\f[V]ImmediateParent(BaseTy, Offset)\f[R] is undefined if
\f[V]Offset\f[R] is non-zero.
.IP \[bu] 2
If \f[V]BaseTy\f[R] is a struct type then
\f[V]ImmediateParent(BaseTy, Offset)\f[R] is
\f[V](NewTy, NewOffset)\f[R] where \f[V]NewTy\f[R] is the type contained
in \f[V]BaseTy\f[R] at offset \f[V]Offset\f[R] and \f[V]NewOffset\f[R]
is \f[V]Offset\f[R] adjusted to be relative within that inner type.
.RE
.PP
A memory access with an access tag
\f[V](BaseTy1, AccessTy1, Offset1)\f[R] aliases a memory access with an
access tag \f[V](BaseTy2, AccessTy2, Offset2)\f[R] if either
\f[V](BaseTy1, Offset1)\f[R] is reachable from
\f[V](Base2, Offset2)\f[R] via the \f[V]Parent\f[R] relation or vice
versa.
.PP
As a concrete example, the type descriptor graph for the following
program
.IP
.nf
\f[C]
struct Inner {
  int i;    // offset 0
  float f;  // offset 4
};

struct Outer {
  float f;  // offset 0
  double d; // offset 4
  struct Inner inner_a;  // offset 12
};

void f(struct Outer* outer, struct Inner* inner, float* f, int* i, char* c) {
  outer->f = 0;            // tag0: (OuterStructTy, FloatScalarTy, 0)
  outer->inner_a.i = 0;    // tag1: (OuterStructTy, IntScalarTy, 12)
  outer->inner_a.f = 0.0;  // tag2: (OuterStructTy, FloatScalarTy, 16)
  *f = 0.0;                // tag3: (FloatScalarTy, FloatScalarTy, 0)
}
\f[R]
.fi
.PP
is (note that in C and C++, \f[V]char\f[R] can be used to access any
arbitrary type):
.IP
.nf
\f[C]
Root = \[dq]TBAA Root\[dq]
CharScalarTy = (\[dq]char\[dq], Root, 0)
FloatScalarTy = (\[dq]float\[dq], CharScalarTy, 0)
DoubleScalarTy = (\[dq]double\[dq], CharScalarTy, 0)
IntScalarTy = (\[dq]int\[dq], CharScalarTy, 0)
InnerStructTy = {\[dq]Inner\[dq] (IntScalarTy, 0), (FloatScalarTy, 4)}
OuterStructTy = {\[dq]Outer\[dq], (FloatScalarTy, 0), (DoubleScalarTy, 4),
                 (InnerStructTy, 12)}
\f[R]
.fi
.PP
with (e.g.)
\f[V]ImmediateParent(OuterStructTy, 12)\f[R] =
\f[V](InnerStructTy, 0)\f[R],
\f[V]ImmediateParent(InnerStructTy, 0)\f[R] =
\f[V](IntScalarTy, 0)\f[R], and
\f[V]ImmediateParent(IntScalarTy, 0)\f[R] = \f[V](CharScalarTy, 0)\f[R].
.SS Representation
.PP
The root node of a TBAA type hierarchy is an \f[V]MDNode\f[R] with 0
operands or with exactly one \f[V]MDString\f[R] operand.
.PP
Scalar type descriptors are represented as an \f[V]MDNode\f[R] s with
two operands.
The first operand is an \f[V]MDString\f[R] denoting the name of the
struct type.
LLVM does not assign meaning to the value of this operand, it only cares
about it being an \f[V]MDString\f[R].
The second operand is an \f[V]MDNode\f[R] which points to the parent for
said scalar type descriptor, which is either another scalar type
descriptor or the TBAA root.
Scalar type descriptors can have an optional third argument, but that
must be the constant integer zero.
.PP
Struct type descriptors are represented as \f[V]MDNode\f[R] s with an
odd number of operands greater than 1.
The first operand is an \f[V]MDString\f[R] denoting the name of the
struct type.
Like in scalar type descriptors the actual value of this name operand is
irrelevant to LLVM.
After the name operand, the struct type descriptors have a sequence of
alternating \f[V]MDNode\f[R] and \f[V]ConstantInt\f[R] operands.
With N starting from 1, the 2N - 1 th operand, an \f[V]MDNode\f[R],
denotes a contained field, and the 2N th operand, a
\f[V]ConstantInt\f[R], is the offset of the said contained field.
The offsets must be in non-decreasing order.
.PP
Access tags are represented as \f[V]MDNode\f[R] s with either 3 or 4
operands.
The first operand is an \f[V]MDNode\f[R] pointing to the node
representing the base type.
The second operand is an \f[V]MDNode\f[R] pointing to the node
representing the access type.
The third operand is a \f[V]ConstantInt\f[R] that states the offset of
the access.
If a fourth field is present, it must be a \f[V]ConstantInt\f[R] valued
at 0 or 1.
If it is 1 then the access tag states that the location being accessed
is \[dq]constant\[dq] (meaning \f[V]pointsToConstantMemory\f[R] should
return true; see other useful AliasAnalysis methods).
The TBAA root of the access type and the base type of an access tag must
be the same, and that is the TBAA root of the access tag.
.SS \[aq]\f[V]tbaa.struct\f[R]\[aq] Metadata
.PP
The \f[V]llvm.memcpy <int_memcpy>\f[R] is often used to implement
aggregate assignment operations in C and similar languages, however it
is defined to copy a contiguous region of memory, which is more than
strictly necessary for aggregate types which contain holes due to
padding.
Also, it doesn\[aq]t contain any TBAA information about the fields of
the aggregate.
.PP
\f[V]!tbaa.struct\f[R] metadata can describe which memory subregions in
a memcpy are padding and what the TBAA tags of the struct are.
.PP
The current metadata format is very simple.
\f[V]!tbaa.struct\f[R] metadata nodes are a list of operands which are
in conceptual groups of three.
For each group of three, the first operand gives the byte offset of a
field in bytes, the second gives its size in bytes, and the third gives
its tbaa tag.
e.g.:
.IP
.nf
\f[C]
!4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }
\f[R]
.fi
.PP
This describes a struct with two fields.
The first is at offset 0 bytes with size 4 bytes, and has tbaa tag !1.
The second is at offset 8 bytes and has size 4 bytes and has tbaa tag
!2.
.PP
Note that the fields need not be contiguous.
In this example, there is a 4 byte gap between the two fields.
This gap represents padding which does not carry useful data and need
not be preserved.
.SS \[aq]\f[V]noalias\f[R]\[aq] and \[aq]\f[V]alias.scope\f[R]\[aq] Metadata
.PP
\f[V]noalias\f[R] and \f[V]alias.scope\f[R] metadata provide the ability
to specify generic noalias memory-access sets.
This means that some collection of memory access instructions (loads,
stores, memory-accessing calls, etc.)
that carry \f[V]noalias\f[R] metadata can specifically be specified not
to alias with some other collection of memory access instructions that
carry \f[V]alias.scope\f[R] metadata.
Each type of metadata specifies a list of scopes where each scope has an
id and a domain.
.PP
When evaluating an aliasing query, if for some domain, the set of scopes
with that domain in one instruction\[aq]s \f[V]alias.scope\f[R] list is
a subset of (or equal to) the set of scopes for that domain in another
instruction\[aq]s \f[V]noalias\f[R] list, then the two memory accesses
are assumed not to alias.
.PP
Because scopes in one domain don\[aq]t affect scopes in other domains,
separate domains can be used to compose multiple independent noalias
sets.
This is used for example during inlining.
As the noalias function parameters are turned into noalias scope
metadata, a new domain is used every time the function is inlined.
.PP
The metadata identifying each domain is itself a list containing one or
two entries.
The first entry is the name of the domain.
Note that if the name is a string then it can be combined across
functions and translation units.
A self-reference can be used to create globally unique domain names.
A descriptive string may optionally be provided as a second list entry.
.PP
The metadata identifying each scope is also itself a list containing two
or three entries.
The first entry is the name of the scope.
Note that if the name is a string then it can be combined across
functions and translation units.
A self-reference can be used to create globally unique scope names.
A metadata reference to the scope\[aq]s domain is the second entry.
A descriptive string may optionally be provided as a third list entry.
.PP
For example,
.IP
.nf
\f[C]
; Two scope domains:
!0 = !{!0}
!1 = !{!1}

; Some scopes in these domains:
!2 = !{!2, !0}
!3 = !{!3, !0}
!4 = !{!4, !1}

; Some scope lists:
!5 = !{!4} ; A list containing only scope !4
!6 = !{!4, !3, !2}
!7 = !{!3}

; These two instructions don\[aq]t alias:
%0 = load float, float* %c, align 4, !alias.scope !5
store float %0, float* %arrayidx.i, align 4, !noalias !5

; These two instructions also don\[aq]t alias (for domain !1, the set of scopes
; in the !alias.scope equals that in the !noalias list):
%2 = load float, float* %c, align 4, !alias.scope !5
store float %2, float* %arrayidx.i2, align 4, !noalias !6

; These two instructions may alias (for domain !0, the set of scopes in
; the !noalias list is not a superset of, or equal to, the scopes in the
; !alias.scope list):
%2 = load float, float* %c, align 4, !alias.scope !6
store float %0, float* %arrayidx.i, align 4, !noalias !7
\f[R]
.fi
.SS \[aq]\f[V]fpmath\f[R]\[aq] Metadata
.PP
\f[V]fpmath\f[R] metadata may be attached to any instruction of
floating-point type.
It can be used to express the maximum acceptable error in the result of
that instruction, in ULPs, thus potentially allowing the compiler to use
a more efficient but less accurate method of computing it.
ULP is defined as follows:
.RS
.PP
If \f[V]x\f[R] is a real number that lies between two finite consecutive
floating-point numbers \f[V]a\f[R] and \f[V]b\f[R], without being equal
to one of them, then \f[V]ulp(x) = |b - a|\f[R], otherwise
\f[V]ulp(x)\f[R] is the distance between the two non-equal finite
floating-point numbers nearest \f[V]x\f[R].
Moreover, \f[V]ulp(NaN)\f[R] is \f[V]NaN\f[R].
.RE
.PP
The metadata node shall consist of a single positive float type number
representing the maximum relative error, for example:
.IP
.nf
\f[C]
!0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs
\f[R]
.fi
.SS \[aq]\f[V]range\f[R]\[aq] Metadata
.PP
\f[V]range\f[R] metadata may be attached only to \f[V]load\f[R],
\f[V]call\f[R] and \f[V]invoke\f[R] of integer types.
It expresses the possible ranges the loaded value or the value returned
by the called function at this call site is in.
If the loaded or returned value is not in the specified range, the
behavior is undefined.
The ranges are represented with a flattened list of integers.
The loaded value or the value returned is known to be in the union of
the ranges defined by each consecutive pair.
Each pair has the following properties:
.IP \[bu] 2
The type must match the type loaded by the instruction.
.IP \[bu] 2
The pair \f[V]a,b\f[R] represents the range \f[V][a,b)\f[R].
.IP \[bu] 2
Both \f[V]a\f[R] and \f[V]b\f[R] are constants.
.IP \[bu] 2
The range is allowed to wrap.
.IP \[bu] 2
The range should not represent the full or empty set.
That is, \f[V]a!=b\f[R].
.PP
In addition, the pairs must be in signed order of the lower bound and
they must be non-contiguous.
.PP
Examples:
.IP
.nf
\f[C]
%a = load i8, i8* %x, align 1, !range !0 ; Can only be 0 or 1
%b = load i8, i8* %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1
%c = call i8 \[at]foo(),       !range !2 ; Can only be 0, 1, 3, 4 or 5
%d = invoke i8 \[at]bar() to label %cont
       unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5
\&...
!0 = !{ i8 0, i8 2 }
!1 = !{ i8 255, i8 2 }
!2 = !{ i8 0, i8 2, i8 3, i8 6 }
!3 = !{ i8 -2, i8 0, i8 3, i8 6 }
\f[R]
.fi
.SS \[aq]\f[V]absolute_symbol\f[R]\[aq] Metadata
.PP
\f[V]absolute_symbol\f[R] metadata may be attached to a global variable
declaration.
It marks the declaration as a reference to an absolute symbol, which
causes the backend to use absolute relocations for the symbol even in
position independent code, and expresses the possible ranges that the
global variable\[aq]s \f[I]address\f[R] (not its value) is in, in the
same format as \f[V]range\f[R] metadata, with the extension that the
pair \f[V]all-ones,all-ones\f[R] may be used to represent the full set.
.PP
Example (assuming 64-bit pointers):
.IP
.nf
\f[C]
\[at]a = external global i8, !absolute_symbol !0 ; Absolute symbol in range [0,256)
\[at]b = external global i8, !absolute_symbol !1 ; Absolute symbol in range [0,2\[ha]64)

\&...
!0 = !{ i64 0, i64 256 }
!1 = !{ i64 -1, i64 -1 }
\f[R]
.fi
.SS \[aq]\f[V]callees\f[R]\[aq] Metadata
.PP
\f[V]callees\f[R] metadata may be attached to indirect call sites.
If \f[V]callees\f[R] metadata is attached to a call site, and any callee
is not among the set of functions provided by the metadata, the behavior
is undefined.
The intent of this metadata is to facilitate optimizations such as
indirect-call promotion.
For example, in the code below, the call instruction may only target the
\f[V]add\f[R] or \f[V]sub\f[R] functions:
.IP
.nf
\f[C]
%result = call i64 %binop(i64 %x, i64 %y), !callees !0

\&...
!0 = !{i64 (i64, i64)* \[at]add, i64 (i64, i64)* \[at]sub}
\f[R]
.fi
.SS \[aq]\f[V]callback\f[R]\[aq] Metadata
.PP
\f[V]callback\f[R] metadata may be attached to a function declaration,
or definition.
(Call sites are excluded only due to the lack of a use case.)
For ease of exposition, we\[aq]ll refer to the function annotated w/
metadata as a broker function.
The metadata describes how the arguments of a call to the broker are in
turn passed to the callback function specified by the metadata.
Thus, the \f[V]callback\f[R] metadata provides a partial description of
a call site inside the broker function with regards to the arguments of
a call to the broker.
The only semantic restriction on the broker function itself is that it
is not allowed to inspect or modify arguments referenced in the
\f[V]callback\f[R] metadata as pass-through to the callback function.
.PP
The broker is not required to actually invoke the callback function at
runtime.
However, the assumptions about not inspecting or modifying arguments
that would be passed to the specified callback function still hold, even
if the callback function is not dynamically invoked.
The broker is allowed to invoke the callback function more than once per
invocation of the broker.
The broker is also allowed to invoke (directly or indirectly) the
function passed as a callback through another use.
Finally, the broker is also allowed to relay the callback callee
invocation to a different thread.
.PP
The metadata is structured as follows: At the outer level,
\f[V]callback\f[R] metadata is a list of \f[V]callback\f[R] encodings.
Each encoding starts with a constant \f[V]i64\f[R] which describes the
argument position of the callback function in the call to the broker.
The following elements, except the last, describe what arguments are
passed to the callback function.
Each element is again an \f[V]i64\f[R] constant identifying the argument
of the broker that is passed through, or \f[V]i64 -1\f[R] to indicate an
unknown or inspected argument.
The order in which they are listed has to be the same in which they are
passed to the callback callee.
The last element of the encoding is a boolean which specifies how
variadic arguments of the broker are handled.
If it is true, all variadic arguments of the broker are passed through
to the callback function \f[I]after\f[R] the arguments encoded
explicitly before.
.PP
In the code below, the \f[V]pthread_create\f[R] function is marked as a
broker through the \f[V]!callback !1\f[R] metadata.
In the example, there is only one callback encoding, namely
\f[V]!2\f[R], associated with the broker.
This encoding identifies the callback function as the second argument of
the broker (\f[V]i64 2\f[R]) and the sole argument of the callback
function as the third one of the broker function (\f[V]i64 3\f[R]).
.IP
.nf
\f[C]
declare !callback !1 dso_local i32 \[at]pthread_create(i64*, %union.pthread_attr_t*, i8* (i8*)*, i8*)

\&...
!2 = !{i64 2, i64 3, i1 false}
!1 = !{!2}
\f[R]
.fi
.PP
Another example is shown below.
The callback callee is the second argument of the
\f[V]__kmpc_fork_call\f[R] function (\f[V]i64 2\f[R]).
The callee is given two unknown values (each identified by a
\f[V]i64 -1\f[R]) and afterwards all variadic arguments that are passed
to the \f[V]__kmpc_fork_call\f[R] call (due to the final
\f[V]i1 true\f[R]).
.IP
.nf
\f[C]
declare !callback !0 dso_local void \[at]__kmpc_fork_call(%struct.ident_t*, i32, void (i32*, i32*, ...)*, ...)

\&...
!1 = !{i64 2, i64 -1, i64 -1, i1 true}
!0 = !{!1}
\f[R]
.fi
.SS \[aq]\f[V]exclude\f[R]\[aq] Metadata
.PP
\f[V]exclude\f[R] metadata may be attached to a global variable to
signify that its section should not be included in the final executable
or shared library.
This option is only valid for global variables with an explicit section
targeting ELF or COFF.
This is done using the \f[V]SHF_EXCLUDE\f[R] flag on ELF targets and the
\f[V]IMAGE_SCN_LNK_REMOVE\f[R] and \f[V]IMAGE_SCN_MEM_DISCARDABLE\f[R]
flags for COFF targets.
Additionally, this metadata is only used as a flag, so the associated
node must be empty.
The explicit section should not conflict with any other sections that
the user does not want removed after linking.
.IP
.nf
\f[C]
\[at]object = private constant [1 x i8] c\[dq]\[rs]00\[dq], section \[dq].foo\[dq] !exclude !0

\&...
!0 = !{}
\f[R]
.fi
.SS \[aq]\f[V]unpredictable\f[R]\[aq] Metadata
.PP
\f[V]unpredictable\f[R] metadata may be attached to any branch or switch
instruction.
It can be used to express the unpredictability of control flow.
Similar to the llvm.expect intrinsic, it may be used to alter
optimizations related to compare and branch instructions.
The metadata is treated as a boolean value; if it exists, it signals
that the branch or switch that it is attached to is completely
unpredictable.
.SS \[aq]\f[V]dereferenceable\f[R]\[aq] Metadata
.PP
The existence of the \f[V]!dereferenceable\f[R] metadata on the
instruction tells the optimizer that the value loaded is known to be
dereferenceable.
The number of bytes known to be dereferenceable is specified by the
integer value in the metadata node.
This is analogous to the \[aq]\[aq]dereferenceable\[aq]\[aq] attribute
on parameters and return values.
.SS \[aq]\f[V]dereferenceable_or_null\f[R]\[aq] Metadata
.PP
The existence of the \f[V]!dereferenceable_or_null\f[R] metadata on the
instruction tells the optimizer that the value loaded is known to be
either dereferenceable or null.
The number of bytes known to be dereferenceable is specified by the
integer value in the metadata node.
This is analogous to the \[aq]\[aq]dereferenceable_or_null\[aq]\[aq]
attribute on parameters and return values.
.SS \[aq]\f[V]llvm.loop\f[R]\[aq]
.PP
It is sometimes useful to attach information to loop constructs.
Currently, loop metadata is implemented as metadata attached to the
branch instruction in the loop latch block.
The loop metadata node is a list of other metadata nodes, each
representing a property of the loop.
Usually, the first item of the property node is a string.
For example, the \f[V]llvm.loop.unroll.count\f[R] suggests an unroll
factor to the loop unroller:
.IP
.nf
\f[C]
br i1 %exitcond, label %._crit_edge, label %.lr.ph, !llvm.loop !0
\&...
!0 = !{!0, !1, !2}
!1 = !{!\[dq]llvm.loop.unroll.enable\[dq]}
!2 = !{!\[dq]llvm.loop.unroll.count\[dq], i32 4}
\f[R]
.fi
.PP
For legacy reasons, the first item of a loop metadata node must be a
reference to itself.
Before the advent of the \[aq]distinct\[aq] keyword, this forced the
preservation of otherwise identical metadata nodes.
Since the loop-metadata node can be attached to multiple nodes, the
\[aq]distinct\[aq] keyword has become unnecessary.
.PP
Prior to the property nodes, one or two \f[V]DILocation\f[R] (debug
location) nodes can be present in the list.
The first, if present, identifies the source-code location where the
loop begins.
The second, if present, identifies the source-code location where the
loop ends.
.PP
Loop metadata nodes cannot be used as unique identifiers.
They are neither persistent for the same loop through transformations
nor necessarily unique to just one loop.
.SS \[aq]\f[V]llvm.loop.disable_nonforced\f[R]\[aq]
.PP
This metadata disables all optional loop transformations unless
explicitly instructed using other transformation metadata such as
\f[V]llvm.loop.unroll.enable\f[R].
That is, no heuristic will try to determine whether a transformation is
profitable.
The purpose is to avoid that the loop is transformed to a different loop
before an explicitly requested (forced) transformation is applied.
For instance, loop fusion can make other transformations impossible.
Mandatory loop canonicalizations such as loop rotation are still
applied.
.PP
It is recommended to use this metadata in addition to any llvm.loop.*
transformation directive.
Also, any loop should have at most one directive applied to it (and a
sequence of transformations built using followup-attributes).
Otherwise, which transformation will be applied depends on
implementation details such as the pass pipeline order.
.PP
See \f[V]transformation-metadata\f[R] for details.
.SS \[aq]\f[V]llvm.loop.vectorize\f[R]\[aq] and \[aq]\f[V]llvm.loop.interleave\f[R]\[aq]
.PP
Metadata prefixed with \f[V]llvm.loop.vectorize\f[R] or
\f[V]llvm.loop.interleave\f[R] are used to control per-loop
vectorization and interleaving parameters such as vectorization width
and interleave count.
These metadata should be used in conjunction with \f[V]llvm.loop\f[R]
loop identification metadata.
The \f[V]llvm.loop.vectorize\f[R] and \f[V]llvm.loop.interleave\f[R]
metadata are only optimization hints and the optimizer will only
interleave and vectorize loops if it believes it is safe to do so.
The \f[V]llvm.loop.parallel_accesses\f[R] metadata which contains
information about loop-carried memory dependencies can be helpful in
determining the safety of these transformations.
.SS \[aq]\f[V]llvm.loop.interleave.count\f[R]\[aq] Metadata
.PP
This metadata suggests an interleave count to the loop interleaver.
The first operand is the string \f[V]llvm.loop.interleave.count\f[R] and
the second operand is an integer specifying the interleave count.
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.interleave.count\[dq], i32 4}
\f[R]
.fi
.PP
Note that setting \f[V]llvm.loop.interleave.count\f[R] to 1 disables
interleaving multiple iterations of the loop.
If \f[V]llvm.loop.interleave.count\f[R] is set to 0 then the interleave
count will be determined automatically.
.SS \[aq]\f[V]llvm.loop.vectorize.enable\f[R]\[aq] Metadata
.PP
This metadata selectively enables or disables vectorization for the
loop.
The first operand is the string \f[V]llvm.loop.vectorize.enable\f[R] and
the second operand is a bit.
If the bit operand value is 1 vectorization is enabled.
A value of 0 disables vectorization:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.vectorize.enable\[dq], i1 0}
!1 = !{!\[dq]llvm.loop.vectorize.enable\[dq], i1 1}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.vectorize.predicate.enable\f[R]\[aq] Metadata
.PP
This metadata selectively enables or disables creating predicated
instructions for the loop, which can enable folding of the scalar
epilogue loop into the main loop.
The first operand is the string
\f[V]llvm.loop.vectorize.predicate.enable\f[R] and the second operand is
a bit.
If the bit operand value is 1 vectorization is enabled.
A value of 0 disables vectorization:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.vectorize.predicate.enable\[dq], i1 0}
!1 = !{!\[dq]llvm.loop.vectorize.predicate.enable\[dq], i1 1}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.vectorize.scalable.enable\f[R]\[aq] Metadata
.PP
This metadata selectively enables or disables scalable vectorization for
the loop, and only has any effect if vectorization for the loop is
already enabled.
The first operand is the string
\f[V]llvm.loop.vectorize.scalable.enable\f[R] and the second operand is
a bit.
If the bit operand value is 1 scalable vectorization is enabled, whereas
a value of 0 reverts to the default fixed width vectorization:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.vectorize.scalable.enable\[dq], i1 0}
!1 = !{!\[dq]llvm.loop.vectorize.scalable.enable\[dq], i1 1}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.vectorize.width\f[R]\[aq] Metadata
.PP
This metadata sets the target width of the vectorizer.
The first operand is the string \f[V]llvm.loop.vectorize.width\f[R] and
the second operand is an integer specifying the width.
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.vectorize.width\[dq], i32 4}
\f[R]
.fi
.PP
Note that setting \f[V]llvm.loop.vectorize.width\f[R] to 1 disables
vectorization of the loop.
If \f[V]llvm.loop.vectorize.width\f[R] is set to 0 or if the loop does
not have this metadata the width will be determined automatically.
.SS \[aq]\f[V]llvm.loop.vectorize.followup_vectorized\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the vectorized loop will
have.
See \f[V]transformation-metadata\f[R] for details.
.SS \[aq]\f[V]llvm.loop.vectorize.followup_epilogue\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the epilogue will have.
The epilogue is not vectorized and is executed when either the
vectorized loop is not known to preserve semantics (because e.g., it
processes two arrays that are found to alias by a runtime check) or for
the last iterations that do not fill a complete set of vector lanes.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.vectorize.followup_all\f[R]\[aq] Metadata
.PP
Attributes in the metadata will be added to both the vectorized and
epilogue loop.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll\f[R]\[aq]
.PP
Metadata prefixed with \f[V]llvm.loop.unroll\f[R] are loop unrolling
optimization hints such as the unroll factor.
\f[V]llvm.loop.unroll\f[R] metadata should be used in conjunction with
\f[V]llvm.loop\f[R] loop identification metadata.
The \f[V]llvm.loop.unroll\f[R] metadata are only optimization hints and
the unrolling will only be performed if the optimizer believes it is
safe to do so.
.SS \[aq]\f[V]llvm.loop.unroll.count\f[R]\[aq] Metadata
.PP
This metadata suggests an unroll factor to the loop unroller.
The first operand is the string \f[V]llvm.loop.unroll.count\f[R] and the
second operand is a positive integer specifying the unroll factor.
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll.count\[dq], i32 4}
\f[R]
.fi
.PP
If the trip count of the loop is less than the unroll count the loop
will be partially unrolled.
.SS \[aq]\f[V]llvm.loop.unroll.disable\f[R]\[aq] Metadata
.PP
This metadata disables loop unrolling.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll.disable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll.disable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll.runtime.disable\f[R]\[aq] Metadata
.PP
This metadata disables runtime loop unrolling.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll.runtime.disable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll.runtime.disable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll.enable\f[R]\[aq] Metadata
.PP
This metadata suggests that the loop should be fully unrolled if the
trip count is known at compile time and partially unrolled if the trip
count is not known at compile time.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll.enable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll.enable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll.full\f[R]\[aq] Metadata
.PP
This metadata suggests that the loop should be unrolled fully.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll.full\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll.full\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll.followup\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the unrolled loop will have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll.followup_remainder\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the remainder loop after
partial/runtime unrolling will have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam\f[R]\[aq]
.PP
This metadata is treated very similarly to the
\f[V]llvm.loop.unroll\f[R] metadata above, but affect the unroll and jam
pass.
In addition any loop with \f[V]llvm.loop.unroll\f[R] metadata but no
\f[V]llvm.loop.unroll_and_jam\f[R] metadata will disable unroll and jam
(so \f[V]llvm.loop.unroll\f[R] metadata will be left to the unroller,
plus \f[V]llvm.loop.unroll.disable\f[R] metadata will disable unroll and
jam too.)
.PP
The metadata for unroll and jam otherwise is the same as for
\f[V]unroll\f[R].
\f[V]llvm.loop.unroll_and_jam.enable\f[R],
\f[V]llvm.loop.unroll_and_jam.disable\f[R] and
\f[V]llvm.loop.unroll_and_jam.count\f[R] do the same as for unroll.
\f[V]llvm.loop.unroll_and_jam.full\f[R] is not supported.
Again these are only hints and the normal safety checks will still be
performed.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.count\f[R]\[aq] Metadata
.PP
This metadata suggests an unroll and jam factor to use, similarly to
\f[V]llvm.loop.unroll.count\f[R].
The first operand is the string \f[V]llvm.loop.unroll_and_jam.count\f[R]
and the second operand is a positive integer specifying the unroll
factor.
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll_and_jam.count\[dq], i32 4}
\f[R]
.fi
.PP
If the trip count of the loop is less than the unroll count the loop
will be partially unroll and jammed.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.disable\f[R]\[aq] Metadata
.PP
This metadata disables loop unroll and jamming.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll_and_jam.disable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll_and_jam.disable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.enable\f[R]\[aq] Metadata
.PP
This metadata suggests that the loop should be fully unroll and jammed
if the trip count is known at compile time and partially unrolled if the
trip count is not known at compile time.
The metadata has a single operand which is the string
\f[V]llvm.loop.unroll_and_jam.enable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.unroll_and_jam.enable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.followup_outer\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the outer unrolled loop will
have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.followup_inner\f[R]\[aq] Metadata
.PP
This metadata defines which loop attributes the inner jammed loop will
have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.followup_remainder_outer\f[R]\[aq] Metadata
.PP
This metadata defines which attributes the epilogue of the outer loop
will have.
This loop is usually unrolled, meaning there is no such loop.
This attribute will be ignored in this case.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.followup_remainder_inner\f[R]\[aq] Metadata
.PP
This metadata defines which attributes the inner loop of the epilogue
will have.
The outer epilogue will usually be unrolled, meaning there can be
multiple inner remainder loops.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.unroll_and_jam.followup_all\f[R]\[aq] Metadata
.PP
Attributes specified in the metadata is added to all
\f[V]llvm.loop.unroll_and_jam.*\f[R] loops.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.licm_versioning.disable\f[R]\[aq] Metadata
.PP
This metadata indicates that the loop should not be versioned for the
purpose of enabling loop-invariant code motion (LICM).
The metadata has a single operand which is the string
\f[V]llvm.loop.licm_versioning.disable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.licm_versioning.disable\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.distribute.enable\f[R]\[aq] Metadata
.PP
Loop distribution allows splitting a loop into multiple loops.
Currently, this is only performed if the entire loop cannot be
vectorized due to unsafe memory dependencies.
The transformation will attempt to isolate the unsafe dependencies into
their own loop.
.PP
This metadata can be used to selectively enable or disable distribution
of the loop.
The first operand is the string \f[V]llvm.loop.distribute.enable\f[R]
and the second operand is a bit.
If the bit operand value is 1 distribution is enabled.
A value of 0 disables distribution:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.loop.distribute.enable\[dq], i1 0}
!1 = !{!\[dq]llvm.loop.distribute.enable\[dq], i1 1}
\f[R]
.fi
.PP
This metadata should be used in conjunction with \f[V]llvm.loop\f[R]
loop identification metadata.
.SS \[aq]\f[V]llvm.loop.distribute.followup_coincident\f[R]\[aq] Metadata
.PP
This metadata defines which attributes extracted loops with no cyclic
dependencies will have (i.e.
can be vectorized).
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.distribute.followup_sequential\f[R]\[aq] Metadata
.PP
This metadata defines which attributes the isolated loops with unsafe
memory dependencies will have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.distribute.followup_fallback\f[R]\[aq] Metadata
.PP
If loop versioning is necessary, this metadata defined the attributes
the non-distributed fallback version will have.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.loop.distribute.followup_all\f[R]\[aq] Metadata
.PP
The attributes in this metadata is added to all followup loops of the
loop distribution pass.
See \f[V]Transformation Metadata <transformation-metadata>\f[R] for
details.
.SS \[aq]\f[V]llvm.licm.disable\f[R]\[aq] Metadata
.PP
This metadata indicates that loop-invariant code motion (LICM) should
not be performed on this loop.
The metadata has a single operand which is the string
\f[V]llvm.licm.disable\f[R].
For example:
.IP
.nf
\f[C]
!0 = !{!\[dq]llvm.licm.disable\[dq]}
\f[R]
.fi
.PP
Note that although it operates per loop it isn\[aq]t given the llvm.loop
prefix as it is not affected by the
\f[V]llvm.loop.disable_nonforced\f[R] metadata.
.SS \[aq]\f[V]llvm.access.group\f[R]\[aq] Metadata
.PP
\f[V]llvm.access.group\f[R] metadata can be attached to any instruction
that potentially accesses memory.
It can point to a single distinct metadata node, which we call access
group.
This node represents all memory access instructions referring to it via
\f[V]llvm.access.group\f[R].
When an instruction belongs to multiple access groups, it can also point
to a list of accesses groups, illustrated by the following example.
.IP
.nf
\f[C]
%val = load i32, i32* %arrayidx, !llvm.access.group !0
\&...
!0 = !{!1, !2}
!1 = distinct !{}
!2 = distinct !{}
\f[R]
.fi
.PP
It is illegal for the list node to be empty since it might be confused
with an access group.
.PP
The access group metadata node must be \[aq]distinct\[aq] to avoid
collapsing multiple access groups by content.
A access group metadata node must always be empty which can be used to
distinguish an access group metadata node from a list of access groups.
Being empty avoids the situation that the content must be updated which,
because metadata is immutable by design, would required finding and
updating all references to the access group node.
.PP
The access group can be used to refer to a memory access instruction
without pointing to it directly (which is not possible in global
metadata).
Currently, the only metadata making use of it is
\f[V]llvm.loop.parallel_accesses\f[R].
.SS \[aq]\f[V]llvm.loop.parallel_accesses\f[R]\[aq] Metadata
.PP
The \f[V]llvm.loop.parallel_accesses\f[R] metadata refers to one or more
access group metadata nodes (see \f[V]llvm.access.group\f[R]).
It denotes that no loop-carried memory dependence exist between it and
other instructions in the loop with this metadata.
.PP
Let \f[V]m1\f[R] and \f[V]m2\f[R] be two instructions that both have the
\f[V]llvm.access.group\f[R] metadata to the access group \f[V]g1\f[R],
respectively \f[V]g2\f[R] (which might be identical).
If a loop contains both access groups in its
\f[V]llvm.loop.parallel_accesses\f[R] metadata, then the compiler can
assume that there is no dependency between \f[V]m1\f[R] and \f[V]m2\f[R]
carried by this loop.
Instructions that belong to multiple access groups are considered having
this property if at least one of the access groups matches the
\f[V]llvm.loop.parallel_accesses\f[R] list.
.PP
If all memory-accessing instructions in a loop have
\f[V]llvm.access.group\f[R] metadata that each refer to one of the
access groups of a loop\[aq]s \f[V]llvm.loop.parallel_accesses\f[R]
metadata, then the loop has no loop carried memory dependences and is
considered to be a parallel loop.
.PP
Note that if not all memory access instructions belong to an access
group referred to by \f[V]llvm.loop.parallel_accesses\f[R], then the
loop must not be considered trivially parallel.
Additional memory dependence analysis is required to make that
determination.
As a fail safe mechanism, this causes loops that were originally
parallel to be considered sequential (if optimization passes that are
unaware of the parallel semantics insert new memory instructions into
the loop body).
.PP
Example of a loop that is considered parallel due to its correct use of
both \f[V]llvm.access.group\f[R] and
\f[V]llvm.loop.parallel_accesses\f[R] metadata types.
.IP
.nf
\f[C]
for.body:
  ...
  %val0 = load i32, i32* %arrayidx, !llvm.access.group !1
  ...
  store i32 %val0, i32* %arrayidx1, !llvm.access.group !1
  ...
  br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0

for.end:
\&...
!0 = distinct !{!0, !{!\[dq]llvm.loop.parallel_accesses\[dq], !1}}
!1 = distinct !{}
\f[R]
.fi
.PP
It is also possible to have nested parallel loops:
.IP
.nf
\f[C]
outer.for.body:
  ...
  %val1 = load i32, i32* %arrayidx3, !llvm.access.group !4
  ...
  br label %inner.for.body

inner.for.body:
  ...
  %val0 = load i32, i32* %arrayidx1, !llvm.access.group !3
  ...
  store i32 %val0, i32* %arrayidx2, !llvm.access.group !3
  ...
  br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1

inner.for.end:
  ...
  store i32 %val1, i32* %arrayidx4, !llvm.access.group !4
  ...
  br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2

outer.for.end:                                          ; preds = %for.body
\&...
!1 = distinct !{!1, !{!\[dq]llvm.loop.parallel_accesses\[dq], !3}}     ; metadata for the inner loop
!2 = distinct !{!2, !{!\[dq]llvm.loop.parallel_accesses\[dq], !3, !4}} ; metadata for the outer loop
!3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well)
!4 = distinct !{} ; access group for instructions in the outer, but not the inner loop
\f[R]
.fi
.SS \[aq]\f[V]llvm.loop.mustprogress\f[R]\[aq] Metadata
.PP
The \f[V]llvm.loop.mustprogress\f[R] metadata indicates that this loop
is required to terminate, unwind, or interact with the environment in an
observable way e.g.
via a volatile memory access, I/O, or other synchronization.
If such a loop is not found to interact with the environment in an
observable way, the loop may be removed.
This corresponds to the \f[V]mustprogress\f[R] function attribute.
.SS \[aq]\f[V]irr_loop\f[R]\[aq] Metadata
.PP
\f[V]irr_loop\f[R] metadata may be attached to the terminator
instruction of a basic block that\[aq]s an irreducible loop header (note
that an irreducible loop has more than once header basic blocks.)
If \f[V]irr_loop\f[R] metadata is attached to the terminator instruction
of a basic block that is not really an irreducible loop header, the
behavior is undefined.
The intent of this metadata is to improve the accuracy of the block
frequency propagation.
For example, in the code below, the block \f[V]header0\f[R] may have a
loop header weight (relative to the other headers of the irreducible
loop) of 100:
.IP
.nf
\f[C]
header0:
\&...
br i1 %cmp, label %t1, label %t2, !irr_loop !0

\&...
!0 = !{\[dq]loop_header_weight\[dq], i64 100}
\f[R]
.fi
.PP
Irreducible loop header weights are typically based on profile data.
.SS \[aq]\f[V]invariant.group\f[R]\[aq] Metadata
.PP
The experimental \f[V]invariant.group\f[R] metadata may be attached to
\f[V]load\f[R]/\f[V]store\f[R] instructions referencing a single
metadata with no entries.
The existence of the \f[V]invariant.group\f[R] metadata on the
instruction tells the optimizer that every \f[V]load\f[R] and
\f[V]store\f[R] to the same pointer operand can be assumed to load or
store the same value (but see the \f[V]llvm.launder.invariant.group\f[R]
intrinsic which affects when two pointers are considered the same).
Pointers returned by bitcast or getelementptr with only zero indices are
considered the same.
.PP
Examples:
.IP
.nf
\f[C]
\[at]unknownPtr = external global i8
\&...
%ptr = alloca i8
store i8 42, i8* %ptr, !invariant.group !0
call void \[at]foo(i8* %ptr)

%a = load i8, i8* %ptr, !invariant.group !0 ; Can assume that value under %ptr didn\[aq]t change
call void \[at]foo(i8* %ptr)

%newPtr = call i8* \[at]getPointer(i8* %ptr)
%c = load i8, i8* %newPtr, !invariant.group !0 ; Can\[aq]t assume anything, because we only have information about %ptr

%unknownValue = load i8, i8* \[at]unknownPtr
store i8 %unknownValue, i8* %ptr, !invariant.group !0 ; Can assume that %unknownValue == 42

call void \[at]foo(i8* %ptr)
%newPtr2 = call i8* \[at]llvm.launder.invariant.group(i8* %ptr)
%d = load i8, i8* %newPtr2, !invariant.group !0  ; Can\[aq]t step through launder.invariant.group to get value of %ptr

\&...
declare void \[at]foo(i8*)
declare i8* \[at]getPointer(i8*)
declare i8* \[at]llvm.launder.invariant.group(i8*)

!0 = !{}
\f[R]
.fi
.PP
The invariant.group metadata must be dropped when replacing one pointer
by another based on aliasing information.
This is because invariant.group is tied to the SSA value of the pointer
operand.
.IP
.nf
\f[C]
%v = load i8, i8* %x, !invariant.group !0
; if %x mustalias %y then we can replace the above instruction with
%v = load i8, i8* %y
\f[R]
.fi
.PP
Note that this is an experimental feature, which means that its
semantics might change in the future.
.SS \[aq]\f[V]type\f[R]\[aq] Metadata
.PP
See \f[V]TypeMetadata\f[R].
.SS \[aq]\f[V]associated\f[R]\[aq] Metadata
.PP
The \f[V]associated\f[R] metadata may be attached to a global variable
definition with a single argument that references a global object
(optionally through an alias).
.PP
This metadata lowers to the ELF section flag \f[V]SHF_LINK_ORDER\f[R]
which prevents discarding of the global variable in linker GC unless the
referenced object is also discarded.
The linker support for this feature is spotty.
For best compatibility, globals carrying this metadata should:
.IP \[bu] 2
Be in \f[V]\[at]llvm.compiler.used\f[R].
.IP \[bu] 2
If the referenced global variable is in a comdat, be in the same comdat.
.PP
\f[V]!associated\f[R] can not express many-to-one relationship.
A global variable with the metadata should generally not be referenced
by a function: the function may be inlined into other functions, leading
to more references to the metadata.
Ideally we would want to keep metadata alive as long as any inline
location is alive, but this many-to-one relationship is not
representable.
Moreover, if the metadata is retained while the function is discarded,
the linker will report an error of a relocation referencing a discarded
section.
.PP
The metadata is often used with an explicit section consisting of valid
C identifiers so that the runtime can find the metadata section with
linker-defined encapsulation symbols \f[V]__start_<section_name>\f[R]
and \f[V]__stop_<section_name>\f[R].
.PP
It does not have any effect on non-ELF targets.
.PP
Example:
.IP
.nf
\f[C]
$a = comdat any
\[at]a = global i32 1, comdat $a
\[at]b = internal global i32 2, comdat $a, section \[dq]abc\[dq], !associated !0
!0 = !{i32* \[at]a}
\f[R]
.fi
.SS \[aq]\f[V]prof\f[R]\[aq] Metadata
.PP
The \f[V]prof\f[R] metadata is used to record profile data in the IR.
The first operand of the metadata node indicates the profile metadata
type.
There are currently 3 types:
\f[V]branch_weights<prof_node_branch_weights>\f[R],
\f[V]function_entry_count<prof_node_function_entry_count>\f[R], and
\f[V]VP<prof_node_VP>\f[R].
.SS branch_weights
.PP
Branch weight metadata attached to a branch, select, switch or call
instruction represents the likeliness of the associated branch being
taken.
For more information, see \f[V]BranchWeightMetadata\f[R].
.SS function_entry_count
.PP
Function entry count metadata can be attached to function definitions to
record the number of times the function is called.
Used with BFI information, it is also used to derive the basic block
profile count.
For more information, see \f[V]BranchWeightMetadata\f[R].
.SS VP
.PP
VP (value profile) metadata can be attached to instructions that have
value profile information.
Currently this is indirect calls (where it records the hottest callees)
and calls to memory intrinsics such as memcpy, memmove, and memset
(where it records the hottest byte lengths).
.PP
Each VP metadata node contains \[dq]VP\[dq] string, then a uint32_t
value for the value profiling kind, a uint64_t value for the total
number of times the instruction is executed, followed by uint64_t value
and execution count pairs.
The value profiling kind is 0 for indirect call targets and 1 for memory
operations.
For indirect call targets, each profile value is a hash of the callee
function name, and for memory operations each value is the byte length.
.PP
Note that the value counts do not need to add up to the total count
listed in the third operand (in practice only the top hottest values are
tracked and reported).
.PP
Indirect call example:
.IP
.nf
\f[C]
call void %f(), !prof !1
!1 = !{!\[dq]VP\[dq], i32 0, i64 1600, i64 7651369219802541373, i64 1030, i64 -4377547752858689819, i64 410}
\f[R]
.fi
.PP
Note that the VP type is 0 (the second operand), which indicates this is
an indirect call value profile data.
The third operand indicates that the indirect call executed 1600 times.
The 4th and 6th operands give the hashes of the 2 hottest target
functions\[aq] names (this is the same hash used to represent function
names in the profile database), and the 5th and 7th operands give the
execution count that each of the respective prior target functions was
called.
.SS \[aq]\f[V]annotation\f[R]\[aq] Metadata
.PP
The \f[V]annotation\f[R] metadata can be used to attach a tuple of
annotation strings to any instruction.
This metadata does not impact the semantics of the program and may only
be used to provide additional insight about the program and
transformations to users.
.PP
Example:
.IP
.nf
\f[C]
%a.addr = alloca float*, align 8, !annotation !0
!0 = !{!\[dq]auto-init\[dq]}
\f[R]
.fi
.SS \[aq]\f[V]func_sanitize\f[R]\[aq] Metadata
.PP
The \f[V]func_sanitize\f[R] metadata is used to attach two values for
the function sanitizer instrumentation.
The first value is the ubsan function signature.
The second value is the address of the proxy variable which stores the
address of the RTTI descriptor.
If \f[V]prologue <prologuedata>\f[R] and
\[aq]\f[V]func_sanitize\f[R]\[aq] are used at the same time,
\f[V]prologue <prologuedata>\f[R] is emitted before
\[aq]\f[V]func_sanitize\f[R]\[aq] in the output.
.PP
Example:
.IP
.nf
\f[C]
\[at]__llvm_rtti_proxy = private unnamed_addr constant i8* bitcast ({ i8*, i8* }* \[at]_ZTIFvvE to i8*)
define void \[at]_Z3funv() !func_sanitize !0 {
  return void
}
!0 = !{i32 846595819, i8** \[at]__llvm_rtti_proxy}
\f[R]
.fi
.SH Module Flags Metadata
.PP
Information about the module as a whole is difficult to convey to
LLVM\[aq]s subsystems.
The LLVM IR isn\[aq]t sufficient to transmit this information.
The \f[V]llvm.module.flags\f[R] named metadata exists in order to
facilitate this.
These flags are in the form of key / value pairs --- much like a
dictionary --- making it easy for any subsystem who cares about a flag
to look it up.
.PP
The \f[V]llvm.module.flags\f[R] metadata contains a list of metadata
triplets.
Each triplet has the following form:
.IP \[bu] 2
The first element is a \f[I]behavior\f[R] flag, which specifies the
behavior when two (or more) modules are merged together, and it
encounters two (or more) metadata with the same ID.
The supported behaviors are described below.
.IP \[bu] 2
The second element is a metadata string that is a unique ID for the
metadata.
Each module may only have one flag entry for each unique ID (not
including entries with the \f[B]Require\f[R] behavior).
.IP \[bu] 2
The third element is the value of the flag.
.PP
When two (or more) modules are merged together, the resulting
\f[V]llvm.module.flags\f[R] metadata is the union of the modules\[aq]
flags.
That is, for each unique metadata ID string, there will be exactly one
entry in the merged modules \f[V]llvm.module.flags\f[R] metadata table,
and the value for that entry will be determined by the merge behavior
flag, as described below.
The only exception is that entries with the \f[I]Require\f[R] behavior
are always preserved.
.PP
The following behaviors are supported:
.PP
.TS
tab(@);
lw(7.0n) lw(63.0n).
T{
Value
T}@T{
Behavior
T}
_
T{
1
T}@T{
.TP
\f[B]Error\f[R]
Emits an error if two values disagree, otherwise the resulting value is
that of the operands.
T}
T{
2
T}@T{
.TP
\f[B]Warning\f[R]
Emits a warning if two values disagree.
The result value will be the operand for the flag from the first module
being linked, or the max if the other module uses \f[B]Max\f[R] (in
which case the resulting flag will be \f[B]Max\f[R]).
T}
T{
3
T}@T{
.TP
\f[B]Require\f[R]
Adds a requirement that another module flag be present and have a
specified value after linking is performed.
The value must be a metadata pair, where the first element of the pair
is the ID of the module flag to be restricted, and the second element of
the pair is the value the module flag should be restricted to.
This behavior can be used to restrict the allowable results (via
triggering of an error) of linking IDs with the \f[B]Override\f[R]
behavior.
T}
T{
4
T}@T{
.TP
\f[B]Override\f[R]
Uses the specified value, regardless of the behavior or value of the
other module.
If both modules specify \f[B]Override\f[R], but the values differ, an
error will be emitted.
T}
T{
5
T}@T{
.TP
\f[B]Append\f[R]
Appends the two values, which are required to be metadata nodes.
T}
T{
6
T}@T{
.TP
\f[B]AppendUnique\f[R]
Appends the two values, which are required to be metadata nodes.
However, duplicate entries in the second list are dropped during the
append operation.
T}
T{
7
T}@T{
.TP
\f[B]Max\f[R]
Takes the max of the two values, which are required to be integers.
T}
.TE
.PP
It is an error for a particular unique flag ID to have multiple
behaviors, except in the case of \f[B]Require\f[R] (which adds
restrictions on another metadata value) or \f[B]Override\f[R].
.PP
An example of module flags:
.IP
.nf
\f[C]
!0 = !{ i32 1, !\[dq]foo\[dq], i32 1 }
!1 = !{ i32 4, !\[dq]bar\[dq], i32 37 }
!2 = !{ i32 2, !\[dq]qux\[dq], i32 42 }
!3 = !{ i32 3, !\[dq]qux\[dq],
  !{
    !\[dq]foo\[dq], i32 1
  }
}
!llvm.module.flags = !{ !0, !1, !2, !3 }
\f[R]
.fi
.IP \[bu] 2
Metadata \f[V]!0\f[R] has the ID \f[V]!\[dq]foo\[dq]\f[R] and the value
\[aq]1\[aq].
The behavior if two or more \f[V]!\[dq]foo\[dq]\f[R] flags are seen is
to emit an error if their values are not equal.
.IP \[bu] 2
Metadata \f[V]!1\f[R] has the ID \f[V]!\[dq]bar\[dq]\f[R] and the value
\[aq]37\[aq].
The behavior if two or more \f[V]!\[dq]bar\[dq]\f[R] flags are seen is
to use the value \[aq]37\[aq].
.IP \[bu] 2
Metadata \f[V]!2\f[R] has the ID \f[V]!\[dq]qux\[dq]\f[R] and the value
\[aq]42\[aq].
The behavior if two or more \f[V]!\[dq]qux\[dq]\f[R] flags are seen is
to emit a warning if their values are not equal.
.IP \[bu] 2
Metadata \f[V]!3\f[R] has the ID \f[V]!\[dq]qux\[dq]\f[R] and the value:
.RS 2
.IP
.nf
\f[C]
!{ !\[dq]foo\[dq], i32 1 }
\f[R]
.fi
.PP
The behavior is to emit an error if the \f[V]llvm.module.flags\f[R] does
not contain a flag with the ID \f[V]!\[dq]foo\[dq]\f[R] that has the
value \[aq]1\[aq] after linking is performed.
.RE
.SS Synthesized Functions Module Flags Metadata
.PP
These metadata specify the default attributes synthesized functions
should have.
These metadata are currently respected by a few instrumentation passes,
such as sanitizers.
.PP
These metadata correspond to a few function attributes with significant
code generation behaviors.
Function attributes with just optimization purposes should not be listed
because the performance impact of these synthesized functions is small.
.IP \[bu] 2
\[dq]frame-pointer\[dq]: \f[B]Max\f[R].
The value can be 0, 1, or 2.
A synthesized function will get the \[dq]frame-pointer\[dq] function
attribute, with value being \[dq]none\[dq], \[dq]non-leaf\[dq], or
\[dq]all\[dq], respectively.
.IP \[bu] 2
\[dq]uwtable\[dq]: \f[B]Max\f[R].
The value can be 0, 1, or 2.
If the value is 1, a synthesized function will get the
\f[V]uwtable(sync)\f[R] function attribute, if the value is 2, a
synthesized function will get the \f[V]uwtable(async)\f[R] function
attribute.
.SS Objective-C Garbage Collection Module Flags Metadata
.PP
On the Mach-O platform, Objective-C stores metadata about garbage
collection in a special section called \[dq]image info\[dq].
The metadata consists of a version number and a bitmask specifying what
types of garbage collection are supported (if any) by the file.
If two or more modules are linked together their garbage collection
metadata needs to be merged rather than appended together.
.PP
The Objective-C garbage collection module flags metadata consists of the
following key-value pairs:
.PP
.TS
tab(@);
lw(21.0n) lw(49.0n).
T{
Key
T}@T{
Value
T}
_
T{
\f[V]Objective-C Version\f[R]
T}@T{
\f[B][Required]\f[R] --- The Objective-C ABI version.
Valid values are 1 and 2.
T}
T{
\f[V]Objective-C Image Info Version\f[R]
T}@T{
\f[B][Required]\f[R] --- The version of the image info section.
Currently always 0.
T}
T{
\f[V]Objective-C Image Info Section\f[R]
T}@T{
\f[B][Required]\f[R] --- The section to place the metadata.
Valid values are \f[V]\[dq]__OBJC, __image_info, regular\[dq]\f[R] for
Objective-C ABI version 1, and
\f[V]\[dq]__DATA,__objc_imageinfo, regular, no_dead_strip\[dq]\f[R] for
Objective-C ABI version 2.
T}
T{
\f[V]Objective-C Garbage Collection\f[R]
T}@T{
\f[B][Required]\f[R] --- Specifies whether garbage collection is
supported or not.
Valid values are 0, for no garbage collection, and 2, for garbage
collection supported.
T}
T{
\f[V]Objective-C GC Only\f[R]
T}@T{
\f[B][Optional]\f[R] --- Specifies that only garbage collection is
supported.
If present, its value must be 6.
This flag requires that the \f[V]Objective-C Garbage Collection\f[R]
flag have the value 2.
T}
.TE
.PP
Some important flag interactions:
.IP \[bu] 2
If a module with \f[V]Objective-C Garbage Collection\f[R] set to 0 is
merged with a module with \f[V]Objective-C Garbage Collection\f[R] set
to 2, then the resulting module has the
\f[V]Objective-C Garbage Collection\f[R] flag set to 0.
.IP \[bu] 2
A module with \f[V]Objective-C Garbage Collection\f[R] set to 0 cannot
be merged with a module with \f[V]Objective-C GC Only\f[R] set to 6.
.SS C type width Module Flags Metadata
.PP
The ARM backend emits a section into each generated object file
describing the options that it was compiled with (in a
compiler-independent way) to prevent linking incompatible objects, and
to allow automatic library selection.
Some of these options are not visible at the IR level, namely wchar_t
width and enum width.
.PP
To pass this information to the backend, these options are encoded in
module flags metadata, using the following key-value pairs:
.PP
.TS
tab(@);
lw(21.0n) lw(49.0n).
T{
Key
T}@T{
Value
T}
_
T{
short_wchar
T}@T{
.IP \[bu] 2
0 --- sizeof(wchar_t) == 4
.IP \[bu] 2
1 --- sizeof(wchar_t) == 2
T}
T{
short_enum
T}@T{
.IP \[bu] 2
0 --- Enums are at least as large as an \f[V]int\f[R].
.IP \[bu] 2
1 --- Enums are stored in the smallest integer type which can represent
all of its values.
T}
.TE
.PP
For example, the following metadata section specifies that the module
was compiled with a \f[V]wchar_t\f[R] width of 4 bytes, and the
underlying type of an enum is the smallest type which can represent all
of its values:
.IP
.nf
\f[C]
!llvm.module.flags = !{!0, !1}
!0 = !{i32 1, !\[dq]short_wchar\[dq], i32 1}
!1 = !{i32 1, !\[dq]short_enum\[dq], i32 0}
\f[R]
.fi
.SS LTO Post-Link Module Flags Metadata
.PP
Some optimisations are only when the entire LTO unit is present in the
current module.
This is represented by the \f[V]LTOPostLink\f[R] module flags metadata,
which will be created with a value of \f[V]1\f[R] when LTO linking
occurs.
.SH Embedded Objects Names Metadata
.PP
Offloading compilations need to embed device code into the host section
table to create a fat binary.
This metadata node references each global that will be embedded in the
module.
The primary use for this is to make referencing these globals more
efficient in the IR.
The metadata references nodes containing pointers to the global to be
embedded followed by the section name it will be stored at:
.IP
.nf
\f[C]
!llvm.embedded.objects = !{!0}
!0 = !{ptr \[at]object, !\[dq].section\[dq]}
\f[R]
.fi
.SH Automatic Linker Flags Named Metadata
.PP
Some targets support embedding of flags to the linker inside individual
object files.
Typically this is used in conjunction with language extensions which
allow source files to contain linker command line options, and have
these automatically be transmitted to the linker via object files.
.PP
These flags are encoded in the IR using named metadata with the name
\f[V]!llvm.linker.options\f[R].
Each operand is expected to be a metadata node which should be a list of
other metadata nodes, each of which should be a list of metadata strings
defining linker options.
.PP
For example, the following metadata section specifies two separate sets
of linker options, presumably to link against \f[V]libz\f[R] and the
\f[V]Cocoa\f[R] framework:
.IP
.nf
\f[C]
!0 = !{ !\[dq]-lz\[dq] }
!1 = !{ !\[dq]-framework\[dq], !\[dq]Cocoa\[dq] }
!llvm.linker.options = !{ !0, !1 }
\f[R]
.fi
.PP
The metadata encoding as lists of lists of options, as opposed to a
collapsed list of options, is chosen so that the IR encoding can use
multiple option strings to specify e.g., a single library, while still
having that specifier be preserved as an atomic element that can be
recognized by a target specific assembly writer or object file emitter.
.PP
Each individual option is required to be either a valid option for the
target\[aq]s linker, or an option that is reserved by the target
specific assembly writer or object file emitter.
No other aspect of these options is defined by the IR.
.SH Dependent Libs Named Metadata
.PP
Some targets support embedding of strings into object files to indicate
a set of libraries to add to the link.
Typically this is used in conjunction with language extensions which
allow source files to explicitly declare the libraries they depend on,
and have these automatically be transmitted to the linker via object
files.
.PP
The list is encoded in the IR using named metadata with the name
\f[V]!llvm.dependent-libraries\f[R].
Each operand is expected to be a metadata node which should contain a
single string operand.
.PP
For example, the following metadata section contains two library
specifiers:
.IP
.nf
\f[C]
!0 = !{!\[dq]a library specifier\[dq]}
!1 = !{!\[dq]another library specifier\[dq]}
!llvm.dependent-libraries = !{ !0, !1 }
\f[R]
.fi
.PP
Each library specifier will be handled independently by the consuming
linker.
The effect of the library specifiers are defined by the consuming
linker.
.SH ThinLTO Summary
.PP
Compiling with ThinLTO (https://clang.llvm.org/docs/ThinLTO.html) causes
the building of a compact summary of the module that is emitted into the
bitcode.
The summary is emitted into the LLVM assembly and identified in syntax
by a caret (\[aq]\f[V]\[ha]\f[R]\[aq]).
.PP
The summary is parsed into a bitcode output, along with the Module IR,
via the \[dq]\f[V]llvm-as\f[R]\[dq] tool.
Tools that parse the Module IR for the purposes of optimization (e.g.
\[dq]\f[V]clang -x ir\f[R]\[dq] and \[dq]\f[V]opt\f[R]\[dq]), will
ignore the summary entries (just as they currently ignore summary
entries in a bitcode input file).
.PP
Eventually, the summary will be parsed into a ModuleSummaryIndex object
under the same conditions where summary index is currently built from
bitcode.
Specifically, tools that test the Thin Link portion of a ThinLTO compile
(i.e.
llvm-lto and llvm-lto2), or when parsing a combined index for a
distributed ThinLTO backend via clang\[aq]s
\[dq]\f[V]-fthinlto-index=<>\f[R]\[dq] flag (this part is not yet
implemented, use llvm-as to create a bitcode object before feeding into
thin link tools for now).
.PP
There are currently 3 types of summary entries in the LLVM assembly:
\f[V]module paths<module_path_summary>\f[R],
\f[V]global values<gv_summary>\f[R], and
\f[V]type identifiers<typeid_summary>\f[R].
.SS Module Path Summary Entry
.PP
Each module path summary entry lists a module containing global values
included in the summary.
For a single IR module there will be one such entry, but in a combined
summary index produced during the thin link, there will be one module
path entry per linked module with summary.
.PP
Example:
.IP
.nf
\f[C]
\[ha]0 = module: (path: \[dq]/path/to/file.o\[dq], hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418))
\f[R]
.fi
.PP
The \f[V]path\f[R] field is a string path to the bitcode file, and the
\f[V]hash\f[R] field is the 160-bit SHA-1 hash of the IR bitcode
contents, used for incremental builds and caching.
.SS Global Value Summary Entry
.PP
Each global value summary entry corresponds to a global value defined or
referenced by a summarized module.
.PP
Example:
.IP
.nf
\f[C]
\[ha]4 = gv: (name: \[dq]f\[dq][, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831
\f[R]
.fi
.PP
For declarations, there will not be a summary list.
For definitions, a global value will contain a list of summaries, one
per module containing a definition.
There can be multiple entries in a combined summary index for symbols
with weak linkage.
.PP
Each \f[V]Summary\f[R] format will depend on whether the global value is
a \f[V]function<function_summary>\f[R],
\f[V]variable<variable_summary>\f[R], or \f[V]alias<alias_summary>\f[R].
.SS Function Summary
.PP
If the global value is a function, the \f[V]Summary\f[R] entry will look
like:
.IP
.nf
\f[C]
function: (module: \[ha]0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), insts: 2[, FuncFlags]?[, Calls]?[, TypeIdInfo]?[, Params]?[, Refs]?
\f[R]
.fi
.PP
The \f[V]module\f[R] field includes the summary entry id for the module
containing this definition, and the \f[V]flags\f[R] field contains
information such as the linkage type, a flag indicating whether it is
legal to import the definition, whether it is globally live and whether
the linker resolved it to a local definition (the latter two are
populated during the thin link).
The \f[V]insts\f[R] field contains the number of IR instructions in the
function.
Finally, there are several optional fields:
\f[V]FuncFlags<funcflags_summary>\f[R], \f[V]Calls<calls_summary>\f[R],
\f[V]TypeIdInfo<typeidinfo_summary>\f[R],
\f[V]Params<params_summary>\f[R], \f[V]Refs<refs_summary>\f[R].
.SS Global Variable Summary
.PP
If the global value is a variable, the \f[V]Summary\f[R] entry will look
like:
.IP
.nf
\f[C]
variable: (module: \[ha]0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0)[, Refs]?
\f[R]
.fi
.PP
The variable entry contains a subset of the fields in a
\f[V]function summary <function_summary>\f[R], see the descriptions
there.
.SS Alias Summary
.PP
If the global value is an alias, the \f[V]Summary\f[R] entry will look
like:
.IP
.nf
\f[C]
alias: (module: \[ha]0, flags: (linkage: external, notEligibleToImport: 0, live: 0, dsoLocal: 0), aliasee: \[ha]2)
\f[R]
.fi
.PP
The \f[V]module\f[R] and \f[V]flags\f[R] fields are as described for a
\f[V]function summary <function_summary>\f[R].
The \f[V]aliasee\f[R] field contains a reference to the global value
summary entry of the aliasee.
.SS Function Flags
.PP
The optional \f[V]FuncFlags\f[R] field looks like:
.IP
.nf
\f[C]
funcFlags: (readNone: 0, readOnly: 0, noRecurse: 0, returnDoesNotAlias: 0, noInline: 0, alwaysInline: 0, noUnwind: 1, mayThrow: 0, hasUnknownCall: 0)
\f[R]
.fi
.PP
If unspecified, flags are assumed to hold the conservative
\f[V]false\f[R] value of \f[V]0\f[R].
.SS Calls
.PP
The optional \f[V]Calls\f[R] field looks like:
.IP
.nf
\f[C]
calls: ((Callee)[, (Callee)]*)
\f[R]
.fi
.PP
where each \f[V]Callee\f[R] looks like:
.IP
.nf
\f[C]
callee: \[ha]1[, hotness: None]?[, relbf: 0]?
\f[R]
.fi
.PP
The \f[V]callee\f[R] refers to the summary entry id of the callee.
At most one of \f[V]hotness\f[R] (which can take the values
\f[V]Unknown\f[R], \f[V]Cold\f[R], \f[V]None\f[R], \f[V]Hot\f[R], and
\f[V]Critical\f[R]), and \f[V]relbf\f[R] (which holds the integer branch
frequency relative to the entry frequency, scaled down by 2\[ha]8) may
be specified.
The defaults are \f[V]Unknown\f[R] and \f[V]0\f[R], respectively.
.SS Params
.PP
The optional \f[V]Params\f[R] is used by \f[V]StackSafety\f[R] and looks
like:
.IP
.nf
\f[C]
Params: ((Param)[, (Param)]*)
\f[R]
.fi
.PP
where each \f[V]Param\f[R] describes pointer parameter access inside of
the function and looks like:
.IP
.nf
\f[C]
param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?
\f[R]
.fi
.PP
where the first \f[V]param\f[R] is the number of the parameter it
describes, \f[V]offset\f[R] is the inclusive range of offsets from the
pointer parameter to bytes which can be accessed by the function.
This range does not include accesses by function calls from
\f[V]calls\f[R] list.
.PP
where each \f[V]Callee\f[R] describes how parameter is forwarded into
other functions and looks like:
.IP
.nf
\f[C]
callee: \[ha]3, param: 5, offset: [-3, 3]
\f[R]
.fi
.PP
The \f[V]callee\f[R] refers to the summary entry id of the callee,
\f[V]param\f[R] is the number of the callee parameter which points into
the callers parameter with offset known to be inside of the
\f[V]offset\f[R] range.
\f[V]calls\f[R] will be consumed and removed by thin link stage to
update \f[V]Param::offset\f[R] so it covers all accesses possible by
\f[V]calls\f[R].
.PP
Pointer parameter without corresponding \f[V]Param\f[R] is considered
unsafe and we assume that access with any offset is possible.
.PP
Example:
.PP
If we have the following function:
.IP
.nf
\f[C]
define i64 \[at]foo(i64* %0, i32* %1, i8* %2, i8 %3) {
  store i32* %1, i32** \[at]x
  %5 = getelementptr inbounds i8, i8* %2, i64 5
  %6 = load i8, i8* %5
  %7 = getelementptr inbounds i8, i8* %2, i8 %3
  tail call void \[at]bar(i8 %3, i8* %7)
  %8 = load i64, i64* %0
  ret i64 %8
}
\f[R]
.fi
.PP
We can expect the record like this:
.IP
.nf
\f[C]
params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: \[ha]3, param: 1, offset: [-128, 127]))))
\f[R]
.fi
.PP
The function may access just 8 bytes of the parameter %0 .
\f[V]calls\f[R] is empty, so the parameter is either not used for
function calls or \f[V]offset\f[R] already covers all accesses from
nested function calls.
Parameter %1 escapes, so access is unknown.
The function itself can access just a single byte of the parameter %2.
Additional access is possible inside of the \f[V]\[at]bar\f[R] or
\f[V]\[ha]3\f[R].
The function adds signed offset to the pointer and passes the result as
the argument %1 into \f[V]\[ha]3\f[R].
This record itself does not tell us how \f[V]\[ha]3\f[R] will access the
parameter.
Parameter %3 is not a pointer.
.SS Refs
.PP
The optional \f[V]Refs\f[R] field looks like:
.IP
.nf
\f[C]
refs: ((Ref)[, (Ref)]*)
\f[R]
.fi
.PP
where each \f[V]Ref\f[R] contains a reference to the summary id of the
referenced value (e.g.
\f[V]\[ha]1\f[R]).
.SS TypeIdInfo
.PP
The optional \f[V]TypeIdInfo\f[R] field, used for Control Flow
Integrity (https://clang.llvm.org/docs/ControlFlowIntegrity.html), looks
like:
.IP
.nf
\f[C]
typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstVCalls)]?[, (TypeCheckedLoadConstVCalls)]?
\f[R]
.fi
.PP
These optional fields have the following forms:
.SS TypeTests
.IP
.nf
\f[C]
typeTests: (TypeIdRef[, TypeIdRef]*)
\f[R]
.fi
.PP
Where each \f[V]TypeIdRef\f[R] refers to a
\f[V]type id<typeid_summary>\f[R] by summary id or \f[V]GUID\f[R].
.SS TypeTestAssumeVCalls
.IP
.nf
\f[C]
typeTestAssumeVCalls: (VFuncId[, VFuncId]*)
\f[R]
.fi
.PP
Where each VFuncId has the format:
.IP
.nf
\f[C]
vFuncId: (TypeIdRef, offset: 16)
\f[R]
.fi
.PP
Where each \f[V]TypeIdRef\f[R] refers to a
\f[V]type id<typeid_summary>\f[R] by summary id or \f[V]GUID\f[R]
preceded by a \f[V]guid:\f[R] tag.
.SS TypeCheckedLoadVCalls
.IP
.nf
\f[C]
typeCheckedLoadVCalls: (VFuncId[, VFuncId]*)
\f[R]
.fi
.PP
Where each VFuncId has the format described for
\f[V]TypeTestAssumeVCalls\f[R].
.SS TypeTestAssumeConstVCalls
.IP
.nf
\f[C]
typeTestAssumeConstVCalls: (ConstVCall[, ConstVCall]*)
\f[R]
.fi
.PP
Where each ConstVCall has the format:
.IP
.nf
\f[C]
(VFuncId, args: (Arg[, Arg]*))
\f[R]
.fi
.PP
and where each VFuncId has the format described for
\f[V]TypeTestAssumeVCalls\f[R], and each Arg is an integer argument
number.
.SS TypeCheckedLoadConstVCalls
.IP
.nf
\f[C]
typeCheckedLoadConstVCalls: (ConstVCall[, ConstVCall]*)
\f[R]
.fi
.PP
Where each ConstVCall has the format described for
\f[V]TypeTestAssumeConstVCalls\f[R].
.SS Type ID Summary Entry
.PP
Each type id summary entry corresponds to a type identifier resolution
which is generated during the LTO link portion of the compile when
building with Control Flow
Integrity (https://clang.llvm.org/docs/ControlFlowIntegrity.html), so
these are only present in a combined summary index.
.PP
Example:
.IP
.nf
\f[C]
\[ha]4 = typeid: (name: \[dq]_ZTS1A\[dq], summary: (typeTestRes: (kind: allOnes, sizeM1BitWidth: 7[, alignLog2: 0]?[, sizeM1: 0]?[, bitMask: 0]?[, inlineBits: 0]?)[, WpdResolutions]?)) ; guid = 7004155349499253778
\f[R]
.fi
.PP
The \f[V]typeTestRes\f[R] gives the type test resolution \f[V]kind\f[R]
(which may be \f[V]unsat\f[R], \f[V]byteArray\f[R], \f[V]inline\f[R],
\f[V]single\f[R], or \f[V]allOnes\f[R]), and the \f[V]size-1\f[R] bit
width.
It is followed by optional flags, which default to 0, and an optional
WpdResolutions (whole program devirtualization resolution) field that
looks like:
.IP
.nf
\f[C]
wpdResolutions: ((offset: 0, WpdRes)[, (offset: 1, WpdRes)]*
\f[R]
.fi
.PP
where each entry is a mapping from the given byte offset to the
whole-program devirtualization resolution WpdRes, that has one of the
following formats:
.IP
.nf
\f[C]
wpdRes: (kind: branchFunnel)
wpdRes: (kind: singleImpl, singleImplName: \[dq]_ZN1A1nEi\[dq])
wpdRes: (kind: indir)
\f[R]
.fi
.PP
Additionally, each wpdRes has an optional \f[V]resByArg\f[R] field,
which describes the resolutions for calls with all constant integer
arguments:
.IP
.nf
\f[C]
resByArg: (ResByArg[, ResByArg]*)
\f[R]
.fi
.PP
where ResByArg is:
.IP
.nf
\f[C]
args: (Arg[, Arg]*), byArg: (kind: UniformRetVal[, info: 0][, byte: 0][, bit: 0])
\f[R]
.fi
.PP
Where the \f[V]kind\f[R] can be \f[V]Indir\f[R],
\f[V]UniformRetVal\f[R], \f[V]UniqueRetVal\f[R] or
\f[V]VirtualConstProp\f[R].
The \f[V]info\f[R] field is only used if the kind is
\f[V]UniformRetVal\f[R] (indicates the uniform return value), or
\f[V]UniqueRetVal\f[R] (holds the return value associated with the
unique vtable (0 or 1)).
The \f[V]byte\f[R] and \f[V]bit\f[R] fields are only used if the target
does not support the use of absolute symbols to store constants.
.SH Intrinsic Global Variables
.PP
LLVM has a number of \[dq]magic\[dq] global variables that contain data
that affect code generation or other IR semantics.
These are documented here.
All globals of this sort should have a section specified as
\[dq]\f[V]llvm.metadata\f[R]\[dq].
This section and all globals that start with \[dq]\f[V]llvm.\f[R]\[dq]
are reserved for use by LLVM.
.SS The \[aq]\f[V]llvm.used\f[R]\[aq] Global Variable
.PP
The \f[V]\[at]llvm.used\f[R] global is an array which has
\f[V]appending linkage <linkage_appending>\f[R].
This array contains a list of pointers to named global variables,
functions and aliases which may optionally have a pointer cast formed of
bitcast or getelementptr.
For example, a legal use of it is:
.IP
.nf
\f[C]
\[at]X = global i8 4
\[at]Y = global i32 123

\[at]llvm.used = appending global [2 x i8*] [
   i8* \[at]X,
   i8* bitcast (i32* \[at]Y to i8*)
], section \[dq]llvm.metadata\[dq]
\f[R]
.fi
.PP
If a symbol appears in the \f[V]\[at]llvm.used\f[R] list, then the
compiler, assembler, and linker are required to treat the symbol as if
there is a reference to the symbol that it cannot see (which is why they
have to be named).
For example, if a variable has internal linkage and no references other
than that from the \f[V]\[at]llvm.used\f[R] list, it cannot be deleted.
This is commonly used to represent references from inline asms and other
things the compiler cannot \[dq]see\[dq], and corresponds to
\[dq]\f[V]attribute((used))\f[R]\[dq] in GNU C.
.PP
On some targets, the code generator must emit a directive to the
assembler or object file to prevent the assembler and linker from
removing the symbol.
.SS The \[aq]\f[V]llvm.compiler.used\f[R]\[aq] Global Variable
.PP
The \f[V]\[at]llvm.compiler.used\f[R] directive is the same as the
\f[V]\[at]llvm.used\f[R] directive, except that it only prevents the
compiler from touching the symbol.
On targets that support it, this allows an intelligent linker to
optimize references to the symbol without being impeded as it would be
by \f[V]\[at]llvm.used\f[R].
.PP
This is a rare construct that should only be used in rare circumstances,
and should not be exposed to source languages.
.SS The \[aq]\f[V]llvm.global_ctors\f[R]\[aq] Global Variable
.IP
.nf
\f[C]
%0 = type { i32, void ()*, i8* }
\[at]llvm.global_ctors = appending global [1 x %0] [%0 { i32 65535, void ()* \[at]ctor, i8* \[at]data }]
\f[R]
.fi
.PP
The \f[V]\[at]llvm.global_ctors\f[R] array contains a list of
constructor functions, priorities, and an associated global or function.
The functions referenced by this array will be called in ascending order
of priority (i.e.
lowest first) when the module is loaded.
The order of functions with the same priority is not defined.
.PP
If the third field is non-null, and points to a global variable or
function, the initializer function will only run if the associated data
from the current module is not discarded.
On ELF the referenced global variable or function must be in a comdat.
.SS The \[aq]\f[V]llvm.global_dtors\f[R]\[aq] Global Variable
.IP
.nf
\f[C]
%0 = type { i32, void ()*, i8* }
\[at]llvm.global_dtors = appending global [1 x %0] [%0 { i32 65535, void ()* \[at]dtor, i8* \[at]data }]
\f[R]
.fi
.PP
The \f[V]\[at]llvm.global_dtors\f[R] array contains a list of destructor
functions, priorities, and an associated global or function.
The functions referenced by this array will be called in descending
order of priority (i.e.
highest first) when the module is unloaded.
The order of functions with the same priority is not defined.
.PP
If the third field is non-null, and points to a global variable or
function, the destructor function will only run if the associated data
from the current module is not discarded.
On ELF the referenced global variable or function must be in a comdat.
.SH Instruction Reference
.PP
The LLVM instruction set consists of several different classifications
of instructions: \f[V]terminator instructions <terminators>\f[R],
\f[V]binary
instructions <binaryops>\f[R], \f[V]bitwise binary
instructions <bitwiseops>\f[R],
\f[V]memory instructions <memoryops>\f[R], and
\f[V]other instructions <otherops>\f[R].
.SS Terminator Instructions
.PP
As mentioned \f[V]previously <functionstructure>\f[R], every basic block
in a program ends with a \[dq]Terminator\[dq] instruction, which
indicates which block should be executed after the current block is
finished.
These terminator instructions typically yield a \[aq]\f[V]void\f[R]\[aq]
value: they produce control flow, not values (the one exception being
the \[aq]\f[V]invoke <i_invoke>\f[R]\[aq] instruction).
.PP
The terminator instructions are: \[aq]\f[V]ret <i_ret>\f[R]\[aq],
\[aq]\f[V]br <i_br>\f[R]\[aq], \[aq]\f[V]switch <i_switch>\f[R]\[aq],
\[aq]\f[V]indirectbr <i_indirectbr>\f[R]\[aq],
\[aq]\f[V]invoke <i_invoke>\f[R]\[aq],
\[aq]\f[V]callbr <i_callbr>\f[R]\[aq]
\[aq]\f[V]resume <i_resume>\f[R]\[aq],
\[aq]\f[V]catchswitch <i_catchswitch>\f[R]\[aq],
\[aq]\f[V]catchret <i_catchret>\f[R]\[aq],
\[aq]\f[V]cleanupret <i_cleanupret>\f[R]\[aq], and
\[aq]\f[V]unreachable <i_unreachable>\f[R]\[aq].
.SS \[aq]\f[V]ret\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
ret <type> <value>       ; Return a value from a non-void function
ret void                 ; Return from void function
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]ret\f[R]\[aq] instruction is used to return control flow
(and optionally a value) from a function back to the caller.
.PP
There are two forms of the \[aq]\f[V]ret\f[R]\[aq] instruction: one that
returns a value and then causes control flow, and one that just causes
control flow to occur.
.SS Arguments:
.PP
The \[aq]\f[V]ret\f[R]\[aq] instruction optionally accepts a single
argument, the return value.
The type of the return value must be a \[aq]\f[V]first
class <t_firstclass>\f[R]\[aq] type.
.PP
A function is not \f[V]well formed <wellformed>\f[R] if it has a
non-void return type and contains a \[aq]\f[V]ret\f[R]\[aq] instruction
with no return value or a return value with a type that does not match
its type, or if it has a void return type and contains a
\[aq]\f[V]ret\f[R]\[aq] instruction with a return value.
.SS Semantics:
.PP
When the \[aq]\f[V]ret\f[R]\[aq] instruction is executed, control flow
returns back to the calling function\[aq]s context.
If the caller is a \[dq]\f[V]call <i_call>\f[R]\[dq] instruction,
execution continues at the instruction after the call.
If the caller was an \[dq]\f[V]invoke <i_invoke>\f[R]\[dq] instruction,
execution continues at the beginning of the \[dq]normal\[dq] destination
block.
If the instruction returns a value, that value shall set the call or
invoke instruction\[aq]s return value.
.SS Example:
.IP
.nf
\f[C]
ret i32 5                       ; Return an integer value of 5
ret void                        ; Return from a void function
ret { i32, i8 } { i32 4, i8 2 } ; Return a struct of values 4 and 2
\f[R]
.fi
.SS \[aq]\f[V]br\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
br i1 <cond>, label <iftrue>, label <iffalse>
br label <dest>          ; Unconditional branch
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]br\f[R]\[aq] instruction is used to cause control flow to
transfer to a different basic block in the current function.
There are two forms of this instruction, corresponding to a conditional
branch and an unconditional branch.
.SS Arguments:
.PP
The conditional branch form of the \[aq]\f[V]br\f[R]\[aq] instruction
takes a single \[aq]\f[V]i1\f[R]\[aq] value and two
\[aq]\f[V]label\f[R]\[aq] values.
The unconditional form of the \[aq]\f[V]br\f[R]\[aq] instruction takes a
single \[aq]\f[V]label\f[R]\[aq] value as a target.
.SS Semantics:
.PP
Upon execution of a conditional \[aq]\f[V]br\f[R]\[aq] instruction, the
\[aq]\f[V]i1\f[R]\[aq] argument is evaluated.
If the value is \f[V]true\f[R], control flows to the
\[aq]\f[V]iftrue\f[R]\[aq] \f[V]label\f[R] argument.
If \[dq]cond\[dq] is \f[V]false\f[R], control flows to the
\[aq]\f[V]iffalse\f[R]\[aq] \f[V]label\f[R] argument.
If \[aq]\f[V]cond\f[R]\[aq] is \f[V]poison\f[R] or \f[V]undef\f[R], this
instruction has undefined behavior.
.SS Example:
.IP
.nf
\f[C]
Test:
  %cond = icmp eq i32 %a, %b
  br i1 %cond, label %IfEqual, label %IfUnequal
IfEqual:
  ret i32 1
IfUnequal:
  ret i32 0
\f[R]
.fi
.SS \[aq]\f[V]switch\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
switch <intty> <value>, label <defaultdest> [ <intty> <val>, label <dest> ... ]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]switch\f[R]\[aq] instruction is used to transfer control
flow to one of several different places.
It is a generalization of the \[aq]\f[V]br\f[R]\[aq] instruction,
allowing a branch to occur to one of many possible destinations.
.SS Arguments:
.PP
The \[aq]\f[V]switch\f[R]\[aq] instruction uses three parameters: an
integer comparison value \[aq]\f[V]value\f[R]\[aq], a default
\[aq]\f[V]label\f[R]\[aq] destination, and an array of pairs of
comparison value constants and \[aq]\f[V]label\f[R]\[aq]s.
The table is not allowed to contain duplicate constant entries.
.SS Semantics:
.PP
The \f[V]switch\f[R] instruction specifies a table of values and
destinations.
When the \[aq]\f[V]switch\f[R]\[aq] instruction is executed, this table
is searched for the given value.
If the value is found, control flow is transferred to the corresponding
destination; otherwise, control flow is transferred to the default
destination.
If \[aq]\f[V]value\f[R]\[aq] is \f[V]poison\f[R] or \f[V]undef\f[R],
this instruction has undefined behavior.
.SS Implementation:
.PP
Depending on properties of the target machine and the particular
\f[V]switch\f[R] instruction, this instruction may be code generated in
different ways.
For example, it could be generated as a series of chained conditional
branches or with a lookup table.
.SS Example:
.IP
.nf
\f[C]
; Emulate a conditional br instruction
%Val = zext i1 %value to i32
switch i32 %Val, label %truedest [ i32 0, label %falsedest ]

; Emulate an unconditional br instruction
switch i32 0, label %dest [ ]

; Implement a jump table:
switch i32 %val, label %otherwise [ i32 0, label %onzero
                                    i32 1, label %onone
                                    i32 2, label %ontwo ]
\f[R]
.fi
.SS \[aq]\f[V]indirectbr\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
indirectbr <somety>* <address>, [ label <dest1>, label <dest2>, ... ]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]indirectbr\f[R]\[aq] instruction implements an indirect
branch to a label within the current function, whose address is
specified by \[dq]\f[V]address\f[R]\[dq].
Address must be derived from a \f[V]blockaddress <blockaddress>\f[R]
constant.
.SS Arguments:
.PP
The \[aq]\f[V]address\f[R]\[aq] argument is the address of the label to
jump to.
The rest of the arguments indicate the full set of possible destinations
that the address may point to.
Blocks are allowed to occur multiple times in the destination list,
though this isn\[aq]t particularly useful.
.PP
This destination list is required so that dataflow analysis has an
accurate understanding of the CFG.
.SS Semantics:
.PP
Control transfers to the block specified in the address argument.
All possible destination blocks must be listed in the label list,
otherwise this instruction has undefined behavior.
This implies that jumps to labels defined in other functions have
undefined behavior as well.
If \[aq]\f[V]address\f[R]\[aq] is \f[V]poison\f[R] or \f[V]undef\f[R],
this instruction has undefined behavior.
.SS Implementation:
.PP
This is typically implemented with a jump through a register.
.SS Example:
.IP
.nf
\f[C]
indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ]
\f[R]
.fi
.SS \[aq]\f[V]invoke\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = invoke [cconv] [ret attrs] [addrspace(<num>)] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]
              [operand bundles] to label <normal label> unwind label <exception label>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]invoke\f[R]\[aq] instruction causes control to transfer to
a specified function, with the possibility of control flow transfer to
either the \[aq]\f[V]normal\f[R]\[aq] label or the
\[aq]\f[V]exception\f[R]\[aq] label.
If the callee function returns with the \[dq]\f[V]ret\f[R]\[dq]
instruction, control flow will return to the \[dq]normal\[dq] label.
If the callee (or any indirect callees) returns via the
\[dq]\f[V]resume <i_resume>\f[R]\[dq] instruction or other exception
handling mechanism, control is interrupted and continued at the
dynamically nearest \[dq]exception\[dq] label.
.PP
The \[aq]\f[V]exception\f[R]\[aq] label is a landing pad for the
exception.
As such, \[aq]\f[V]exception\f[R]\[aq] label is required to have the
\[dq]\f[V]landingpad <i_landingpad>\f[R]\[dq] instruction, which
contains the information about the behavior of the program after
unwinding happens, as its first non-PHI instruction.
The restrictions on the \[dq]\f[V]landingpad\f[R]\[dq] instruction\[aq]s
tightly couples it to the \[dq]\f[V]invoke\f[R]\[dq] instruction, so
that the important information contained within the
\[dq]\f[V]landingpad\f[R]\[dq] instruction can\[aq]t be lost through
normal code motion.
.SS Arguments:
.PP
This instruction requires several arguments:
.IP " 1." 4
The optional \[dq]cconv\[dq] marker indicates which \f[V]calling
convention <callingconv>\f[R] the call should use.
If none is specified, the call defaults to using C calling conventions.
.IP " 2." 4
The optional \f[V]Parameter Attributes <paramattrs>\f[R] list for return
values.
Only \[aq]\f[V]zeroext\f[R]\[aq], \[aq]\f[V]signext\f[R]\[aq], and
\[aq]\f[V]inreg\f[R]\[aq] attributes are valid here.
.IP " 3." 4
The optional addrspace attribute can be used to indicate the address
space of the called function.
If it is not specified, the program address space from the
\f[V]datalayout string<langref_datalayout>\f[R] will be used.
.IP " 4." 4
\[aq]\f[V]ty\f[R]\[aq]: the type of the call instruction itself which is
also the type of the return value.
Functions that return no value are marked \f[V]void\f[R].
.IP " 5." 4
\[aq]\f[V]fnty\f[R]\[aq]: shall be the signature of the function being
invoked.
The argument types must match the types implied by this signature.
This type can be omitted if the function is not varargs.
.IP " 6." 4
\[aq]\f[V]fnptrval\f[R]\[aq]: An LLVM value containing a pointer to a
function to be invoked.
In most cases, this is a direct function invocation, but indirect
\f[V]invoke\f[R]\[aq]s are just as possible, calling an arbitrary
pointer to function value.
.IP " 7." 4
\[aq]\f[V]function args\f[R]\[aq]: argument list whose types match the
function signature argument types and parameter attributes.
All arguments must be of \f[V]first class <t_firstclass>\f[R] type.
If the function signature indicates the function accepts a variable
number of arguments, the extra arguments can be specified.
.IP " 8." 4
\[aq]\f[V]normal label\f[R]\[aq]: the label reached when the called
function executes a \[aq]\f[V]ret\f[R]\[aq] instruction.
.IP " 9." 4
\[aq]\f[V]exception label\f[R]\[aq]: the label reached when a callee
returns via the \f[V]resume <i_resume>\f[R] instruction or other
exception handling mechanism.
.IP "10." 4
The optional \f[V]function attributes <fnattrs>\f[R] list.
.IP "11." 4
The optional \f[V]operand bundles <opbundles>\f[R] list.
.SS Semantics:
.PP
This instruction is designed to operate as a standard
\[aq]\f[V]call\f[R]\[aq] instruction in most regards.
The primary difference is that it establishes an association with a
label, which is used by the runtime library to unwind the stack.
.PP
This instruction is used in languages with destructors to ensure that
proper cleanup is performed in the case of either a \f[V]longjmp\f[R] or
a thrown exception.
Additionally, this is important for implementation of
\[aq]\f[V]catch\f[R]\[aq] clauses in high-level languages that support
them.
.PP
For the purposes of the SSA form, the definition of the value returned
by the \[aq]\f[V]invoke\f[R]\[aq] instruction is deemed to occur on the
edge from the current block to the \[dq]normal\[dq] label.
If the callee unwinds then no return value is available.
.SS Example:
.IP
.nf
\f[C]
%retval = invoke i32 \[at]Test(i32 15) to label %Continue
            unwind label %TestCleanup              ; i32:retval set
%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue
            unwind label %TestCleanup              ; i32:retval set
\f[R]
.fi
.SS \[aq]\f[V]callbr\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = callbr [cconv] [ret attrs] [addrspace(<num>)] <ty>|<fnty> <fnptrval>(<function args>) [fn attrs]
              [operand bundles] to label <fallthrough label> [indirect labels]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]callbr\f[R]\[aq] instruction causes control to transfer to
a specified function, with the possibility of control flow transfer to
either the \[aq]\f[V]fallthrough\f[R]\[aq] label or one of the
\[aq]\f[V]indirect\f[R]\[aq] labels.
.PP
This instruction should only be used to implement the \[dq]goto\[dq]
feature of gcc style inline assembly.
Any other usage is an error in the IR verifier.
.SS Arguments:
.PP
This instruction requires several arguments:
.IP " 1." 4
The optional \[dq]cconv\[dq] marker indicates which \f[V]calling
convention <callingconv>\f[R] the call should use.
If none is specified, the call defaults to using C calling conventions.
.IP " 2." 4
The optional \f[V]Parameter Attributes <paramattrs>\f[R] list for return
values.
Only \[aq]\f[V]zeroext\f[R]\[aq], \[aq]\f[V]signext\f[R]\[aq], and
\[aq]\f[V]inreg\f[R]\[aq] attributes are valid here.
.IP " 3." 4
The optional addrspace attribute can be used to indicate the address
space of the called function.
If it is not specified, the program address space from the
\f[V]datalayout string<langref_datalayout>\f[R] will be used.
.IP " 4." 4
\[aq]\f[V]ty\f[R]\[aq]: the type of the call instruction itself which is
also the type of the return value.
Functions that return no value are marked \f[V]void\f[R].
.IP " 5." 4
\[aq]\f[V]fnty\f[R]\[aq]: shall be the signature of the function being
called.
The argument types must match the types implied by this signature.
This type can be omitted if the function is not varargs.
.IP " 6." 4
\[aq]\f[V]fnptrval\f[R]\[aq]: An LLVM value containing a pointer to a
function to be called.
In most cases, this is a direct function call, but other
\f[V]callbr\f[R]\[aq]s are just as possible, calling an arbitrary
pointer to function value.
.IP " 7." 4
\[aq]\f[V]function args\f[R]\[aq]: argument list whose types match the
function signature argument types and parameter attributes.
All arguments must be of \f[V]first class <t_firstclass>\f[R] type.
If the function signature indicates the function accepts a variable
number of arguments, the extra arguments can be specified.
.IP " 8." 4
\[aq]\f[V]fallthrough label\f[R]\[aq]: the label reached when the inline
assembly\[aq]s execution exits the bottom.
.IP " 9." 4
\[aq]\f[V]indirect labels\f[R]\[aq]: the labels reached when a callee
transfers control to a location other than the
\[aq]\f[V]fallthrough label\f[R]\[aq].
The blockaddress constant for these should also be in the list of
\[aq]\f[V]function args\f[R]\[aq].
.IP "10." 4
The optional \f[V]function attributes <fnattrs>\f[R] list.
.IP "11." 4
The optional \f[V]operand bundles <opbundles>\f[R] list.
.SS Semantics:
.PP
This instruction is designed to operate as a standard
\[aq]\f[V]call\f[R]\[aq] instruction in most regards.
The primary difference is that it establishes an association with
additional labels to define where control flow goes after the call.
.PP
The output values of a \[aq]\f[V]callbr\f[R]\[aq] instruction are
available only to the \[aq]\f[V]fallthrough\f[R]\[aq] block, not to any
\[aq]\f[V]indirect\f[R]\[aq] blocks(s).
.PP
The only use of this today is to implement the \[dq]goto\[dq] feature of
gcc inline assembly where additional labels can be provided as locations
for the inline assembly to jump to.
.SS Example:
.IP
.nf
\f[C]
; \[dq]asm goto\[dq] without output constraints.
callbr void asm \[dq]\[dq], \[dq]r,X\[dq](i32 %x, i8 *blockaddress(\[at]foo, %indirect))
            to label %fallthrough [label %indirect]

; \[dq]asm goto\[dq] with output constraints.
<result> = callbr i32 asm \[dq]\[dq], \[dq]=r,r,X\[dq](i32 %x, i8 *blockaddress(\[at]foo, %indirect))
            to label %fallthrough [label %indirect]
\f[R]
.fi
.SS \[aq]\f[V]resume\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
resume <type> <value>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]resume\f[R]\[aq] instruction is a terminator instruction
that has no successors.
.SS Arguments:
.PP
The \[aq]\f[V]resume\f[R]\[aq] instruction requires one argument, which
must have the same type as the result of any
\[aq]\f[V]landingpad\f[R]\[aq] instruction in the same function.
.SS Semantics:
.PP
The \[aq]\f[V]resume\f[R]\[aq] instruction resumes propagation of an
existing (in-flight) exception whose unwinding was interrupted with a
\f[V]landingpad <i_landingpad>\f[R] instruction.
.SS Example:
.IP
.nf
\f[C]
resume { i8*, i32 } %exn
\f[R]
.fi
.SS \[aq]\f[V]catchswitch\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller
<resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]catchswitch\f[R]\[aq] instruction is used by LLVM\[aq]s
exception handling system to describe the set of possible catch handlers
that may be executed by the
\f[V]EH personality routine <personalityfn>\f[R].
.SS Arguments:
.PP
The \f[V]parent\f[R] argument is the token of the funclet that contains
the \f[V]catchswitch\f[R] instruction.
If the \f[V]catchswitch\f[R] is not inside a funclet, this operand may
be the token \f[V]none\f[R].
.PP
The \f[V]default\f[R] argument is the label of another basic block
beginning with either a \f[V]cleanuppad\f[R] or \f[V]catchswitch\f[R]
instruction.
This unwind destination must be a legal target with respect to the
\f[V]parent\f[R] links, as described in the exception handling
documentation.
.PP
The \f[V]handlers\f[R] are a nonempty list of successor blocks that each
begin with a \f[V]catchpad <i_catchpad>\f[R] instruction.
.SS Semantics:
.PP
Executing this instruction transfers control to one of the successors in
\f[V]handlers\f[R], if appropriate, or continues to unwind via the
unwind label if present.
.PP
The \f[V]catchswitch\f[R] is both a terminator and a \[dq]pad\[dq]
instruction, meaning that it must be both the first non-phi instruction
and last instruction in the basic block.
Therefore, it must be the only non-phi instruction in the block.
.SS Example:
.IP
.nf
\f[C]
dispatch1:
  %cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller
dispatch2:
  %cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup
\f[R]
.fi
.SS \[aq]\f[V]catchret\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
catchret from <token> to label <normal>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]catchret\f[R]\[aq] instruction is a terminator instruction
that has a single successor.
.SS Arguments:
.PP
The first argument to a \[aq]\f[V]catchret\f[R]\[aq] indicates which
\f[V]catchpad\f[R] it exits.
It must be a \f[V]catchpad <i_catchpad>\f[R].
The second argument to a \[aq]\f[V]catchret\f[R]\[aq] specifies where
control will transfer to next.
.SS Semantics:
.PP
The \[aq]\f[V]catchret\f[R]\[aq] instruction ends an existing
(in-flight) exception whose unwinding was interrupted with a
\f[V]catchpad <i_catchpad>\f[R] instruction.
The \f[V]personality function <personalityfn>\f[R] gets a chance to
execute arbitrary code to, for example, destroy the active exception.
Control then transfers to \f[V]normal\f[R].
.PP
The \f[V]token\f[R] argument must be a token produced by a
\f[V]catchpad\f[R] instruction.
If the specified \f[V]catchpad\f[R] is not the most-recently-entered
not-yet-exited funclet pad (as described in the EH documentation), the
\f[V]catchret\f[R]\[aq]s behavior is undefined.
.SS Example:
.IP
.nf
\f[C]
catchret from %catch to label %continue
\f[R]
.fi
.SS \[aq]\f[V]cleanupret\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
cleanupret from <value> unwind label <continue>
cleanupret from <value> unwind to caller
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]cleanupret\f[R]\[aq] instruction is a terminator
instruction that has an optional successor.
.SS Arguments:
.PP
The \[aq]\f[V]cleanupret\f[R]\[aq] instruction requires one argument,
which indicates which \f[V]cleanuppad\f[R] it exits, and must be a
\f[V]cleanuppad <i_cleanuppad>\f[R].
If the specified \f[V]cleanuppad\f[R] is not the most-recently-entered
not-yet-exited funclet pad (as described in the EH documentation), the
\f[V]cleanupret\f[R]\[aq]s behavior is undefined.
.PP
The \[aq]\f[V]cleanupret\f[R]\[aq] instruction also has an optional
successor, \f[V]continue\f[R], which must be the label of another basic
block beginning with either a \f[V]cleanuppad\f[R] or
\f[V]catchswitch\f[R] instruction.
This unwind destination must be a legal target with respect to the
\f[V]parent\f[R] links, as described in the exception handling
documentation.
.SS Semantics:
.PP
The \[aq]\f[V]cleanupret\f[R]\[aq] instruction indicates to the
\f[V]personality function <personalityfn>\f[R] that one
\f[V]cleanuppad <i_cleanuppad>\f[R] it transferred control to has ended.
It transfers control to \f[V]continue\f[R] or unwinds out of the
function.
.SS Example:
.IP
.nf
\f[C]
cleanupret from %cleanup unwind to caller
cleanupret from %cleanup unwind label %continue
\f[R]
.fi
.SS \[aq]\f[V]unreachable\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
unreachable
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]unreachable\f[R]\[aq] instruction has no defined
semantics.
This instruction is used to inform the optimizer that a particular
portion of the code is not reachable.
This can be used to indicate that the code after a no-return function
cannot be reached, and other facts.
.SS Semantics:
.PP
The \[aq]\f[V]unreachable\f[R]\[aq] instruction has no defined
semantics.
.SS Unary Operations
.PP
Unary operators require a single operand, execute an operation on it,
and produce a single value.
The operand might represent multiple data, as is the case with the
\f[V]vector <t_vector>\f[R] data type.
The result value has the same type as its operand.
.SS \[aq]\f[V]fneg\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fneg [fast-math flags]* <ty> <op1>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fneg\f[R]\[aq] instruction returns the negation of its
operand.
.SS Arguments:
.PP
The argument to the \[aq]\f[V]fneg\f[R]\[aq] instruction must be a
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
.SS Semantics:
.PP
The value produced is a copy of the operand with its sign bit flipped.
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = fneg float %val          ; yields float:result = -%var
\f[R]
.fi
.SS Binary Operations
.PP
Binary operators are used to do most of the computation in a program.
They require two operands of the same type, execute an operation on
them, and produce a single value.
The operands might represent multiple data, as is the case with the
\f[V]vector <t_vector>\f[R] data type.
The result value has the same type as its operands.
.PP
There are several different binary operators:
.SS \[aq]\f[V]add\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = add <ty> <op1>, <op2>          ; yields ty:result
<result> = add nuw <ty> <op1>, <op2>      ; yields ty:result
<result> = add nsw <ty> <op1>, <op2>      ; yields ty:result
<result> = add nuw nsw <ty> <op1>, <op2>  ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]add\f[R]\[aq] instruction returns the sum of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]add\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the integer sum of the two operands.
.PP
If the sum has unsigned overflow, the result returned is the
mathematical result modulo 2^n^, where n is the bit width of the result.
.PP
Because LLVM integers use a two\[aq]s complement representation, this
instruction is appropriate for both signed and unsigned integers.
.PP
\f[V]nuw\f[R] and \f[V]nsw\f[R] stand for \[dq]No Unsigned Wrap\[dq] and
\[dq]No Signed Wrap\[dq], respectively.
If the \f[V]nuw\f[R] and/or \f[V]nsw\f[R] keywords are present, the
result value of the \f[V]add\f[R] is a
\f[V]poison value <poisonvalues>\f[R] if unsigned and/or signed
overflow, respectively, occurs.
.SS Example:
.IP
.nf
\f[C]
<result> = add i32 4, %var          ; yields i32:result = 4 + %var
\f[R]
.fi
.SS \[aq]\f[V]fadd\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fadd [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fadd\f[R]\[aq] instruction returns the sum of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]fadd\f[R]\[aq] instruction must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the floating-point sum of the two operands.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = fadd float 4.0, %var          ; yields float:result = 4.0 + %var
\f[R]
.fi
.SS \[aq]\f[V]sub\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = sub <ty> <op1>, <op2>          ; yields ty:result
<result> = sub nuw <ty> <op1>, <op2>      ; yields ty:result
<result> = sub nsw <ty> <op1>, <op2>      ; yields ty:result
<result> = sub nuw nsw <ty> <op1>, <op2>  ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]sub\f[R]\[aq] instruction returns the difference of its
two operands.
.PP
Note that the \[aq]\f[V]sub\f[R]\[aq] instruction is used to represent
the \[aq]\f[V]neg\f[R]\[aq] instruction present in most other
intermediate representations.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]sub\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the integer difference of the two operands.
.PP
If the difference has unsigned overflow, the result returned is the
mathematical result modulo 2^n^, where n is the bit width of the result.
.PP
Because LLVM integers use a two\[aq]s complement representation, this
instruction is appropriate for both signed and unsigned integers.
.PP
\f[V]nuw\f[R] and \f[V]nsw\f[R] stand for \[dq]No Unsigned Wrap\[dq] and
\[dq]No Signed Wrap\[dq], respectively.
If the \f[V]nuw\f[R] and/or \f[V]nsw\f[R] keywords are present, the
result value of the \f[V]sub\f[R] is a
\f[V]poison value <poisonvalues>\f[R] if unsigned and/or signed
overflow, respectively, occurs.
.SS Example:
.IP
.nf
\f[C]
<result> = sub i32 4, %var          ; yields i32:result = 4 - %var
<result> = sub i32 0, %val          ; yields i32:result = -%var
\f[R]
.fi
.SS \[aq]\f[V]fsub\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fsub [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fsub\f[R]\[aq] instruction returns the difference of its
two operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]fsub\f[R]\[aq] instruction must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the floating-point difference of the two operands.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = fsub float 4.0, %var           ; yields float:result = 4.0 - %var
<result> = fsub float -0.0, %val          ; yields float:result = -%var
\f[R]
.fi
.SS \[aq]\f[V]mul\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = mul <ty> <op1>, <op2>          ; yields ty:result
<result> = mul nuw <ty> <op1>, <op2>      ; yields ty:result
<result> = mul nsw <ty> <op1>, <op2>      ; yields ty:result
<result> = mul nuw nsw <ty> <op1>, <op2>  ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]mul\f[R]\[aq] instruction returns the product of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]mul\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the integer product of the two operands.
.PP
If the result of the multiplication has unsigned overflow, the result
returned is the mathematical result modulo 2^n^, where n is the bit
width of the result.
.PP
Because LLVM integers use a two\[aq]s complement representation, and the
result is the same width as the operands, this instruction returns the
correct result for both signed and unsigned integers.
If a full product (e.g.
\f[V]i32\f[R] * \f[V]i32\f[R] -> \f[V]i64\f[R]) is needed, the operands
should be sign-extended or zero-extended as appropriate to the width of
the full product.
.PP
\f[V]nuw\f[R] and \f[V]nsw\f[R] stand for \[dq]No Unsigned Wrap\[dq] and
\[dq]No Signed Wrap\[dq], respectively.
If the \f[V]nuw\f[R] and/or \f[V]nsw\f[R] keywords are present, the
result value of the \f[V]mul\f[R] is a
\f[V]poison value <poisonvalues>\f[R] if unsigned and/or signed
overflow, respectively, occurs.
.SS Example:
.IP
.nf
\f[C]
<result> = mul i32 4, %var          ; yields i32:result = 4 * %var
\f[R]
.fi
.SS \[aq]\f[V]fmul\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fmul [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fmul\f[R]\[aq] instruction returns the product of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]fmul\f[R]\[aq] instruction must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the floating-point product of the two operands.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = fmul float 4.0, %var          ; yields float:result = 4.0 * %var
\f[R]
.fi
.SS \[aq]\f[V]udiv\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = udiv <ty> <op1>, <op2>         ; yields ty:result
<result> = udiv exact <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]udiv\f[R]\[aq] instruction returns the quotient of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]udiv\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the unsigned integer quotient of the two operands.
.PP
Note that unsigned integer division and signed integer division are
distinct operations; for signed integer division, use
\[aq]\f[V]sdiv\f[R]\[aq].
.PP
Division by zero is undefined behavior.
For vectors, if any element of the divisor is zero, the operation has
undefined behavior.
.PP
If the \f[V]exact\f[R] keyword is present, the result value of the
\f[V]udiv\f[R] is a \f[V]poison value <poisonvalues>\f[R] if %op1 is not
a multiple of %op2 (as such, \[dq]((a udiv exact b) mul b) == a\[dq]).
.SS Example:
.IP
.nf
\f[C]
<result> = udiv i32 4, %var          ; yields i32:result = 4 / %var
\f[R]
.fi
.SS \[aq]\f[V]sdiv\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = sdiv <ty> <op1>, <op2>         ; yields ty:result
<result> = sdiv exact <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]sdiv\f[R]\[aq] instruction returns the quotient of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]sdiv\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the signed integer quotient of the two operands
rounded towards zero.
.PP
Note that signed integer division and unsigned integer division are
distinct operations; for unsigned integer division, use
\[aq]\f[V]udiv\f[R]\[aq].
.PP
Division by zero is undefined behavior.
For vectors, if any element of the divisor is zero, the operation has
undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can
occur, for example, by doing a 32-bit division of -2147483648 by -1.
.PP
If the \f[V]exact\f[R] keyword is present, the result value of the
\f[V]sdiv\f[R] is a \f[V]poison value <poisonvalues>\f[R] if the result
would be rounded.
.SS Example:
.IP
.nf
\f[C]
<result> = sdiv i32 4, %var          ; yields i32:result = 4 / %var
\f[R]
.fi
.SS \[aq]\f[V]fdiv\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fdiv [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fdiv\f[R]\[aq] instruction returns the quotient of its two
operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]fdiv\f[R]\[aq] instruction must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the floating-point quotient of the two operands.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var
\f[R]
.fi
.SS \[aq]\f[V]urem\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = urem <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]urem\f[R]\[aq] instruction returns the remainder from the
unsigned division of its two arguments.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]urem\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
This instruction returns the unsigned integer \f[I]remainder\f[R] of a
division.
This instruction always performs an unsigned division to get the
remainder.
.PP
Note that unsigned integer remainder and signed integer remainder are
distinct operations; for signed integer remainder, use
\[aq]\f[V]srem\f[R]\[aq].
.PP
Taking the remainder of a division by zero is undefined behavior.
For vectors, if any element of the divisor is zero, the operation has
undefined behavior.
.SS Example:
.IP
.nf
\f[C]
<result> = urem i32 4, %var          ; yields i32:result = 4 % %var
\f[R]
.fi
.SS \[aq]\f[V]srem\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = srem <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]srem\f[R]\[aq] instruction returns the remainder from the
signed division of its two operands.
This instruction can also take \f[V]vector <t_vector>\f[R] versions of
the values in which case the elements must be integers.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]srem\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
This instruction returns the \f[I]remainder\f[R] of a division (where
the result is either zero or has the same sign as the dividend,
\f[V]op1\f[R]), not the \f[I]modulo\f[R] operator (where the result is
either zero or has the same sign as the divisor, \f[V]op2\f[R]) of a
value.
For more information about the difference, see The Math
Forum (http://mathforum.org/dr.math/problems/anne.4.28.99.html).
For a table of how this is implemented in various languages, please see
Wikipedia: modulo
operation (http://en.wikipedia.org/wiki/Modulo_operation).
.PP
Note that signed integer remainder and unsigned integer remainder are
distinct operations; for unsigned integer remainder, use
\[aq]\f[V]urem\f[R]\[aq].
.PP
Taking the remainder of a division by zero is undefined behavior.
For vectors, if any element of the divisor is zero, the operation has
undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can
occur, for example, by taking the remainder of a 32-bit division of
-2147483648 by -1.
(The remainder doesn\[aq]t actually overflow, but this rule lets srem be
implemented using instructions that return both the result of the
division and the remainder.)
.SS Example:
.IP
.nf
\f[C]
<result> = srem i32 4, %var          ; yields i32:result = 4 % %var
\f[R]
.fi
.SS \[aq]\f[V]frem\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = frem [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]frem\f[R]\[aq] instruction returns the remainder from the
division of its two operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]frem\f[R]\[aq] instruction must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.SS Semantics:
.PP
The value produced is the floating-point remainder of the two operands.
This is the same output as a libm \[aq]\f[V]fmod\f[R]\[aq] function, but
without any possibility of setting \f[V]errno\f[R].
The remainder has the same sign as the dividend.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
This instruction can also take any number of \f[V]fast-math
flags <fastmath>\f[R], which are optimization hints to enable otherwise
unsafe floating-point optimizations:
.SS Example:
.IP
.nf
\f[C]
<result> = frem float 4.0, %var          ; yields float:result = 4.0 % %var
\f[R]
.fi
.SS Bitwise Binary Operations
.PP
Bitwise binary operators are used to do various forms of bit-twiddling
in a program.
They are generally very efficient instructions and can commonly be
strength reduced from other instructions.
They require two operands of the same type, execute an operation on
them, and produce a single value.
The resulting value is the same type as its operands.
.SS \[aq]\f[V]shl\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = shl <ty> <op1>, <op2>           ; yields ty:result
<result> = shl nuw <ty> <op1>, <op2>       ; yields ty:result
<result> = shl nsw <ty> <op1>, <op2>       ; yields ty:result
<result> = shl nuw nsw <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]shl\f[R]\[aq] instruction returns the first operand
shifted to the left a specified number of bits.
.SS Arguments:
.PP
Both arguments to the \[aq]\f[V]shl\f[R]\[aq] instruction must be the
same \f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of
integer type.
\[aq]\f[V]op2\f[R]\[aq] is treated as an unsigned value.
.SS Semantics:
.PP
The value produced is \f[V]op1\f[R] * 2^op2^ mod 2^n^, where \f[V]n\f[R]
is the width of the result.
If \f[V]op2\f[R] is (statically or dynamically) equal to or larger than
the number of bits in \f[V]op1\f[R], this instruction returns a
\f[V]poison value <poisonvalues>\f[R].
If the arguments are vectors, each vector element of \f[V]op1\f[R] is
shifted by the corresponding shift amount in \f[V]op2\f[R].
.PP
If the \f[V]nuw\f[R] keyword is present, then the shift produces a
poison value if it shifts out any non-zero bits.
If the \f[V]nsw\f[R] keyword is present, then the shift produces a
poison value if it shifts out any bits that disagree with the resultant
sign bit.
.SS Example:
.IP
.nf
\f[C]
<result> = shl i32 4, %var   ; yields i32: 4 << %var
<result> = shl i32 4, 2      ; yields i32: 16
<result> = shl i32 1, 10     ; yields i32: 1024
<result> = shl i32 1, 32     ; undefined
<result> = shl <2 x i32> < i32 1, i32 1>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 2, i32 4>
\f[R]
.fi
.SS \[aq]\f[V]lshr\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = lshr <ty> <op1>, <op2>         ; yields ty:result
<result> = lshr exact <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]lshr\f[R]\[aq] instruction (logical shift right) returns
the first operand shifted to the right a specified number of bits with
zero fill.
.SS Arguments:
.PP
Both arguments to the \[aq]\f[V]lshr\f[R]\[aq] instruction must be the
same \f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of
integer type.
\[aq]\f[V]op2\f[R]\[aq] is treated as an unsigned value.
.SS Semantics:
.PP
This instruction always performs a logical shift right operation.
The most significant bits of the result will be filled with zero bits
after the shift.
If \f[V]op2\f[R] is (statically or dynamically) equal to or larger than
the number of bits in \f[V]op1\f[R], this instruction returns a
\f[V]poison
value <poisonvalues>\f[R].
If the arguments are vectors, each vector element of \f[V]op1\f[R] is
shifted by the corresponding shift amount in \f[V]op2\f[R].
.PP
If the \f[V]exact\f[R] keyword is present, the result value of the
\f[V]lshr\f[R] is a poison value if any of the bits shifted out are
non-zero.
.SS Example:
.IP
.nf
\f[C]
<result> = lshr i32 4, 1   ; yields i32:result = 2
<result> = lshr i32 4, 2   ; yields i32:result = 1
<result> = lshr i8  4, 3   ; yields i8:result = 0
<result> = lshr i8 -2, 1   ; yields i8:result = 0x7F
<result> = lshr i32 1, 32  ; undefined
<result> = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>
\f[R]
.fi
.SS \[aq]\f[V]ashr\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = ashr <ty> <op1>, <op2>         ; yields ty:result
<result> = ashr exact <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]ashr\f[R]\[aq] instruction (arithmetic shift right)
returns the first operand shifted to the right a specified number of
bits with sign extension.
.SS Arguments:
.PP
Both arguments to the \[aq]\f[V]ashr\f[R]\[aq] instruction must be the
same \f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of
integer type.
\[aq]\f[V]op2\f[R]\[aq] is treated as an unsigned value.
.SS Semantics:
.PP
This instruction always performs an arithmetic shift right operation,
The most significant bits of the result will be filled with the sign bit
of \f[V]op1\f[R].
If \f[V]op2\f[R] is (statically or dynamically) equal to or larger than
the number of bits in \f[V]op1\f[R], this instruction returns a
\f[V]poison
value <poisonvalues>\f[R].
If the arguments are vectors, each vector element of \f[V]op1\f[R] is
shifted by the corresponding shift amount in \f[V]op2\f[R].
.PP
If the \f[V]exact\f[R] keyword is present, the result value of the
\f[V]ashr\f[R] is a poison value if any of the bits shifted out are
non-zero.
.SS Example:
.IP
.nf
\f[C]
<result> = ashr i32 4, 1   ; yields i32:result = 2
<result> = ashr i32 4, 2   ; yields i32:result = 1
<result> = ashr i8  4, 3   ; yields i8:result = 0
<result> = ashr i8 -2, 1   ; yields i8:result = -1
<result> = ashr i32 1, 32  ; undefined
<result> = ashr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 3>   ; yields: result=<2 x i32> < i32 -1, i32 0>
\f[R]
.fi
.SS \[aq]\f[V]and\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = and <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]and\f[R]\[aq] instruction returns the bitwise logical and
of its two operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]and\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The truth table used for the \[aq]\f[V]and\f[R]\[aq] instruction is:
.PP
.TS
tab(@);
lw(5.8n) lw(5.8n) lw(5.8n).
T{
In0
T}@T{
In1
T}@T{
Out
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
0
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}
.TE
.SS Example:
.IP
.nf
\f[C]
<result> = and i32 4, %var         ; yields i32:result = 4 & %var
<result> = and i32 15, 40          ; yields i32:result = 8
<result> = and i32 4, 8            ; yields i32:result = 0
\f[R]
.fi
.SS \[aq]\f[V]or\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = or <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]or\f[R]\[aq] instruction returns the bitwise logical
inclusive or of its two operands.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]or\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The truth table used for the \[aq]\f[V]or\f[R]\[aq] instruction is:
.PP
.TS
tab(@);
lw(5.8n) lw(5.8n) lw(5.8n).
T{
In0
T}@T{
In1
T}@T{
Out
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
1
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}
.TE
.SS Example:
.IP
.nf
\f[C]
<result> = or i32 4, %var         ; yields i32:result = 4 | %var
<result> = or i32 15, 40          ; yields i32:result = 47
<result> = or i32 4, 8            ; yields i32:result = 12
\f[R]
.fi
.SS \[aq]\f[V]xor\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = xor <ty> <op1>, <op2>   ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]xor\f[R]\[aq] instruction returns the bitwise logical
exclusive or of its two operands.
The \f[V]xor\f[R] is used to implement the \[dq]one\[aq]s
complement\[dq] operation, which is the \[dq]\[ti]\[dq] operator in C.
.SS Arguments:
.PP
The two arguments to the \[aq]\f[V]xor\f[R]\[aq] instruction must be
\f[V]integer <t_integer>\f[R] or \f[V]vector <t_vector>\f[R] of integer
values.
Both arguments must have identical types.
.SS Semantics:
.PP
The truth table used for the \[aq]\f[V]xor\f[R]\[aq] instruction is:
.PP
.TS
tab(@);
lw(5.8n) lw(5.8n) lw(5.8n).
T{
In0
T}@T{
In1
T}@T{
Out
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
0
.RE
T}
T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
0
.RE
T}@T{
.RS
.PP
1
.RE
T}
T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
1
.RE
T}@T{
.RS
.PP
0
.RE
T}
.TE
.SS Example:
.IP
.nf
\f[C]
<result> = xor i32 4, %var         ; yields i32:result = 4 \[ha] %var
<result> = xor i32 15, 40          ; yields i32:result = 39
<result> = xor i32 4, 8            ; yields i32:result = 12
<result> = xor i32 %V, -1          ; yields i32:result = \[ti]%V
\f[R]
.fi
.SS Vector Operations
.PP
LLVM supports several instructions to represent vector operations in a
target-independent manner.
These instructions cover the element-access and vector-specific
operations needed to process vectors effectively.
While LLVM does directly support these vector operations, many
sophisticated algorithms will want to use target-specific intrinsics to
take full advantage of a specific target.
.SS \[aq]\f[V]extractelement\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = extractelement <n x <ty>> <val>, <ty2> <idx>  ; yields <ty>
<result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]extractelement\f[R]\[aq] instruction extracts a single
scalar element from a vector at a specified index.
.SS Arguments:
.PP
The first operand of an \[aq]\f[V]extractelement\f[R]\[aq] instruction
is a value of \f[V]vector <t_vector>\f[R] type.
The second operand is an index indicating the position from which to
extract the element.
The index may be a variable of any integer type.
.SS Semantics:
.PP
The result is a scalar of the same type as the element type of
\f[V]val\f[R].
Its value is the value at position \f[V]idx\f[R] of \f[V]val\f[R].
If \f[V]idx\f[R] exceeds the length of \f[V]val\f[R] for a fixed-length
vector, the result is a \f[V]poison value <poisonvalues>\f[R].
For a scalable vector, if the value of \f[V]idx\f[R] exceeds the runtime
length of the vector, the result is a
\f[V]poison value <poisonvalues>\f[R].
.SS Example:
.IP
.nf
\f[C]
<result> = extractelement <4 x i32> %vec, i32 0    ; yields i32
\f[R]
.fi
.SS \[aq]\f[V]insertelement\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx>    ; yields <n x <ty>>
<result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]insertelement\f[R]\[aq] instruction inserts a scalar
element into a vector at a specified index.
.SS Arguments:
.PP
The first operand of an \[aq]\f[V]insertelement\f[R]\[aq] instruction is
a value of \f[V]vector <t_vector>\f[R] type.
The second operand is a scalar value whose type must equal the element
type of the first operand.
The third operand is an index indicating the position at which to insert
the value.
The index may be a variable of any integer type.
.SS Semantics:
.PP
The result is a vector of the same type as \f[V]val\f[R].
Its element values are those of \f[V]val\f[R] except at position
\f[V]idx\f[R], where it gets the value \f[V]elt\f[R].
If \f[V]idx\f[R] exceeds the length of \f[V]val\f[R] for a fixed-length
vector, the result is a \f[V]poison value <poisonvalues>\f[R].
For a scalable vector, if the value of \f[V]idx\f[R] exceeds the runtime
length of the vector, the result is a
\f[V]poison value <poisonvalues>\f[R].
.SS Example:
.IP
.nf
\f[C]
<result> = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>
\f[R]
.fi
.SS \[aq]\f[V]shufflevector\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask>    ; yields <m x <ty>>
<result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask>  ; yields <vscale x m x <ty>>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]shufflevector\f[R]\[aq] instruction constructs a
permutation of elements from two input vectors, returning a vector with
the same element type as the input and length that is the same as the
shuffle mask.
.SS Arguments:
.PP
The first two operands of a \[aq]\f[V]shufflevector\f[R]\[aq]
instruction are vectors with the same type.
The third argument is a shuffle mask vector constant whose element type
is \f[V]i32\f[R].
The mask vector elements must be constant integers or \f[V]undef\f[R]
values.
The result of the instruction is a vector whose length is the same as
the shuffle mask and whose element type is the same as the element type
of the first two operands.
.SS Semantics:
.PP
The elements of the two input vectors are numbered from left to right
across both of the vectors.
For each element of the result vector, the shuffle mask selects an
element from one of the input vectors to copy to the result.
Non-negative elements in the mask represent an index into the
concatenated pair of input vectors.
.PP
If the shuffle mask is undefined, the result vector is undefined.
If the shuffle mask selects an undefined element from one of the input
vectors, the resulting element is undefined.
An undefined element in the mask vector specifies that the resulting
element is undefined.
An undefined element in the mask vector prevents a poisoned vector
element from propagating.
.PP
For scalable vectors, the only valid mask values at present are
\f[V]zeroinitializer\f[R] and \f[V]undef\f[R], since we cannot write all
indices as literals for a vector with a length unknown at compile time.
.SS Example:
.IP
.nf
\f[C]
<result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,
                        <4 x i32> <i32 0, i32 4, i32 1, i32 5>  ; yields <4 x i32>
<result> = shufflevector <4 x i32> %v1, <4 x i32> undef,
                        <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32> - Identity shuffle.
<result> = shufflevector <8 x i32> %v1, <8 x i32> undef,
                        <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32>
<result> = shufflevector <4 x i32> %v1, <4 x i32> %v2,
                        <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >  ; yields <8 x i32>
\f[R]
.fi
.SS Aggregate Operations
.PP
LLVM supports several instructions for working with
\f[V]aggregate <t_aggregate>\f[R] values.
.SS \[aq]\f[V]extractvalue\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = extractvalue <aggregate type> <val>, <idx>{, <idx>}*
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]extractvalue\f[R]\[aq] instruction extracts the value of a
member field from an \f[V]aggregate <t_aggregate>\f[R] value.
.SS Arguments:
.PP
The first operand of an \[aq]\f[V]extractvalue\f[R]\[aq] instruction is
a value of \f[V]struct <t_struct>\f[R] or \f[V]array <t_array>\f[R]
type.
The other operands are constant indices to specify which value to
extract in a similar manner as indices in a
\[aq]\f[V]getelementptr\f[R]\[aq] instruction.
.PP
The major differences to \f[V]getelementptr\f[R] indexing are:
.IP \[bu] 2
Since the value being indexed is not a pointer, the first index is
omitted and assumed to be zero.
.IP \[bu] 2
At least one index must be specified.
.IP \[bu] 2
Not only struct indices but also array indices must be in bounds.
.SS Semantics:
.PP
The result is the value at the position in the aggregate specified by
the index operands.
.SS Example:
.IP
.nf
\f[C]
<result> = extractvalue {i32, float} %agg, 0    ; yields i32
\f[R]
.fi
.SS \[aq]\f[V]insertvalue\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = insertvalue <aggregate type> <val>, <ty> <elt>, <idx>{, <idx>}*    ; yields <aggregate type>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]insertvalue\f[R]\[aq] instruction inserts a value into a
member field in an \f[V]aggregate <t_aggregate>\f[R] value.
.SS Arguments:
.PP
The first operand of an \[aq]\f[V]insertvalue\f[R]\[aq] instruction is a
value of \f[V]struct <t_struct>\f[R] or \f[V]array <t_array>\f[R] type.
The second operand is a first-class value to insert.
The following operands are constant indices indicating the position at
which to insert the value in a similar manner as indices in a
\[aq]\f[V]extractvalue\f[R]\[aq] instruction.
The value to insert must have the same type as the value identified by
the indices.
.SS Semantics:
.PP
The result is an aggregate of the same type as \f[V]val\f[R].
Its value is that of \f[V]val\f[R] except that the value at the position
specified by the indices is that of \f[V]elt\f[R].
.SS Example:
.IP
.nf
\f[C]
%agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}
%agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}
%agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0    ; yields {i32 undef, {float %val}}
\f[R]
.fi
.SS Memory Access and Addressing Operations
.PP
A key design point of an SSA-based representation is how it represents
memory.
In LLVM, no memory locations are in SSA form, which makes things very
simple.
This section describes how to read, write, and allocate memory in LLVM.
.SS \[aq]\f[V]alloca\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = alloca [inalloca] <type> [, <ty> <NumElements>] [, align <alignment>] [, addrspace(<num>)]     ; yields type addrspace(num)*:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]alloca\f[R]\[aq] instruction allocates memory on the stack
frame of the currently executing function, to be automatically released
when this function returns to its caller.
If the address space is not explicitly specified, the object is
allocated in the alloca address space from the
\f[V]datalayout string<langref_datalayout>\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]alloca\f[R]\[aq] instruction allocates
\f[V]sizeof(<type>)*NumElements\f[R] bytes of memory on the runtime
stack, returning a pointer of the appropriate type to the program.
If \[dq]NumElements\[dq] is specified, it is the number of elements
allocated, otherwise \[dq]NumElements\[dq] is defaulted to be one.
If a constant alignment is specified, the value result of the allocation
is guaranteed to be aligned to at least that boundary.
The alignment may not be greater than \f[V]1 << 32\f[R].
If not specified, or if zero, the target can choose to align the
allocation on any convenient boundary compatible with the type.
.PP
\[aq]\f[V]type\f[R]\[aq] may be any sized type.
.SS Semantics:
.PP
Memory is allocated; a pointer is returned.
The allocated memory is uninitialized, and loading from uninitialized
memory produces an undefined value.
The operation itself is undefined if there is insufficient stack space
for the allocation.\[aq]\f[V]alloca\f[R]\[aq]d memory is automatically
released when the function returns.
The \[aq]\f[V]alloca\f[R]\[aq] instruction is commonly used to represent
automatic variables that must have an address available.
When the function returns (either with the \f[V]ret\f[R] or
\f[V]resume\f[R] instructions), the memory is reclaimed.
Allocating zero bytes is legal, but the returned pointer may not be
unique.
The order in which memory is allocated (ie., which way the stack grows)
is not specified.
.PP
Note that \[aq]\f[V]alloca\f[R]\[aq] outside of the alloca address space
from the \f[V]datalayout string<langref_datalayout>\f[R] is meaningful
only if the target has assigned it a semantics.
.PP
If the returned pointer is used by
\f[V]llvm.lifetime.start <int_lifestart>\f[R], the returned object is
initially dead.
See \f[V]llvm.lifetime.start <int_lifestart>\f[R] and
\f[V]llvm.lifetime.end <int_lifeend>\f[R] for the precise semantics of
lifetime-manipulating intrinsics.
.SS Example:
.IP
.nf
\f[C]
%ptr = alloca i32                             ; yields i32*:ptr
%ptr = alloca i32, i32 4                      ; yields i32*:ptr
%ptr = alloca i32, i32 4, align 1024          ; yields i32*:ptr
%ptr = alloca i32, align 1024                 ; yields i32*:ptr
\f[R]
.fi
.SS \[aq]\f[V]load\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = load [volatile] <ty>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.load !<empty_node>][, !invariant.group !<empty_node>][, !nonnull !<empty_node>][, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>][, !align !<align_node>][, !noundef !<empty_node>]
<result> = load atomic [volatile] <ty>, <ty>* <pointer> [syncscope(\[dq]<target-scope>\[dq])] <ordering>, align <alignment> [, !invariant.group !<empty_node>]
!<nontemp_node> = !{ i32 1 }
!<empty_node> = !{}
!<deref_bytes_node> = !{ i64 <dereferenceable_bytes> }
!<align_node> = !{ i64 <value_alignment> }
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]load\f[R]\[aq] instruction is used to read from memory.
.SS Arguments:
.PP
The argument to the \f[V]load\f[R] instruction specifies the memory
address from which to load.
The type specified must be a \f[V]first class <t_firstclass>\f[R] type
of known size (i.e.
not containing an \f[V]opaque structural type <t_opaque>\f[R]).
If the \f[V]load\f[R] is marked as \f[V]volatile\f[R], then the
optimizer is not allowed to modify the number or order of execution of
this \f[V]load\f[R] with other \f[V]volatile operations <volatile>\f[R].
.PP
If the \f[V]load\f[R] is marked as \f[V]atomic\f[R], it takes an extra
\f[V]ordering
<ordering>\f[R] and optional
\f[V]syncscope(\[dq]<target-scope>\[dq])\f[R] argument.
The \f[V]release\f[R] and \f[V]acq_rel\f[R] orderings are not valid on
\f[V]load\f[R] instructions.
Atomic loads produce \f[V]defined <memmodel>\f[R] results when they may
see multiple atomic stores.
The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight
and less than or equal to a target-specific size limit.
\f[V]align\f[R] must be explicitly specified on atomic loads, and the
load has undefined behavior if the alignment is not set to a value which
is at least the size in bytes of the pointee.
\f[V]!nontemporal\f[R] does not have any defined semantics for atomic
loads.
.PP
The optional constant \f[V]align\f[R] argument specifies the alignment
of the operation (that is, the alignment of the memory address).
A value of 0 or an omitted \f[V]align\f[R] argument means that the
operation has the ABI alignment for the target.
It is the responsibility of the code emitter to ensure that the
alignment information is correct.
Overestimating the alignment results in undefined behavior.
Underestimating the alignment may produce less efficient code.
An alignment of 1 is always safe.
The maximum possible alignment is \f[V]1 << 32\f[R].
An alignment value higher than the size of the loaded type implies
memory up to the alignment value bytes can be safely loaded without
trapping in the default address space.
Access of the high bytes can interfere with debugging tools, so should
not be accessed if the function has the \f[V]sanitize_thread\f[R] or
\f[V]sanitize_address\f[R] attributes.
.PP
The optional \f[V]!nontemporal\f[R] metadata must reference a single
metadata name \f[V]<nontemp_node>\f[R] corresponding to a metadata node
with one \f[V]i32\f[R] entry of value 1.
The existence of the \f[V]!nontemporal\f[R] metadata on the instruction
tells the optimizer and code generator that this load is not expected to
be reused in the cache.
The code generator may select special instructions to save cache
bandwidth, such as the \f[V]MOVNT\f[R] instruction on x86.
.PP
The optional \f[V]!invariant.load\f[R] metadata must reference a single
metadata name \f[V]<empty_node>\f[R] corresponding to a metadata node
with no entries.
If a load instruction tagged with the \f[V]!invariant.load\f[R] metadata
is executed, the memory location referenced by the load has to contain
the same value at all points in the program where the memory location is
dereferenceable; otherwise, the behavior is undefined.
.TP
The optional \f[V]!invariant.group\f[R] metadata must reference a single metadata name
\f[V]<empty_node>\f[R] corresponding to a metadata node with no entries.
See \f[V]invariant.group\f[R] metadata
\f[V]invariant.group <md_invariant.group>\f[R].
.PP
The optional \f[V]!nonnull\f[R] metadata must reference a single
metadata name \f[V]<empty_node>\f[R] corresponding to a metadata node
with no entries.
The existence of the \f[V]!nonnull\f[R] metadata on the instruction
tells the optimizer that the value loaded is known to never be null.
If the value is null at runtime, the behavior is undefined.
This is analogous to the \f[V]nonnull\f[R] attribute on parameters and
return values.
This metadata can only be applied to loads of a pointer type.
.PP
The optional \f[V]!dereferenceable\f[R] metadata must reference a single
metadata name \f[V]<deref_bytes_node>\f[R] corresponding to a metadata
node with one \f[V]i64\f[R] entry.
See \f[V]dereferenceable\f[R] metadata
\f[V]dereferenceable <md_dereferenceable>\f[R].
.PP
The optional \f[V]!dereferenceable_or_null\f[R] metadata must reference
a single metadata name \f[V]<deref_bytes_node>\f[R] corresponding to a
metadata node with one \f[V]i64\f[R] entry.
See \f[V]dereferenceable_or_null\f[R] metadata
\f[V]dereferenceable_or_null
<md_dereferenceable_or_null>\f[R].
.PP
The optional \f[V]!align\f[R] metadata must reference a single metadata
name \f[V]<align_node>\f[R] corresponding to a metadata node with one
\f[V]i64\f[R] entry.
The existence of the \f[V]!align\f[R] metadata on the instruction tells
the optimizer that the value loaded is known to be aligned to a boundary
specified by the integer value in the metadata node.
The alignment must be a power of 2.
This is analogous to the \[aq]\[aq]align\[aq]\[aq] attribute on
parameters and return values.
This metadata can only be applied to loads of a pointer type.
If the returned value is not appropriately aligned at runtime, the
behavior is undefined.
.PP
The optional \f[V]!noundef\f[R] metadata must reference a single
metadata name \f[V]<empty_node>\f[R] corresponding to a node with no
entries.
The existence of \f[V]!noundef\f[R] metadata on the instruction tells
the optimizer that the value loaded is known to be
\f[V]well defined <welldefinedvalues>\f[R].
If the value isn\[aq]t well defined, the behavior is undefined.
.SS Semantics:
.PP
The location of memory pointed to is loaded.
If the value being loaded is of scalar type then the number of bytes
read does not exceed the minimum number of bytes needed to hold all bits
of the type.
For example, loading an \f[V]i24\f[R] reads at most three bytes.
When loading a value of a type like \f[V]i20\f[R] with a size that is
not an integral number of bytes, the result is undefined if the value
was not originally written using a store of the same type.
If the value being loaded is of aggregate type, the bytes that
correspond to padding may be accessed but are ignored, because it is
impossible to observe padding from the loaded aggregate value.
If \f[V]<pointer>\f[R] is not a well-defined value, the behavior is
undefined.
.SS Examples:
.IP
.nf
\f[C]
%ptr = alloca i32                               ; yields i32*:ptr
store i32 3, i32* %ptr                          ; yields void
%val = load i32, i32* %ptr                      ; yields i32:val = i32 3
\f[R]
.fi
.SS \[aq]\f[V]store\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
store [volatile] <ty> <value>, <ty>* <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>]        ; yields void
store atomic [volatile] <ty> <value>, <ty>* <pointer> [syncscope(\[dq]<target-scope>\[dq])] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void
!<nontemp_node> = !{ i32 1 }
!<empty_node> = !{}
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]store\f[R]\[aq] instruction is used to write to memory.
.SS Arguments:
.PP
There are two arguments to the \f[V]store\f[R] instruction: a value to
store and an address at which to store it.
The type of the \f[V]<pointer>\f[R] operand must be a pointer to the
\f[V]first class <t_firstclass>\f[R] type of the \f[V]<value>\f[R]
operand.
If the \f[V]store\f[R] is marked as \f[V]volatile\f[R], then the
optimizer is not allowed to modify the number or order of execution of
this \f[V]store\f[R] with other
\f[V]volatile operations <volatile>\f[R].
Only values of \f[V]first class
<t_firstclass>\f[R] types of known size (i.e.
not containing an \f[V]opaque
structural type <t_opaque>\f[R]) can be stored.
.PP
If the \f[V]store\f[R] is marked as \f[V]atomic\f[R], it takes an extra
\f[V]ordering
<ordering>\f[R] and optional
\f[V]syncscope(\[dq]<target-scope>\[dq])\f[R] argument.
The \f[V]acquire\f[R] and \f[V]acq_rel\f[R] orderings aren\[aq]t valid
on \f[V]store\f[R] instructions.
Atomic loads produce \f[V]defined <memmodel>\f[R] results when they may
see multiple atomic stores.
The type of the pointee must be an integer, pointer, or floating-point
type whose bit width is a power of two greater than or equal to eight
and less than or equal to a target-specific size limit.
\f[V]align\f[R] must be explicitly specified on atomic stores, and the
store has undefined behavior if the alignment is not set to a value
which is at least the size in bytes of the pointee.
\f[V]!nontemporal\f[R] does not have any defined semantics for atomic
stores.
.PP
The optional constant \f[V]align\f[R] argument specifies the alignment
of the operation (that is, the alignment of the memory address).
A value of 0 or an omitted \f[V]align\f[R] argument means that the
operation has the ABI alignment for the target.
It is the responsibility of the code emitter to ensure that the
alignment information is correct.
Overestimating the alignment results in undefined behavior.
Underestimating the alignment may produce less efficient code.
An alignment of 1 is always safe.
The maximum possible alignment is \f[V]1 << 32\f[R].
An alignment value higher than the size of the stored type implies
memory up to the alignment value bytes can be stored to without trapping
in the default address space.
Storing to the higher bytes however may result in data races if another
thread can access the same address.
Introducing a data race is not allowed.
Storing to the extra bytes is not allowed even in situations where a
data race is known to not exist if the function has the
\f[V]sanitize_address\f[R] attribute.
.PP
The optional \f[V]!nontemporal\f[R] metadata must reference a single
metadata name \f[V]<nontemp_node>\f[R] corresponding to a metadata node
with one \f[V]i32\f[R] entry of value 1.
The existence of the \f[V]!nontemporal\f[R] metadata on the instruction
tells the optimizer and code generator that this load is not expected to
be reused in the cache.
The code generator may select special instructions to save cache
bandwidth, such as the \f[V]MOVNT\f[R] instruction on x86.
.PP
The optional \f[V]!invariant.group\f[R] metadata must reference a single
metadata name \f[V]<empty_node>\f[R].
See \f[V]invariant.group\f[R] metadata.
.SS Semantics:
.PP
The contents of memory are updated to contain \f[V]<value>\f[R] at the
location specified by the \f[V]<pointer>\f[R] operand.
If \f[V]<value>\f[R] is of scalar type then the number of bytes written
does not exceed the minimum number of bytes needed to hold all bits of
the type.
For example, storing an \f[V]i24\f[R] writes at most three bytes.
When writing a value of a type like \f[V]i20\f[R] with a size that is
not an integral number of bytes, it is unspecified what happens to the
extra bits that do not belong to the type, but they will typically be
overwritten.
If \f[V]<value>\f[R] is of aggregate type, padding is filled with
\f[V]undef <undefvalues>\f[R].
If \f[V]<pointer>\f[R] is not a well-defined value, the behavior is
undefined.
.SS Example:
.IP
.nf
\f[C]
%ptr = alloca i32                               ; yields i32*:ptr
store i32 3, i32* %ptr                          ; yields void
%val = load i32, i32* %ptr                      ; yields i32:val = i32 3
\f[R]
.fi
.SS \[aq]\f[V]fence\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
fence [syncscope(\[dq]<target-scope>\[dq])] <ordering>  ; yields void
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fence\f[R]\[aq] instruction is used to introduce
happens-before edges between operations.
.SS Arguments:
.PP
\[aq]\f[V]fence\f[R]\[aq] instructions take an
\f[V]ordering <ordering>\f[R] argument which defines what
\f[I]synchronizes-with\f[R] edges they add.
They can only be given \f[V]acquire\f[R], \f[V]release\f[R],
\f[V]acq_rel\f[R], and \f[V]seq_cst\f[R] orderings.
.SS Semantics:
.PP
A fence A which has (at least) \f[V]release\f[R] ordering semantics
\f[I]synchronizes with\f[R] a fence B with (at least) \f[V]acquire\f[R]
ordering semantics if and only if there exist atomic operations X and Y,
both operating on some atomic object M, such that A is sequenced before
X, X modifies M (either directly or through some side effect of a
sequence headed by X), Y is sequenced before B, and Y observes M.
This provides a \f[I]happens-before\f[R] dependency between A and B.
Rather than an explicit \f[V]fence\f[R], one (but not both) of the
atomic operations X or Y might provide a \f[V]release\f[R] or
\f[V]acquire\f[R] (resp.)
ordering constraint and still \f[I]synchronize-with\f[R] the explicit
\f[V]fence\f[R] and establish the \f[I]happens-before\f[R] edge.
.PP
A \f[V]fence\f[R] which has \f[V]seq_cst\f[R] ordering, in addition to
having both \f[V]acquire\f[R] and \f[V]release\f[R] semantics specified
above, participates in the global program order of other
\f[V]seq_cst\f[R] operations and/or fences.
.PP
A \f[V]fence\f[R] instruction can also take an optional
\[dq]\f[V]syncscope <syncscope>\f[R]\[dq] argument.
.SS Example:
.IP
.nf
\f[C]
fence acquire                                        ; yields void
fence syncscope(\[dq]singlethread\[dq]) seq_cst              ; yields void
fence syncscope(\[dq]agent\[dq]) seq_cst                     ; yields void
\f[R]
.fi
.SS \[aq]\f[V]cmpxchg\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
cmpxchg [weak] [volatile] <ty>* <pointer>, <ty> <cmp>, <ty> <new> [syncscope(\[dq]<target-scope>\[dq])] <success ordering> <failure ordering>[, align <alignment>] ; yields  { ty, i1 }
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]cmpxchg\f[R]\[aq] instruction is used to atomically modify
memory.
It loads a value in memory and compares it to a given value.
If they are equal, it tries to store a new value into the memory.
.SS Arguments:
.PP
There are three arguments to the \[aq]\f[V]cmpxchg\f[R]\[aq]
instruction: an address to operate on, a value to compare to the value
currently be at that address, and a new value to place at that address
if the compared values are equal.
The type of \[aq]<cmp>\[aq] must be an integer or pointer type whose bit
width is a power of two greater than or equal to eight and less than or
equal to a target-specific size limit.
\[aq]<cmp>\[aq] and \[aq]<new>\[aq] must have the same type, and the
type of \[aq]<pointer>\[aq] must be a pointer to that type.
If the \f[V]cmpxchg\f[R] is marked as \f[V]volatile\f[R], then the
optimizer is not allowed to modify the number or order of execution of
this \f[V]cmpxchg\f[R] with other
\f[V]volatile operations <volatile>\f[R].
.PP
The success and failure \f[V]ordering <ordering>\f[R] arguments specify
how this \f[V]cmpxchg\f[R] synchronizes with other atomic operations.
Both ordering parameters must be at least \f[V]monotonic\f[R], the
failure ordering cannot be either \f[V]release\f[R] or
\f[V]acq_rel\f[R].
.PP
A \f[V]cmpxchg\f[R] instruction can also take an optional
\[dq]\f[V]syncscope <syncscope>\f[R]\[dq] argument.
.PP
The instruction can take an optional \f[V]align\f[R] attribute.
The alignment must be a power of two greater or equal to the size of the
<value> type.
If unspecified, the alignment is assumed to be equal to the size of the
\[aq]<value>\[aq] type.
Note that this default alignment assumption is different from the
alignment used for the load/store instructions when align isn\[aq]t
specified.
.PP
The pointer passed into cmpxchg must have alignment greater than or
equal to the size in memory of the operand.
.SS Semantics:
.PP
The contents of memory at the location specified by the
\[aq]\f[V]<pointer>\f[R]\[aq] operand is read and compared to
\[aq]\f[V]<cmp>\f[R]\[aq]; if the values are equal,
\[aq]\f[V]<new>\f[R]\[aq] is written to the location.
The original value at the location is returned, together with a flag
indicating success (true) or failure (false).
.PP
If the cmpxchg operation is marked as \f[V]weak\f[R] then a spurious
failure is permitted: the operation may not write \f[V]<new>\f[R] even
if the comparison matched.
.PP
If the cmpxchg operation is strong (the default), the i1 value is 1 if
and only if the value loaded equals \f[V]cmp\f[R].
.PP
A successful \f[V]cmpxchg\f[R] is a read-modify-write instruction for
the purpose of identifying release sequences.
A failed \f[V]cmpxchg\f[R] is equivalent to an atomic load with an
ordering parameter determined the second ordering parameter.
.SS Example:
.IP
.nf
\f[C]
entry:
  %orig = load atomic i32, i32* %ptr unordered, align 4                      ; yields i32
  br label %loop

loop:
  %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]
  %squared = mul i32 %cmp, %cmp
  %val_success = cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }
  %value_loaded = extractvalue { i32, i1 } %val_success, 0
  %success = extractvalue { i32, i1 } %val_success, 1
  br i1 %success, label %done, label %loop

done:
  ...
\f[R]
.fi
.SS \[aq]\f[V]atomicrmw\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
atomicrmw [volatile] <operation> <ty>* <pointer>, <ty> <value> [syncscope(\[dq]<target-scope>\[dq])] <ordering>[, align <alignment>]  ; yields ty
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]atomicrmw\f[R]\[aq] instruction is used to atomically
modify memory.
.SS Arguments:
.PP
There are three arguments to the \[aq]\f[V]atomicrmw\f[R]\[aq]
instruction: an operation to apply, an address whose value to modify, an
argument to the operation.
The operation must be one of the following keywords:
.IP \[bu] 2
xchg
.IP \[bu] 2
add
.IP \[bu] 2
sub
.IP \[bu] 2
and
.IP \[bu] 2
nand
.IP \[bu] 2
or
.IP \[bu] 2
xor
.IP \[bu] 2
max
.IP \[bu] 2
min
.IP \[bu] 2
umax
.IP \[bu] 2
umin
.IP \[bu] 2
fadd
.IP \[bu] 2
fsub
.IP \[bu] 2
fmax
.IP \[bu] 2
fmin
.PP
For most of these operations, the type of \[aq]<value>\[aq] must be an
integer type whose bit width is a power of two greater than or equal to
eight and less than or equal to a target-specific size limit.
For xchg, this may also be a floating point or a pointer type with the
same size constraints as integers.
For fadd/fsub/fmax/fmin, this must be a floating point type.
The type of the \[aq]\f[V]<pointer>\f[R]\[aq] operand must be a pointer
to that type.
If the \f[V]atomicrmw\f[R] is marked as \f[V]volatile\f[R], then the
optimizer is not allowed to modify the number or order of execution of
this \f[V]atomicrmw\f[R] with other
\f[V]volatile operations <volatile>\f[R].
.PP
The instruction can take an optional \f[V]align\f[R] attribute.
The alignment must be a power of two greater or equal to the size of the
<value> type.
If unspecified, the alignment is assumed to be equal to the size of the
\[aq]<value>\[aq] type.
Note that this default alignment assumption is different from the
alignment used for the load/store instructions when align isn\[aq]t
specified.
.PP
A \f[V]atomicrmw\f[R] instruction can also take an optional
\[dq]\f[V]syncscope <syncscope>\f[R]\[dq] argument.
.SS Semantics:
.PP
The contents of memory at the location specified by the
\[aq]\f[V]<pointer>\f[R]\[aq] operand are atomically read, modified, and
written back.
The original value at the location is returned.
The modification is specified by the operation argument:
.IP \[bu] 2
xchg: \f[V]*ptr = val\f[R]
.IP \[bu] 2
add: \f[V]*ptr = *ptr + val\f[R]
.IP \[bu] 2
sub: \f[V]*ptr = *ptr - val\f[R]
.IP \[bu] 2
and: \f[V]*ptr = *ptr & val\f[R]
.IP \[bu] 2
nand: \f[V]*ptr = \[ti](*ptr & val)\f[R]
.IP \[bu] 2
or: \f[V]*ptr = *ptr | val\f[R]
.IP \[bu] 2
xor: \f[V]*ptr = *ptr \[ha] val\f[R]
.IP \[bu] 2
max: \f[V]*ptr = *ptr > val ? *ptr : val\f[R] (using a signed
comparison)
.IP \[bu] 2
min: \f[V]*ptr = *ptr < val ? *ptr : val\f[R] (using a signed
comparison)
.IP \[bu] 2
umax: \f[V]*ptr = *ptr > val ? *ptr : val\f[R] (using an unsigned
comparison)
.IP \[bu] 2
umin: \f[V]*ptr = *ptr < val ? *ptr : val\f[R] (using an unsigned
comparison)
.IP \[bu] 2
fadd: \f[V]*ptr = *ptr + val\f[R] (using floating point arithmetic)
.IP \[bu] 2
fsub: \f[V]*ptr = *ptr - val\f[R] (using floating point arithmetic)
.IP \[bu] 2
fmax: \f[V]*ptr = maxnum(*ptr, val)\f[R] (match the llvm.maxnum.*\[ga]
intrinsic)
.IP \[bu] 2
fmin: \f[V]*ptr = minnum(*ptr, val)\f[R] (match the llvm.minnum.*\[ga]
intrinsic)
.SS Example:
.IP
.nf
\f[C]
%old = atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32
\f[R]
.fi
.SS \[aq]\f[V]getelementptr\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = getelementptr <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
<result> = getelementptr inbounds <ty>, <ty>* <ptrval>{, [inrange] <ty> <idx>}*
<result> = getelementptr <ty>, <ptr vector> <ptrval>, [inrange] <vector index type> <idx>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]getelementptr\f[R]\[aq] instruction is used to get the
address of a subelement of an \f[V]aggregate <t_aggregate>\f[R] data
structure.
It performs address calculation only and does not access memory.
The instruction can also be used to calculate a vector of such
addresses.
.SS Arguments:
.PP
The first argument is always a type used as the basis for the
calculations.
The second argument is always a pointer or a vector of pointers, and is
the base address to start from.
The remaining arguments are indices that indicate which of the elements
of the aggregate object are indexed.
The interpretation of each index is dependent on the type being indexed
into.
The first index always indexes the pointer value given as the second
argument, the second index indexes a value of the type pointed to (not
necessarily the value directly pointed to, since the first index can be
non-zero), etc.
The first type indexed into must be a pointer value, subsequent types
can be arrays, vectors, and structs.
Note that subsequent types being indexed into can never be pointers,
since that would require loading the pointer before continuing
calculation.
.PP
The type of each index argument depends on the type it is indexing into.
When indexing into a (optionally packed) structure, only \f[V]i32\f[R]
integer \f[B]constants\f[R] are allowed (when using a vector of indices
they must all be the \f[B]same\f[R] \f[V]i32\f[R] integer constant).
When indexing into an array, pointer or vector, integers of any width
are allowed, and they are not required to be constant.
These integers are treated as signed values where relevant.
.PP
For example, let\[aq]s consider a C code fragment and how it gets
compiled to LLVM:
.IP
.nf
\f[C]
struct RT {
  char A;
  int B[10][20];
  char C;
};
struct ST {
  int X;
  double Y;
  struct RT Z;
};

int *foo(struct ST *s) {
  return &s[1].Z.B[5][13];
}
\f[R]
.fi
.PP
The LLVM code generated by Clang is:
.IP
.nf
\f[C]
%struct.RT = type { i8, [10 x [20 x i32]], i8 }
%struct.ST = type { i32, double, %struct.RT }

define i32* \[at]foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {
entry:
  %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13
  ret i32* %arrayidx
}
\f[R]
.fi
.SS Semantics:
.PP
In the example above, the first index is indexing into the
\[aq]\f[V]%struct.ST*\f[R]\[aq] type, which is a pointer, yielding a
\[aq]\f[V]%struct.ST\f[R]\[aq] =
\[aq]\f[V]{ i32, double, %struct.RT }\f[R]\[aq] type, a structure.
The second index indexes into the third element of the structure,
yielding a \[aq]\f[V]%struct.RT\f[R]\[aq] =
\[aq]\f[V]{ i8 , [10 x [20 x i32]], i8 }\f[R]\[aq] type, another
structure.
The third index indexes into the second element of the structure,
yielding a \[aq]\f[V][10 x [20 x i32]]\f[R]\[aq] type, an array.
The two dimensions of the array are subscripted into, yielding an
\[aq]\f[V]i32\f[R]\[aq] type.
The \[aq]\f[V]getelementptr\f[R]\[aq] instruction returns a pointer to
this element, thus computing a value of \[aq]\f[V]i32*\f[R]\[aq] type.
.PP
Note that it is perfectly legal to index partially through a structure,
returning a pointer to an inner element.
Because of this, the LLVM code for the given testcase is equivalent to:
.IP
.nf
\f[C]
define i32* \[at]foo(%struct.ST* %s) {
  %t1 = getelementptr %struct.ST, %struct.ST* %s, i32 1                        ; yields %struct.ST*:%t1
  %t2 = getelementptr %struct.ST, %struct.ST* %t1, i32 0, i32 2                ; yields %struct.RT*:%t2
  %t3 = getelementptr %struct.RT, %struct.RT* %t2, i32 0, i32 1                ; yields [10 x [20 x i32]]*:%t3
  %t4 = getelementptr [10 x [20 x i32]], [10 x [20 x i32]]* %t3, i32 0, i32 5  ; yields [20 x i32]*:%t4
  %t5 = getelementptr [20 x i32], [20 x i32]* %t4, i32 0, i32 13               ; yields i32*:%t5
  ret i32* %t5
}
\f[R]
.fi
.PP
If the \f[V]inbounds\f[R] keyword is present, the result value of the
\f[V]getelementptr\f[R] is a \f[V]poison value <poisonvalues>\f[R] if
one of the following rules is violated:
.IP \[bu] 2
The base pointer has an \f[I]in bounds\f[R] address of an allocated
object, which means that it points into an allocated object, or to its
end.
The only \f[I]in bounds\f[R] address for a null pointer in the default
address-space is the null pointer itself.
.IP \[bu] 2
If the type of an index is larger than the pointer index type, the
truncation to the pointer index type preserves the signed value.
.IP \[bu] 2
The multiplication of an index by the type size does not wrap the
pointer index type in a signed sense (\f[V]nsw\f[R]).
.IP \[bu] 2
The successive addition of offsets (without adding the base address)
does not wrap the pointer index type in a signed sense (\f[V]nsw\f[R]).
.IP \[bu] 2
The successive addition of the current address, interpreted as an
unsigned number, and an offset, interpreted as a signed number, does not
wrap the unsigned address space and remains \f[I]in bounds\f[R] of the
allocated object.
As a corollary, if the added offset is non-negative, the addition does
not wrap in an unsigned sense (\f[V]nuw\f[R]).
.IP \[bu] 2
In cases where the base is a vector of pointers, the \f[V]inbounds\f[R]
keyword applies to each of the computations element-wise.
.PP
These rules are based on the assumption that no allocated object may
cross the unsigned address space boundary, and no allocated object may
be larger than half the pointer index type space.
.PP
If the \f[V]inbounds\f[R] keyword is not present, the offsets are added
to the base address with silently-wrapping two\[aq]s complement
arithmetic.
If the offsets have a different width from the pointer, they are
sign-extended or truncated to the width of the pointer.
The result value of the \f[V]getelementptr\f[R] may be outside the
object pointed to by the base pointer.
The result value may not necessarily be used to access memory though,
even if it happens to point into allocated storage.
See the \f[V]Pointer Aliasing Rules <pointeraliasing>\f[R] section for
more information.
.PP
If the \f[V]inrange\f[R] keyword is present before any index, loading
from or storing to any pointer derived from the \f[V]getelementptr\f[R]
has undefined behavior if the load or store would access memory outside
of the bounds of the element selected by the index marked as
\f[V]inrange\f[R].
The result of a pointer comparison or \f[V]ptrtoint\f[R] (including
\f[V]ptrtoint\f[R]-like operations involving memory) involving a pointer
derived from a \f[V]getelementptr\f[R] with the \f[V]inrange\f[R]
keyword is undefined, with the exception of comparisons in the case
where both operands are in the range of the element selected by the
\f[V]inrange\f[R] keyword, inclusive of the address one past the end of
that element.
Note that the \f[V]inrange\f[R] keyword is currently only allowed in
constant \f[V]getelementptr\f[R] expressions.
.PP
The getelementptr instruction is often confusing.
For some more insight into how it works, see
\f[V]the getelementptr FAQ <GetElementPtr>\f[R].
.SS Example:
.IP
.nf
\f[C]
; yields [12 x i8]*:aptr
%aptr = getelementptr {i32, [12 x i8]}, {i32, [12 x i8]}* %saptr, i64 0, i32 1
; yields i8*:vptr
%vptr = getelementptr {i32, <2 x i8>}, {i32, <2 x i8>}* %svptr, i64 0, i32 1, i32 1
; yields i8*:eptr
%eptr = getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1
; yields i32*:iptr
%iptr = getelementptr [10 x i32], [10 x i32]* \[at]arr, i16 0, i16 0
\f[R]
.fi
.SS Vector of pointers:
.PP
The \f[V]getelementptr\f[R] returns a vector of pointers, instead of a
single address, when one or more of its arguments is a vector.
In such cases, all vector arguments should have the same number of
elements, and every scalar argument will be effectively broadcast into a
vector during address calculation.
.IP
.nf
\f[C]
; All arguments are vectors:
;   A[i] = ptrs[i] + offsets[i]*sizeof(i8)
%A = getelementptr i8, <4 x i8*> %ptrs, <4 x i64> %offsets

; Add the same scalar offset to each pointer of a vector:
;   A[i] = ptrs[i] + offset*sizeof(i8)
%A = getelementptr i8, <4 x i8*> %ptrs, i64 %offset

; Add distinct offsets to the same pointer:
;   A[i] = ptr + offsets[i]*sizeof(i8)
%A = getelementptr i8, i8* %ptr, <4 x i64> %offsets

; In all cases described above the type of the result is <4 x i8*>
\f[R]
.fi
.PP
The two following instructions are equivalent:
.IP
.nf
\f[C]
getelementptr  %struct.ST, <4 x %struct.ST*> %s, <4 x i64> %ind1,
  <4 x i32> <i32 2, i32 2, i32 2, i32 2>,
  <4 x i32> <i32 1, i32 1, i32 1, i32 1>,
  <4 x i32> %ind4,
  <4 x i64> <i64 13, i64 13, i64 13, i64 13>

getelementptr  %struct.ST, <4 x %struct.ST*> %s, <4 x i64> %ind1,
  i32 2, i32 1, <4 x i32> %ind4, i64 13
\f[R]
.fi
.PP
Let\[aq]s look at the C code, where the vector version of
\f[V]getelementptr\f[R] makes sense:
.IP
.nf
\f[C]
// Let\[aq]s assume that we vectorize the following loop:
double *A, *B; int *C;
for (int i = 0; i < size; ++i) {
  A[i] = B[C[i]];
}
\f[R]
.fi
.IP
.nf
\f[C]
; get pointers for 8 elements from array B
%ptrs = getelementptr double, double* %B, <8 x i32> %C
; load 8 elements from array B into A
%A = call <8 x double> \[at]llvm.masked.gather.v8f64.v8p0f64(<8 x double*> %ptrs,
     i32 8, <8 x i1> %mask, <8 x double> %passthru)
\f[R]
.fi
.SS Conversion Operations
.PP
The instructions in this category are the conversion instructions
(casting) which all take a single operand and a type.
They perform various bit conversions on the operand.
.SS \[aq]\f[V]trunc .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = trunc <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]trunc\f[R]\[aq] instruction truncates its operand to the
type \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]trunc\f[R]\[aq] instruction takes a value to trunc, and a
type to trunc it to.
Both types must be of \f[V]integer <t_integer>\f[R] types, or vectors of
the same number of integers.
The bit size of the \f[V]value\f[R] must be larger than the bit size of
the destination type, \f[V]ty2\f[R].
Equal sized types are not allowed.
.SS Semantics:
.PP
The \[aq]\f[V]trunc\f[R]\[aq] instruction truncates the high order bits
in \f[V]value\f[R] and converts the remaining bits to \f[V]ty2\f[R].
Since the source size must be larger than the destination size,
\f[V]trunc\f[R] cannot be a \f[I]no-op cast\f[R].
It will always truncate bits.
.SS Example:
.IP
.nf
\f[C]
%X = trunc i32 257 to i8                        ; yields i8:1
%Y = trunc i32 123 to i1                        ; yields i1:true
%Z = trunc i32 122 to i1                        ; yields i1:false
%W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>
\f[R]
.fi
.SS \[aq]\f[V]zext .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = zext <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]zext\f[R]\[aq] instruction zero extends its operand to
type \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]zext\f[R]\[aq] instruction takes a value to cast, and a
type to cast it to.
Both types must be of \f[V]integer <t_integer>\f[R] types, or vectors of
the same number of integers.
The bit size of the \f[V]value\f[R] must be smaller than the bit size of
the destination type, \f[V]ty2\f[R].
.SS Semantics:
.PP
The \f[V]zext\f[R] fills the high order bits of the \f[V]value\f[R] with
zero bits until it reaches the size of the destination type,
\f[V]ty2\f[R].
.PP
When zero extending from i1, the result will always be either 0 or 1.
.SS Example:
.IP
.nf
\f[C]
%X = zext i32 257 to i64              ; yields i64:257
%Y = zext i1 true to i32              ; yields i32:1
%Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>
\f[R]
.fi
.SS \[aq]\f[V]sext .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = sext <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]sext\f[R]\[aq] sign extends \f[V]value\f[R] to the type
\f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]sext\f[R]\[aq] instruction takes a value to cast, and a
type to cast it to.
Both types must be of \f[V]integer <t_integer>\f[R] types, or vectors of
the same number of integers.
The bit size of the \f[V]value\f[R] must be smaller than the bit size of
the destination type, \f[V]ty2\f[R].
.SS Semantics:
.PP
The \[aq]\f[V]sext\f[R]\[aq] instruction performs a sign extension by
copying the sign bit (highest order bit) of the \f[V]value\f[R] until it
reaches the bit size of the type \f[V]ty2\f[R].
.PP
When sign extending from i1, the extension always results in -1 or 0.
.SS Example:
.IP
.nf
\f[C]
%X = sext i8  -1 to i16              ; yields i16   :65535
%Y = sext i1 true to i32             ; yields i32:-1
%Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>
\f[R]
.fi
.SS \[aq]\f[V]fptrunc .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fptrunc <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fptrunc\f[R]\[aq] instruction truncates \f[V]value\f[R] to
type \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]fptrunc\f[R]\[aq] instruction takes a
\f[V]floating-point <t_floating>\f[R] value to cast and a
\f[V]floating-point <t_floating>\f[R] type to cast it to.
The size of \f[V]value\f[R] must be larger than the size of
\f[V]ty2\f[R].
This implies that \f[V]fptrunc\f[R] cannot be used to make a \f[I]no-op
cast\f[R].
.SS Semantics:
.PP
The \[aq]\f[V]fptrunc\f[R]\[aq] instruction casts a \f[V]value\f[R] from
a larger \f[V]floating-point <t_floating>\f[R] type to a smaller
\f[V]floating-point
<t_floating>\f[R] type.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
.SS Example:
.IP
.nf
\f[C]
%X = fptrunc double 16777217.0 to float    ; yields float:16777216.0
%Y = fptrunc double 1.0E+300 to half       ; yields half:+infinity
\f[R]
.fi
.SS \[aq]\f[V]fpext .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fpext <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fpext\f[R]\[aq] extends a floating-point \f[V]value\f[R]
to a larger floating-point value.
.SS Arguments:
.PP
The \[aq]\f[V]fpext\f[R]\[aq] instruction takes a
\f[V]floating-point <t_floating>\f[R] \f[V]value\f[R] to cast, and a
\f[V]floating-point <t_floating>\f[R] type to cast it to.
The source type must be smaller than the destination type.
.SS Semantics:
.PP
The \[aq]\f[V]fpext\f[R]\[aq] instruction extends the \f[V]value\f[R]
from a smaller \f[V]floating-point <t_floating>\f[R] type to a larger
\f[V]floating-point
<t_floating>\f[R] type.
The \f[V]fpext\f[R] cannot be used to make a \f[I]no-op cast\f[R]
because it always changes bits.
Use \f[V]bitcast\f[R] to make a \f[I]no-op cast\f[R] for a
floating-point cast.
.SS Example:
.IP
.nf
\f[C]
%X = fpext float 3.125 to double         ; yields double:3.125000e+00
%Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000
\f[R]
.fi
.SS \[aq]\f[V]fptoui .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fptoui <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fptoui\f[R]\[aq] converts a floating-point \f[V]value\f[R]
to its unsigned integer equivalent of type \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]fptoui\f[R]\[aq] instruction takes a value to cast, which
must be a scalar or vector \f[V]floating-point <t_floating>\f[R] value,
and a type to cast it to \f[V]ty2\f[R], which must be an
\f[V]integer <t_integer>\f[R] type.
If \f[V]ty\f[R] is a vector floating-point type, \f[V]ty2\f[R] must be a
vector integer type with the same number of elements as \f[V]ty\f[R]
.SS Semantics:
.PP
The \[aq]\f[V]fptoui\f[R]\[aq] instruction converts its
\f[V]floating-point
<t_floating>\f[R] operand into the nearest (rounding towards zero)
unsigned integer value.
If the value cannot fit in \f[V]ty2\f[R], the result is a
\f[V]poison value <poisonvalues>\f[R].
.SS Example:
.IP
.nf
\f[C]
%X = fptoui double 123.0 to i32      ; yields i32:123
%Y = fptoui float 1.0E+300 to i1     ; yields undefined:1
%Z = fptoui float 1.04E+17 to i8     ; yields undefined:1
\f[R]
.fi
.SS \[aq]\f[V]fptosi .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fptosi <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fptosi\f[R]\[aq] instruction converts
\f[V]floating-point <t_floating>\f[R] \f[V]value\f[R] to type
\f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]fptosi\f[R]\[aq] instruction takes a value to cast, which
must be a scalar or vector \f[V]floating-point <t_floating>\f[R] value,
and a type to cast it to \f[V]ty2\f[R], which must be an
\f[V]integer <t_integer>\f[R] type.
If \f[V]ty\f[R] is a vector floating-point type, \f[V]ty2\f[R] must be a
vector integer type with the same number of elements as \f[V]ty\f[R]
.SS Semantics:
.PP
The \[aq]\f[V]fptosi\f[R]\[aq] instruction converts its
\f[V]floating-point
<t_floating>\f[R] operand into the nearest (rounding towards zero)
signed integer value.
If the value cannot fit in \f[V]ty2\f[R], the result is a
\f[V]poison value <poisonvalues>\f[R].
.SS Example:
.IP
.nf
\f[C]
%X = fptosi double -123.0 to i32      ; yields i32:-123
%Y = fptosi float 1.0E-247 to i1      ; yields undefined:1
%Z = fptosi float 1.04E+17 to i8      ; yields undefined:1
\f[R]
.fi
.SS \[aq]\f[V]uitofp .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = uitofp <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]uitofp\f[R]\[aq] instruction regards \f[V]value\f[R] as an
unsigned integer and converts that value to the \f[V]ty2\f[R] type.
.SS Arguments:
.PP
The \[aq]\f[V]uitofp\f[R]\[aq] instruction takes a value to cast, which
must be a scalar or vector \f[V]integer <t_integer>\f[R] value, and a
type to cast it to \f[V]ty2\f[R], which must be an
\f[V]floating-point <t_floating>\f[R] type.
If \f[V]ty\f[R] is a vector integer type, \f[V]ty2\f[R] must be a vector
floating-point type with the same number of elements as \f[V]ty\f[R]
.SS Semantics:
.PP
The \[aq]\f[V]uitofp\f[R]\[aq] instruction interprets its operand as an
unsigned integer quantity and converts it to the corresponding
floating-point value.
If the value cannot be exactly represented, it is rounded using the
default rounding mode.
.SS Example:
.IP
.nf
\f[C]
%X = uitofp i32 257 to float         ; yields float:257.0
%Y = uitofp i8 -1 to double          ; yields double:255.0
\f[R]
.fi
.SS \[aq]\f[V]sitofp .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = sitofp <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]sitofp\f[R]\[aq] instruction regards \f[V]value\f[R] as a
signed integer and converts that value to the \f[V]ty2\f[R] type.
.SS Arguments:
.PP
The \[aq]\f[V]sitofp\f[R]\[aq] instruction takes a value to cast, which
must be a scalar or vector \f[V]integer <t_integer>\f[R] value, and a
type to cast it to \f[V]ty2\f[R], which must be an
\f[V]floating-point <t_floating>\f[R] type.
If \f[V]ty\f[R] is a vector integer type, \f[V]ty2\f[R] must be a vector
floating-point type with the same number of elements as \f[V]ty\f[R]
.SS Semantics:
.PP
The \[aq]\f[V]sitofp\f[R]\[aq] instruction interprets its operand as a
signed integer quantity and converts it to the corresponding
floating-point value.
If the value cannot be exactly represented, it is rounded using the
default rounding mode.
.SS Example:
.IP
.nf
\f[C]
%X = sitofp i32 257 to float         ; yields float:257.0
%Y = sitofp i8 -1 to double          ; yields double:-1.0
\f[R]
.fi
.SS \[aq]\f[V]ptrtoint .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = ptrtoint <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]ptrtoint\f[R]\[aq] instruction converts the pointer or a
vector of pointers \f[V]value\f[R] to the integer (or vector of
integers) type \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]ptrtoint\f[R]\[aq] instruction takes a \f[V]value\f[R] to
cast, which must be a value of type \f[V]pointer <t_pointer>\f[R] or a
vector of pointers, and a type to cast it to \f[V]ty2\f[R], which must
be an \f[V]integer <t_integer>\f[R] or a vector of integers type.
.SS Semantics:
.PP
The \[aq]\f[V]ptrtoint\f[R]\[aq] instruction converts \f[V]value\f[R] to
integer type \f[V]ty2\f[R] by interpreting the pointer value as an
integer and either truncating or zero extending that value to the size
of the integer type.
If \f[V]value\f[R] is smaller than \f[V]ty2\f[R] then a zero extension
is done.
If \f[V]value\f[R] is larger than \f[V]ty2\f[R] then a truncation is
done.
If they are the same size, then nothing is done (\f[I]no-op cast\f[R])
other than a type change.
.SS Example:
.IP
.nf
\f[C]
%X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture
%Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture
%Z = ptrtoint <4 x i32*> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture
\f[R]
.fi
.SS \[aq]\f[V]inttoptr .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>]             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]inttoptr\f[R]\[aq] instruction converts an integer
\f[V]value\f[R] to a pointer type, \f[V]ty2\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]inttoptr\f[R]\[aq] instruction takes an
\f[V]integer <t_integer>\f[R] value to cast, and a type to cast it to,
which must be a \f[V]pointer <t_pointer>\f[R] type.
.PP
The optional \f[V]!dereferenceable\f[R] metadata must reference a single
metadata name \f[V]<deref_bytes_node>\f[R] corresponding to a metadata
node with one \f[V]i64\f[R] entry.
See \f[V]dereferenceable\f[R] metadata.
.PP
The optional \f[V]!dereferenceable_or_null\f[R] metadata must reference
a single metadata name \f[V]<deref_bytes_node>\f[R] corresponding to a
metadata node with one \f[V]i64\f[R] entry.
See \f[V]dereferenceable_or_null\f[R] metadata.
.SS Semantics:
.PP
The \[aq]\f[V]inttoptr\f[R]\[aq] instruction converts \f[V]value\f[R] to
type \f[V]ty2\f[R] by applying either a zero extension or a truncation
depending on the size of the integer \f[V]value\f[R].
If \f[V]value\f[R] is larger than the size of a pointer then a
truncation is done.
If \f[V]value\f[R] is smaller than the size of a pointer then a zero
extension is done.
If they are the same size, nothing is done (\f[I]no-op cast\f[R]).
.SS Example:
.IP
.nf
\f[C]
%X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture
%Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture
%Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture
%Z = inttoptr <4 x i32> %G to <4 x i8*>; yields truncation of vector G to four pointers
\f[R]
.fi
.SS \[aq]\f[V]bitcast .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = bitcast <ty> <value> to <ty2>             ; yields ty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]bitcast\f[R]\[aq] instruction converts \f[V]value\f[R] to
type \f[V]ty2\f[R] without changing any bits.
.SS Arguments:
.PP
The \[aq]\f[V]bitcast\f[R]\[aq] instruction takes a value to cast, which
must be a non-aggregate first class value, and a type to cast it to,
which must also be a non-aggregate \f[V]first class <t_firstclass>\f[R]
type.
The bit sizes of \f[V]value\f[R] and the destination type,
\f[V]ty2\f[R], must be identical.
If the source type is a pointer, the destination type must also be a
pointer of the same size.
This instruction supports bitwise conversion of vectors to integers and
to vectors of other types (as long as they have the same size).
.SS Semantics:
.PP
The \[aq]\f[V]bitcast\f[R]\[aq] instruction converts \f[V]value\f[R] to
type \f[V]ty2\f[R].
It is always a \f[I]no-op cast\f[R] because no bits change with this
conversion.
The conversion is done as if the \f[V]value\f[R] had been stored to
memory and read back as type \f[V]ty2\f[R].
Pointer (or vector of pointers) types may only be converted to other
pointer (or vector of pointers) types with the same address space
through this instruction.
To convert pointers to other types, use the
\f[V]inttoptr <i_inttoptr>\f[R] or \f[V]ptrtoint <i_ptrtoint>\f[R]
instructions first.
.PP
There is a caveat for bitcasts involving vector types in relation to
endianess.
For example \f[V]bitcast <2 x i8> <value> to i16\f[R] puts element zero
of the vector in the least significant bits of the i16 for little-endian
while element zero ends up in the most significant bits for big-endian.
.SS Example:
.IP
.nf
\f[C]
%X = bitcast i8 255 to i8          ; yields i8 :-1
%Y = bitcast i32* %x to i16*      ; yields i16*:%x
%Z = bitcast <2 x i32> %V to i64;  ; yields i64: %V (depends on endianess)
%Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>
\f[R]
.fi
.SS \[aq]\f[V]addrspacecast .. to\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = addrspacecast <pty> <ptrval> to <pty2>       ; yields pty2
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]addrspacecast\f[R]\[aq] instruction converts
\f[V]ptrval\f[R] from \f[V]pty\f[R] in address space \f[V]n\f[R] to type
\f[V]pty2\f[R] in address space \f[V]m\f[R].
.SS Arguments:
.PP
The \[aq]\f[V]addrspacecast\f[R]\[aq] instruction takes a pointer or
vector of pointer value to cast and a pointer type to cast it to, which
must have a different address space.
.SS Semantics:
.PP
The \[aq]\f[V]addrspacecast\f[R]\[aq] instruction converts the pointer
value \f[V]ptrval\f[R] to type \f[V]pty2\f[R].
It can be a \f[I]no-op cast\f[R] or a complex value modification,
depending on the target and the address space pair.
Pointer conversions within the same address space must be performed with
the \f[V]bitcast\f[R] instruction.
Note that if the address space conversion is legal then both result and
operand refer to the same memory location.
.SS Example:
.IP
.nf
\f[C]
%X = addrspacecast i32* %x to i32 addrspace(1)*    ; yields i32 addrspace(1)*:%x
%Y = addrspacecast i32 addrspace(1)* %y to i64 addrspace(2)*    ; yields i64 addrspace(2)*:%y
%Z = addrspacecast <4 x i32*> %z to <4 x float addrspace(3)*>   ; yields <4 x float addrspace(3)*>:%z
\f[R]
.fi
.SS Other Operations
.PP
The instructions in this category are the \[dq]miscellaneous\[dq]
instructions, which defy better classification.
.SS \[aq]\f[V]icmp\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = icmp <cond> <ty> <op1>, <op2>   ; yields i1 or <N x i1>:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]icmp\f[R]\[aq] instruction returns a boolean value or a
vector of boolean values based on comparison of its two integer, integer
vector, pointer, or pointer vector operands.
.SS Arguments:
.PP
The \[aq]\f[V]icmp\f[R]\[aq] instruction takes three operands.
The first operand is the condition code indicating the kind of
comparison to perform.
It is not a value, just a keyword.
The possible condition codes are:
.IP " 1." 4
\f[V]eq\f[R]: equal
.IP " 2." 4
\f[V]ne\f[R]: not equal
.IP " 3." 4
\f[V]ugt\f[R]: unsigned greater than
.IP " 4." 4
\f[V]uge\f[R]: unsigned greater or equal
.IP " 5." 4
\f[V]ult\f[R]: unsigned less than
.IP " 6." 4
\f[V]ule\f[R]: unsigned less or equal
.IP " 7." 4
\f[V]sgt\f[R]: signed greater than
.IP " 8." 4
\f[V]sge\f[R]: signed greater or equal
.IP " 9." 4
\f[V]slt\f[R]: signed less than
.IP "10." 4
\f[V]sle\f[R]: signed less or equal
.PP
The remaining two arguments must be \f[V]integer <t_integer>\f[R] or
\f[V]pointer <t_pointer>\f[R] or integer \f[V]vector <t_vector>\f[R]
typed.
They must also be identical types.
.SS Semantics:
.PP
The \[aq]\f[V]icmp\f[R]\[aq] compares \f[V]op1\f[R] and \f[V]op2\f[R]
according to the condition code given as \f[V]cond\f[R].
The comparison performed always yields either an
\f[V]i1 <t_integer>\f[R] or vector of \f[V]i1\f[R] result, as follows:
.IP " 1." 4
\f[V]eq\f[R]: yields \f[V]true\f[R] if the operands are equal,
\f[V]false\f[R] otherwise.
No sign interpretation is necessary or performed.
.IP " 2." 4
\f[V]ne\f[R]: yields \f[V]true\f[R] if the operands are unequal,
\f[V]false\f[R] otherwise.
No sign interpretation is necessary or performed.
.IP " 3." 4
\f[V]ugt\f[R]: interprets the operands as unsigned values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP " 4." 4
\f[V]uge\f[R]: interprets the operands as unsigned values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is greater than or equal to
\f[V]op2\f[R].
.IP " 5." 4
\f[V]ult\f[R]: interprets the operands as unsigned values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP " 6." 4
\f[V]ule\f[R]: interprets the operands as unsigned values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.IP " 7." 4
\f[V]sgt\f[R]: interprets the operands as signed values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP " 8." 4
\f[V]sge\f[R]: interprets the operands as signed values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is greater than or equal to
\f[V]op2\f[R].
.IP " 9." 4
\f[V]slt\f[R]: interprets the operands as signed values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP "10." 4
\f[V]sle\f[R]: interprets the operands as signed values and yields
\f[V]true\f[R] if \f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.PP
If the operands are \f[V]pointer <t_pointer>\f[R] typed, the pointer
values are compared as if they were integers.
.PP
If the operands are integer vectors, then they are compared element by
element.
The result is an \f[V]i1\f[R] vector with the same number of elements as
the values being compared.
Otherwise, the result is an \f[V]i1\f[R].
.SS Example:
.IP
.nf
\f[C]
<result> = icmp eq i32 4, 5          ; yields: result=false
<result> = icmp ne float* %X, %X     ; yields: result=false
<result> = icmp ult i16  4, 5        ; yields: result=true
<result> = icmp sgt i16  4, 5        ; yields: result=false
<result> = icmp ule i16 -4, 5        ; yields: result=false
<result> = icmp sge i16  4, 5        ; yields: result=false
\f[R]
.fi
.SS \[aq]\f[V]fcmp\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = fcmp [fast-math flags]* <cond> <ty> <op1>, <op2>     ; yields i1 or <N x i1>:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]fcmp\f[R]\[aq] instruction returns a boolean value or
vector of boolean values based on comparison of its operands.
.PP
If the operands are floating-point scalars, then the result type is a
boolean (\f[V]i1 <t_integer>\f[R]).
.PP
If the operands are floating-point vectors, then the result type is a
vector of boolean with the same number of elements as the operands being
compared.
.SS Arguments:
.PP
The \[aq]\f[V]fcmp\f[R]\[aq] instruction takes three operands.
The first operand is the condition code indicating the kind of
comparison to perform.
It is not a value, just a keyword.
The possible condition codes are:
.IP " 1." 4
\f[V]false\f[R]: no comparison, always returns false
.IP " 2." 4
\f[V]oeq\f[R]: ordered and equal
.IP " 3." 4
\f[V]ogt\f[R]: ordered and greater than
.IP " 4." 4
\f[V]oge\f[R]: ordered and greater than or equal
.IP " 5." 4
\f[V]olt\f[R]: ordered and less than
.IP " 6." 4
\f[V]ole\f[R]: ordered and less than or equal
.IP " 7." 4
\f[V]one\f[R]: ordered and not equal
.IP " 8." 4
\f[V]ord\f[R]: ordered (no nans)
.IP " 9." 4
\f[V]ueq\f[R]: unordered or equal
.IP "10." 4
\f[V]ugt\f[R]: unordered or greater than
.IP "11." 4
\f[V]uge\f[R]: unordered or greater than or equal
.IP "12." 4
\f[V]ult\f[R]: unordered or less than
.IP "13." 4
\f[V]ule\f[R]: unordered or less than or equal
.IP "14." 4
\f[V]une\f[R]: unordered or not equal
.IP "15." 4
\f[V]uno\f[R]: unordered (either nans)
.IP "16." 4
\f[V]true\f[R]: no comparison, always returns true
.PP
\f[I]Ordered\f[R] means that neither operand is a QNAN while
\f[I]unordered\f[R] means that either operand may be a QNAN.
.PP
Each of \f[V]val1\f[R] and \f[V]val2\f[R] arguments must be either a
\f[V]floating-point
<t_floating>\f[R] type or a \f[V]vector <t_vector>\f[R] of
floating-point type.
They must have identical types.
.SS Semantics:
.PP
The \[aq]\f[V]fcmp\f[R]\[aq] instruction compares \f[V]op1\f[R] and
\f[V]op2\f[R] according to the condition code given as \f[V]cond\f[R].
If the operands are vectors, then the vectors are compared element by
element.
Each comparison performed always yields an \f[V]i1 <t_integer>\f[R]
result, as follows:
.IP " 1." 4
\f[V]false\f[R]: always yields \f[V]false\f[R], regardless of operands.
.IP " 2." 4
\f[V]oeq\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is equal to \f[V]op2\f[R].
.IP " 3." 4
\f[V]ogt\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP " 4." 4
\f[V]oge\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is greater than or equal to \f[V]op2\f[R].
.IP " 5." 4
\f[V]olt\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP " 6." 4
\f[V]ole\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.IP " 7." 4
\f[V]one\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN and
\f[V]op1\f[R] is not equal to \f[V]op2\f[R].
.IP " 8." 4
\f[V]ord\f[R]: yields \f[V]true\f[R] if both operands are not a QNAN.
.IP " 9." 4
\f[V]ueq\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is equal to \f[V]op2\f[R].
.IP "10." 4
\f[V]ugt\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP "11." 4
\f[V]uge\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is greater than or equal to \f[V]op2\f[R].
.IP "12." 4
\f[V]ult\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP "13." 4
\f[V]ule\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.IP "14." 4
\f[V]une\f[R]: yields \f[V]true\f[R] if either operand is a QNAN or
\f[V]op1\f[R] is not equal to \f[V]op2\f[R].
.IP "15." 4
\f[V]uno\f[R]: yields \f[V]true\f[R] if either operand is a QNAN.
.IP "16." 4
\f[V]true\f[R]: always yields \f[V]true\f[R], regardless of operands.
.PP
The \f[V]fcmp\f[R] instruction can also optionally take any number of
\f[V]fast-math flags <fastmath>\f[R], which are optimization hints to
enable otherwise unsafe floating-point optimizations.
.PP
Any set of fast-math flags are legal on an \f[V]fcmp\f[R] instruction,
but the only flags that have any effect on its semantics are those that
allow assumptions to be made about the values of input arguments; namely
\f[V]nnan\f[R], \f[V]ninf\f[R], and \f[V]reassoc\f[R].
See \f[V]fastmath\f[R] for more information.
.SS Example:
.IP
.nf
\f[C]
<result> = fcmp oeq float 4.0, 5.0    ; yields: result=false
<result> = fcmp one float 4.0, 5.0    ; yields: result=true
<result> = fcmp olt float 4.0, 5.0    ; yields: result=true
<result> = fcmp ueq double 1.0, 2.0   ; yields: result=false
\f[R]
.fi
.SS \[aq]\f[V]phi\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = phi [fast-math-flags] <ty> [ <val0>, <label0>], ...
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]phi\f[R]\[aq] instruction is used to implement the \[+f]
node in the SSA graph representing the function.
.SS Arguments:
.PP
The type of the incoming values is specified with the first type field.
After this, the \[aq]\f[V]phi\f[R]\[aq] instruction takes a list of
pairs as arguments, with one pair for each predecessor basic block of
the current block.
Only values of \f[V]first class <t_firstclass>\f[R] type may be used as
the value arguments to the PHI node.
Only labels may be used as the label arguments.
.PP
There must be no non-phi instructions between the start of a basic block
and the PHI instructions: i.e.
PHI instructions must be first in a basic block.
.PP
For the purposes of the SSA form, the use of each incoming value is
deemed to occur on the edge from the corresponding predecessor block to
the current block (but after any definition of an
\[aq]\f[V]invoke\f[R]\[aq] instruction\[aq]s return value on the same
edge).
.PP
The optional \f[V]fast-math-flags\f[R] marker indicates that the phi has
one or more \f[V]fast-math-flags <fastmath>\f[R].
These are optimization hints to enable otherwise unsafe floating-point
optimizations.
Fast-math-flags are only valid for phis that return a floating-point
scalar or vector type, or an array (nested to any depth) of
floating-point scalar or vector types.
.SS Semantics:
.PP
At runtime, the \[aq]\f[V]phi\f[R]\[aq] instruction logically takes on
the value specified by the pair corresponding to the predecessor basic
block that executed just prior to the current block.
.SS Example:
.IP
.nf
\f[C]
Loop:       ; Infinite loop that counts from 0 on up...
  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
  %nextindvar = add i32 %indvar, 1
  br label %Loop
\f[R]
.fi
.SS \[aq]\f[V]select\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = select [fast-math flags] selty <cond>, <ty> <val1>, <ty> <val2>             ; yields ty

selty is either i1 or {<N x i1>}
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]select\f[R]\[aq] instruction is used to choose one value
based on a condition, without IR-level branching.
.SS Arguments:
.PP
The \[aq]\f[V]select\f[R]\[aq] instruction requires an \[aq]i1\[aq]
value or a vector of \[aq]i1\[aq] values indicating the condition, and
two values of the same \f[V]first
class <t_firstclass>\f[R] type.
.IP "1." 3
The optional \f[V]fast-math flags\f[R] marker indicates that the select
has one or more \f[V]fast-math flags <fastmath>\f[R].
These are optimization hints to enable otherwise unsafe floating-point
optimizations.
Fast-math flags are only valid for selects that return a floating-point
scalar or vector type, or an array (nested to any depth) of
floating-point scalar or vector types.
.SS Semantics:
.PP
If the condition is an i1 and it evaluates to 1, the instruction returns
the first value argument; otherwise, it returns the second value
argument.
.PP
If the condition is a vector of i1, then the value arguments must be
vectors of the same size, and the selection is done element by element.
.PP
If the condition is an i1 and the value arguments are vectors of the
same size, then an entire vector is selected.
.SS Example:
.IP
.nf
\f[C]
%X = select i1 true, i8 17, i8 42          ; yields i8:17
\f[R]
.fi
.SS \[aq]\f[V]freeze\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = freeze ty <val>    ; yields ty:result
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]freeze\f[R]\[aq] instruction is used to stop propagation
of \f[V]undef <undefvalues>\f[R] and \f[V]poison <poisonvalues>\f[R]
values.
.SS Arguments:
.PP
The \[aq]\f[V]freeze\f[R]\[aq] instruction takes a single argument.
.SS Semantics:
.PP
If the argument is \f[V]undef\f[R] or \f[V]poison\f[R],
\[aq]\f[V]freeze\f[R]\[aq] returns an arbitrary, but fixed, value of
type \[aq]\f[V]ty\f[R]\[aq].
Otherwise, this instruction is a no-op and returns the input argument.
All uses of a value returned by the same \[aq]\f[V]freeze\f[R]\[aq]
instruction are guaranteed to always observe the same value, while
different \[aq]\f[V]freeze\f[R]\[aq] instructions may yield different
values.
.PP
While \f[V]undef\f[R] and \f[V]poison\f[R] pointers can be frozen, the
result is a non-dereferenceable pointer.
See the \f[V]Pointer Aliasing Rules <pointeraliasing>\f[R] section for
more information.
If an aggregate value or vector is frozen, the operand is frozen
element-wise.
The padding of an aggregate isn\[aq]t considered, since it isn\[aq]t
visible without storing it into memory and loading it with a different
type.
.SS Example:
.IP
.nf
\f[C]
%w = i32 undef
%x = freeze i32 %w
%y = add i32 %w, %w         ; undef
%z = add i32 %x, %x         ; even number because all uses of %x observe
                            ; the same value
%x2 = freeze i32 %w
%cmp = icmp eq i32 %x, %x2  ; can be true or false

; example with vectors
%v = <2 x i32> <i32 undef, i32 poison>
%a = extractelement <2 x i32> %v, i32 0    ; undef
%b = extractelement <2 x i32> %v, i32 1    ; poison
%add = add i32 %a, %a                      ; undef

%v.fr = freeze <2 x i32> %v                ; element-wise freeze
%d = extractelement <2 x i32> %v.fr, i32 0 ; not undef
%add.f = add i32 %d, %d                    ; even number

; branching on frozen value
%poison = add nsw i1 %k, undef   ; poison
%c = freeze i1 %poison
br i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar
\f[R]
.fi
.SS \[aq]\f[V]call\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<result> = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(<num>)]
           <ty>|<fnty> <fnptrval>(<function args>) [fn attrs] [ operand bundles ]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]call\f[R]\[aq] instruction represents a simple function
call.
.SS Arguments:
.PP
This instruction requires several arguments:
.IP "1." 3
The optional \f[V]tail\f[R] and \f[V]musttail\f[R] markers indicate that
the optimizers should perform tail call optimization.
The \f[V]tail\f[R] marker is a hint that can be ignored.
The \f[V]musttail\f[R] marker means that the call must be tail call
optimized in order for the program to be correct.
The \f[V]musttail\f[R] marker provides these guarantees:
.RS 4
.IP "1." 3
The call will not cause unbounded stack growth if it is part of a
recursive cycle in the call graph.
.IP "2." 3
Arguments with the \f[V]inalloca <attr_inalloca>\f[R] or
\f[V]preallocated <attr_preallocated>\f[R] attribute are forwarded in
place.
.IP "3." 3
If the musttail call appears in a function with the
\f[V]\[dq]thunk\[dq]\f[R] attribute and the caller and callee both have
varargs, than any unprototyped arguments in register or memory are
forwarded to the callee.
Similarly, the return value of the callee is returned to the
caller\[aq]s caller, even if a void return type is in use.
.PP
Both markers imply that the callee does not access allocas from the
caller.
The \f[V]tail\f[R] marker additionally implies that the callee does not
access varargs from the caller.
Calls marked \f[V]musttail\f[R] must obey the following additional
rules:
.IP \[bu] 2
The call must immediately precede a \f[V]ret <i_ret>\f[R] instruction,
or a pointer bitcast followed by a ret instruction.
.IP \[bu] 2
The ret instruction must return the (possibly bitcasted) value produced
by the call, undef, or void.
.IP \[bu] 2
The calling conventions of the caller and callee must match.
.IP \[bu] 2
The callee must be varargs iff the caller is varargs.
Bitcasting a non-varargs function to the appropriate varargs type is
legal so long as the non-varargs prefixes obey the other rules.
.IP \[bu] 2
The return type must not undergo automatic conversion to an sret
pointer.
.RE
.RS
.PP
In addition, if the calling convention is not swifttailcc or
\[ga]tailcc\[ga]:
.RS
.IP \[bu] 2
All ABI-impacting function attributes, such as sret, byval, inreg,
returned, and inalloca, must match.
.IP \[bu] 2
The caller and callee prototypes must match.
Pointer types of parameters or return types may differ in pointee type,
but not in address space.
.RE
.PP
On the other hand, if the calling convention is swifttailcc or
\[ga]swiftcc\[ga]:
.RS
.IP \[bu] 2
Only these ABI-impacting attributes attributes are allowed: sret, byval,
swiftself, and swiftasync.
.IP \[bu] 2
Prototypes are not required to match.
.PP
Tail call optimization for calls marked \f[V]tail\f[R] is guaranteed to
occur if the following conditions are met:
.IP \[bu] 2
Caller and callee both have the calling convention \f[V]fastcc\f[R] or
\f[V]tailcc\f[R].
.IP \[bu] 2
The call is in tail position (ret immediately follows call and ret uses
value of call or is void).
.IP \[bu] 2
Option \f[V]-tailcallopt\f[R] is enabled,
\f[V]llvm::GuaranteedTailCallOpt\f[R] is \f[V]true\f[R], or the calling
convention is \f[V]tailcc\f[R]
.IP \[bu] 2
Platform-specific constraints are met.
.RE
.RE
.IP " 1." 4
The optional \f[V]notail\f[R] marker indicates that the optimizers
should not add \f[V]tail\f[R] or \f[V]musttail\f[R] markers to the call.
It is used to prevent tail call optimization from being performed on the
call.
.IP " 2." 4
The optional \f[V]fast-math flags\f[R] marker indicates that the call
has one or more \f[V]fast-math flags <fastmath>\f[R], which are
optimization hints to enable otherwise unsafe floating-point
optimizations.
Fast-math flags are only valid for calls that return a floating-point
scalar or vector type, or an array (nested to any depth) of
floating-point scalar or vector types.
.IP " 3." 4
The optional \[dq]cconv\[dq] marker indicates which \f[V]calling
convention <callingconv>\f[R] the call should use.
If none is specified, the call defaults to using C calling conventions.
The calling convention of the call must match the calling convention of
the target function, or else the behavior is undefined.
.IP " 4." 4
The optional \f[V]Parameter Attributes <paramattrs>\f[R] list for return
values.
Only \[aq]\f[V]zeroext\f[R]\[aq], \[aq]\f[V]signext\f[R]\[aq], and
\[aq]\f[V]inreg\f[R]\[aq] attributes are valid here.
.IP " 5." 4
The optional addrspace attribute can be used to indicate the address
space of the called function.
If it is not specified, the program address space from the
\f[V]datalayout string<langref_datalayout>\f[R] will be used.
.IP " 6." 4
\[aq]\f[V]ty\f[R]\[aq]: the type of the call instruction itself which is
also the type of the return value.
Functions that return no value are marked \f[V]void\f[R].
.IP " 7." 4
\[aq]\f[V]fnty\f[R]\[aq]: shall be the signature of the function being
called.
The argument types must match the types implied by this signature.
This type can be omitted if the function is not varargs.
.IP " 8." 4
\[aq]\f[V]fnptrval\f[R]\[aq]: An LLVM value containing a pointer to a
function to be called.
In most cases, this is a direct function call, but indirect
\f[V]call\f[R]\[aq]s are just as possible, calling an arbitrary pointer
to function value.
.IP " 9." 4
\[aq]\f[V]function args\f[R]\[aq]: argument list whose types match the
function signature argument types and parameter attributes.
All arguments must be of \f[V]first class <t_firstclass>\f[R] type.
If the function signature indicates the function accepts a variable
number of arguments, the extra arguments can be specified.
.IP "10." 4
The optional \f[V]function attributes <fnattrs>\f[R] list.
.IP "11." 4
The optional \f[V]operand bundles <opbundles>\f[R] list.
.SS Semantics:
.PP
The \[aq]\f[V]call\f[R]\[aq] instruction is used to cause control flow
to transfer to a specified function, with its incoming arguments bound
to the specified values.
Upon a \[aq]\f[V]ret\f[R]\[aq] instruction in the called function,
control flow continues with the instruction after the function call, and
the return value of the function is bound to the result argument.
.SS Example:
.IP
.nf
\f[C]
%retval = call i32 \[at]test(i32 %argc)
call i32 (i8*, ...)* \[at]printf(i8* %msg, i32 12, i8 42)        ; yields i32
%X = tail call i32 \[at]foo()                                    ; yields i32
%Y = tail call fastcc i32 \[at]foo()  ; yields i32
call void %foo(i8 signext 97)

%struct.A = type { i32, i8 }
%r = call %struct.A \[at]foo()                        ; yields { i32, i8 }
%gr = extractvalue %struct.A %r, 0                ; yields i32
%gr1 = extractvalue %struct.A %r, 1               ; yields i8
%Z = call void \[at]foo() noreturn                    ; indicates that %foo never returns normally
%ZZ = call zeroext i32 \[at]bar()                     ; Return value is %zero extended
\f[R]
.fi
.PP
llvm treats calls to some functions with names and arguments that match
the standard C99 library as being the C99 library functions, and may
perform optimizations or generate code for them under that assumption.
This is something we\[aq]d like to change in the future to provide
better support for freestanding environments and non-C-based languages.
.SS \[aq]\f[V]va_arg\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<resultval> = va_arg <va_list*> <arglist>, <argty>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]va_arg\f[R]\[aq] instruction is used to access arguments
passed through the \[dq]variable argument\[dq] area of a function call.
It is used to implement the \f[V]va_arg\f[R] macro in C.
.SS Arguments:
.PP
This instruction takes a \f[V]va_list*\f[R] value and the type of the
argument.
It returns a value of the specified argument type and increments the
\f[V]va_list\f[R] to point to the next argument.
The actual type of \f[V]va_list\f[R] is target specific.
.SS Semantics:
.PP
The \[aq]\f[V]va_arg\f[R]\[aq] instruction loads an argument of the
specified type from the specified \f[V]va_list\f[R] and causes the
\f[V]va_list\f[R] to point to the next argument.
For more information, see the variable argument handling
\f[V]Intrinsic Functions <int_varargs>\f[R].
.PP
It is legal for this instruction to be called in a function which does
not take a variable number of arguments, for example, the
\f[V]vfprintf\f[R] function.
.PP
\f[V]va_arg\f[R] is an LLVM instruction instead of an \f[V]intrinsic
function <intrinsics>\f[R] because it takes a type as an argument.
.SS Example:
.PP
See the \f[V]variable argument processing <int_varargs>\f[R] section.
.PP
Note that the code generator does not yet fully support va_arg on many
targets.
Also, it does not currently support va_arg with aggregate types on any
target.
.SS \[aq]\f[V]landingpad\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<resultval> = landingpad <resultty> <clause>+
<resultval> = landingpad <resultty> cleanup <clause>*

<clause> := catch <type> <value>
<clause> := filter <array constant type> <array constant>
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]landingpad\f[R]\[aq] instruction is used by LLVM\[aq]s
exception handling system to specify that a basic block is a landing pad
--- one where the exception lands, and corresponds to the code found in
the \f[V]catch\f[R] portion of a \f[V]try\f[R]/\f[V]catch\f[R] sequence.
It defines values supplied by the
\f[V]personality function <personalityfn>\f[R] upon re-entry to the
function.
The \f[V]resultval\f[R] has the type \f[V]resultty\f[R].
.SS Arguments:
.PP
The optional \f[V]cleanup\f[R] flag indicates that the landing pad block
is a cleanup.
.PP
A \f[V]clause\f[R] begins with the clause type --- \f[V]catch\f[R] or
\f[V]filter\f[R] --- and contains the global variable representing the
\[dq]type\[dq] that may be caught or filtered respectively.
Unlike the \f[V]catch\f[R] clause, the \f[V]filter\f[R] clause takes an
array constant as its argument.
Use \[dq]\f[V][0 x i8**] undef\f[R]\[dq] for a filter which cannot
throw.
The \[aq]\f[V]landingpad\f[R]\[aq] instruction must contain \f[I]at
least\f[R] one \f[V]clause\f[R] or the \f[V]cleanup\f[R] flag.
.SS Semantics:
.PP
The \[aq]\f[V]landingpad\f[R]\[aq] instruction defines the values which
are set by the \f[V]personality function <personalityfn>\f[R] upon
re-entry to the function, and therefore the \[dq]result type\[dq] of the
\f[V]landingpad\f[R] instruction.
As with calling conventions, how the personality function results are
represented in LLVM IR is target specific.
.PP
The clauses are applied in order from top to bottom.
If two \f[V]landingpad\f[R] instructions are merged together through
inlining, the clauses from the calling function are appended to the list
of clauses.
When the call stack is being unwound due to an exception being thrown,
the exception is compared against each \f[V]clause\f[R] in turn.
If it doesn\[aq]t match any of the clauses, and the \f[V]cleanup\f[R]
flag is not set, then unwinding continues further up the call stack.
.PP
The \f[V]landingpad\f[R] instruction has several restrictions:
.IP \[bu] 2
A landing pad block is a basic block which is the unwind destination of
an \[aq]\f[V]invoke\f[R]\[aq] instruction.
.IP \[bu] 2
A landing pad block must have a \[aq]\f[V]landingpad\f[R]\[aq]
instruction as its first non-PHI instruction.
.IP \[bu] 2
There can be only one \[aq]\f[V]landingpad\f[R]\[aq] instruction within
the landing pad block.
.IP \[bu] 2
A basic block that is not a landing pad block may not include a
\[aq]\f[V]landingpad\f[R]\[aq] instruction.
.SS Example:
.IP
.nf
\f[C]
;; A landing pad which can catch an integer.
%res = landingpad { i8*, i32 }
         catch i8** \[at]_ZTIi
;; A landing pad that is a cleanup.
%res = landingpad { i8*, i32 }
         cleanup
;; A landing pad which can catch an integer and can only throw a double.
%res = landingpad { i8*, i32 }
         catch i8** \[at]_ZTIi
         filter [1 x i8**] [i8** \[at]_ZTId]
\f[R]
.fi
.SS \[aq]\f[V]catchpad\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<resultval> = catchpad within <catchswitch> [<args>*]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]catchpad\f[R]\[aq] instruction is used by LLVM\[aq]s
exception handling system to specify that a basic block begins a catch
handler --- one where a personality routine attempts to transfer control
to catch an exception.
.SS Arguments:
.PP
The \f[V]catchswitch\f[R] operand must always be a token produced by a
\f[V]catchswitch <i_catchswitch>\f[R] instruction in a predecessor
block.
This ensures that each \f[V]catchpad\f[R] has exactly one predecessor
block, and it always terminates in a \f[V]catchswitch\f[R].
.PP
The \f[V]args\f[R] correspond to whatever information the personality
routine requires to know if this is an appropriate handler for the
exception.
Control will transfer to the \f[V]catchpad\f[R] if this is the first
appropriate handler for the exception.
.PP
The \f[V]resultval\f[R] has the type \f[V]token <t_token>\f[R] and is
used to match the \f[V]catchpad\f[R] to corresponding
\f[V]catchrets <i_catchret>\f[R] and other nested EH pads.
.SS Semantics:
.PP
When the call stack is being unwound due to an exception being thrown,
the exception is compared against the \f[V]args\f[R].
If it doesn\[aq]t match, control will not reach the \f[V]catchpad\f[R]
instruction.
The representation of \f[V]args\f[R] is entirely target and personality
function-specific.
.PP
Like the \f[V]landingpad <i_landingpad>\f[R] instruction, the
\f[V]catchpad\f[R] instruction must be the first non-phi of its parent
basic block.
.PP
The meaning of the tokens produced and consumed by \f[V]catchpad\f[R]
and other \[dq]pad\[dq] instructions is described in the Windows
exception handling documentation.
.PP
When a \f[V]catchpad\f[R] has been \[dq]entered\[dq] but not yet
\[dq]exited\[dq] (as described in the EH documentation), it is undefined
behavior to execute a \f[V]call <i_call>\f[R] or
\f[V]invoke <i_invoke>\f[R] that does not carry an appropriate
\f[V]\[dq]funclet\[dq] bundle <ob_funclet>\f[R].
.SS Example:
.IP
.nf
\f[C]
dispatch:
  %cs = catchswitch within none [label %handler0] unwind to caller
  ;; A catch block which can catch an integer.
handler0:
  %tok = catchpad within %cs [i8** \[at]_ZTIi]
\f[R]
.fi
.SS \[aq]\f[V]cleanuppad\f[R]\[aq] Instruction
.SS Syntax:
.IP
.nf
\f[C]
<resultval> = cleanuppad within <parent> [<args>*]
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]cleanuppad\f[R]\[aq] instruction is used by LLVM\[aq]s
exception handling system to specify that a basic block is a cleanup
block --- one where a personality routine attempts to transfer control
to run cleanup actions.
The \f[V]args\f[R] correspond to whatever additional information the
\f[V]personality function <personalityfn>\f[R] requires to execute the
cleanup.
The \f[V]resultval\f[R] has the type \f[V]token <t_token>\f[R] and is
used to match the \f[V]cleanuppad\f[R] to corresponding
\f[V]cleanuprets <i_cleanupret>\f[R].
The \f[V]parent\f[R] argument is the token of the funclet that contains
the \f[V]cleanuppad\f[R] instruction.
If the \f[V]cleanuppad\f[R] is not inside a funclet, this operand may be
the token \f[V]none\f[R].
.SS Arguments:
.PP
The instruction takes a list of arbitrary values which are interpreted
by the \f[V]personality function <personalityfn>\f[R].
.SS Semantics:
.PP
When the call stack is being unwound due to an exception being thrown,
the \f[V]personality function <personalityfn>\f[R] transfers control to
the \f[V]cleanuppad\f[R] with the aid of the personality-specific
arguments.
As with calling conventions, how the personality function results are
represented in LLVM IR is target specific.
.PP
The \f[V]cleanuppad\f[R] instruction has several restrictions:
.IP \[bu] 2
A cleanup block is a basic block which is the unwind destination of an
exceptional instruction.
.IP \[bu] 2
A cleanup block must have a \[aq]\f[V]cleanuppad\f[R]\[aq] instruction
as its first non-PHI instruction.
.IP \[bu] 2
There can be only one \[aq]\f[V]cleanuppad\f[R]\[aq] instruction within
the cleanup block.
.IP \[bu] 2
A basic block that is not a cleanup block may not include a
\[aq]\f[V]cleanuppad\f[R]\[aq] instruction.
.PP
When a \f[V]cleanuppad\f[R] has been \[dq]entered\[dq] but not yet
\[dq]exited\[dq] (as described in the EH documentation), it is undefined
behavior to execute a \f[V]call <i_call>\f[R] or
\f[V]invoke <i_invoke>\f[R] that does not carry an appropriate
\f[V]\[dq]funclet\[dq] bundle <ob_funclet>\f[R].
.SS Example:
.IP
.nf
\f[C]
%tok = cleanuppad within %cs []
\f[R]
.fi
.SH Intrinsic Functions
.PP
LLVM supports the notion of an \[dq]intrinsic function\[dq].
These functions have well known names and semantics and are required to
follow certain restrictions.
Overall, these intrinsics represent an extension mechanism for the LLVM
language that does not require changing all of the transformations in
LLVM when adding to the language (or the bitcode reader/writer, the
parser, etc...).
.PP
Intrinsic function names must all start with an
\[dq]\f[V]llvm.\f[R]\[dq] prefix.
This prefix is reserved in LLVM for intrinsic names; thus, function
names may not begin with this prefix.
Intrinsic functions must always be external functions: you cannot define
the body of intrinsic functions.
Intrinsic functions may only be used in call or invoke instructions: it
is illegal to take the address of an intrinsic function.
Additionally, because intrinsic functions are part of the LLVM language,
it is required if any are added that they be documented here.
.PP
Some intrinsic functions can be overloaded, i.e., the intrinsic
represents a family of functions that perform the same operation but on
different data types.
Because LLVM can represent over 8 million different integer types,
overloading is used commonly to allow an intrinsic function to operate
on any integer type.
One or more of the argument types or the result type can be overloaded
to accept any integer type.
Argument types may also be defined as exactly matching a previous
argument\[aq]s type or the result type.
This allows an intrinsic function which accepts multiple arguments, but
needs all of them to be of the same type, to only be overloaded with
respect to a single argument or the result.
.PP
Overloaded intrinsics will have the names of its overloaded argument
types encoded into its function name, each preceded by a period.
Only those types which are overloaded result in a name suffix.
Arguments whose type is matched against another type do not.
For example, the \f[V]llvm.ctpop\f[R] function can take an integer of
any width and returns an integer of exactly the same integer width.
This leads to a family of functions such as
\f[V]i8 \[at]llvm.ctpop.i8(i8 %val)\f[R] and
\f[V]i29 \[at]llvm.ctpop.i29(i29 %val)\f[R].
Only one type, the return type, is overloaded, and only one type suffix
is required.
Because the argument\[aq]s type is matched against the return type, it
does not require its own name suffix.
.PP
\f[V]Unnamed types <t_opaque>\f[R] are encoded as \f[V]s_s\f[R].
Overloaded intrinsics that depend on an unnamed type in one of its
overloaded argument types get an additional \f[V].<number>\f[R] suffix.
This allows differentiating intrinsics with different unnamed types as
arguments.
(For example: \f[V]llvm.ssa.copy.p0s_s.2(%42*)\f[R]) The number is
tracked in the LLVM module and it ensures unique names in the module.
While linking together two modules, it is still possible to get a name
clash.
In that case one of the names will be changed by getting a new number.
.PP
For target developers who are defining intrinsics for back-end code
generation, any intrinsic overloads based solely the distinction between
integer or floating point types should not be relied upon for correct
code generation.
In such cases, the recommended approach for target maintainers when
defining intrinsics is to create separate integer and FP intrinsics
rather than rely on overloading.
For example, if different codegen is required for
\f[V]llvm.target.foo(<4 x i32>)\f[R] and
\f[V]llvm.target.foo(<4 x float>)\f[R] then these should be split into
different intrinsics.
.PP
To learn how to add an intrinsic function, please see the Extending LLVM
Guide.
.SS Variable Argument Handling Intrinsics
.PP
Variable argument support is defined in LLVM with the
\f[V]va_arg <i_va_arg>\f[R] instruction and these three intrinsic
functions.
These functions are related to the similarly named macros defined in the
\f[V]<stdarg.h>\f[R] header file.
.PP
All of these functions operate on arguments that use a target-specific
value type \[dq]\f[V]va_list\f[R]\[dq].
The LLVM assembly language reference manual does not define what this
type is, so all transformations should be prepared to handle these
functions regardless of the type used.
.PP
This example shows how the \f[V]va_arg <i_va_arg>\f[R] instruction and
the variable argument handling intrinsic functions are used.
.IP
.nf
\f[C]
; This struct is different for every platform. For most platforms,
; it is merely an i8*.
%struct.va_list = type { i8* }

; For Unix x86_64 platforms, va_list is the following struct:
; %struct.va_list = type { i32, i32, i8*, i8* }

define i32 \[at]test(i32 %X, ...) {
  ; Initialize variable argument processing
  %ap = alloca %struct.va_list
  %ap2 = bitcast %struct.va_list* %ap to i8*
  call void \[at]llvm.va_start(i8* %ap2)

  ; Read a single integer argument
  %tmp = va_arg i8* %ap2, i32

  ; Demonstrate usage of llvm.va_copy and llvm.va_end
  %aq = alloca i8*
  %aq2 = bitcast i8** %aq to i8*
  call void \[at]llvm.va_copy(i8* %aq2, i8* %ap2)
  call void \[at]llvm.va_end(i8* %aq2)

  ; Stop processing of arguments.
  call void \[at]llvm.va_end(i8* %ap2)
  ret i32 %tmp
}

declare void \[at]llvm.va_start(i8*)
declare void \[at]llvm.va_copy(i8*, i8*)
declare void \[at]llvm.va_end(i8*)
\f[R]
.fi
.SS \[aq]\f[V]llvm.va_start\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.va_start(i8* <arglist>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.va_start\f[R]\[aq] intrinsic initializes
\f[V]*<arglist>\f[R] for subsequent use by \f[V]va_arg\f[R].
.SS Arguments:
.PP
The argument is a pointer to a \f[V]va_list\f[R] element to initialize.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.va_start\f[R]\[aq] intrinsic works just like the
\f[V]va_start\f[R] macro available in C.
In a target-dependent way, it initializes the \f[V]va_list\f[R] element
to which the argument points, so that the next call to \f[V]va_arg\f[R]
will produce the first variable argument passed to the function.
Unlike the C \f[V]va_start\f[R] macro, this intrinsic does not need to
know the last argument of the function as the compiler can figure that
out.
.SS \[aq]\f[V]llvm.va_end\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.va_end(i8* <arglist>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.va_end\f[R]\[aq] intrinsic destroys
\f[V]*<arglist>\f[R], which has been initialized previously with
\f[V]llvm.va_start\f[R] or \f[V]llvm.va_copy\f[R].
.SS Arguments:
.PP
The argument is a pointer to a \f[V]va_list\f[R] to destroy.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.va_end\f[R]\[aq] intrinsic works just like the
\f[V]va_end\f[R] macro available in C.
In a target-dependent way, it destroys the \f[V]va_list\f[R] element to
which the argument points.
Calls to \f[V]llvm.va_start <int_va_start>\f[R] and
\f[V]llvm.va_copy <int_va_copy>\f[R] must be matched exactly with calls
to \f[V]llvm.va_end\f[R].
.SS \[aq]\f[V]llvm.va_copy\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.va_copy(i8* <destarglist>, i8* <srcarglist>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.va_copy\f[R]\[aq] intrinsic copies the current
argument position from the source argument list to the destination
argument list.
.SS Arguments:
.PP
The first argument is a pointer to a \f[V]va_list\f[R] element to
initialize.
The second argument is a pointer to a \f[V]va_list\f[R] element to copy
from.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.va_copy\f[R]\[aq] intrinsic works just like the
\f[V]va_copy\f[R] macro available in C.
In a target-dependent way, it copies the source \f[V]va_list\f[R]
element into the destination \f[V]va_list\f[R] element.
This intrinsic is necessary because the \f[V]llvm.va_start\f[R]
intrinsic may be arbitrarily complex and require, for example, memory
allocation.
.SS Accurate Garbage Collection Intrinsics
.PP
LLVM\[aq]s support for Accurate Garbage Collection (GC) requires the
frontend to generate code containing appropriate intrinsic calls and
select an appropriate GC strategy which knows how to lower these
intrinsics in a manner which is appropriate for the target collector.
.PP
These intrinsics allow identification of \f[V]GC roots on the
stack <int_gcroot>\f[R], as well as garbage collector implementations
that require \f[V]read <int_gcread>\f[R] and
\f[V]write <int_gcwrite>\f[R] barriers.
Frontends for type-safe garbage collected languages should generate
these intrinsics to make use of the LLVM garbage collectors.
For more details, see Garbage Collection with LLVM.
.PP
LLVM provides an second experimental set of intrinsics for describing
garbage collection safepoints in compiled code.
These intrinsics are an alternative to the \f[V]llvm.gcroot\f[R]
intrinsics, but are compatible with the ones for
\f[V]read <int_gcread>\f[R] and \f[V]write <int_gcwrite>\f[R] barriers.
The differences in approach are covered in the Garbage Collection with
LLVM documentation.
The intrinsics themselves are described in \f[V]Statepoints\f[R].
.SS \[aq]\f[V]llvm.gcroot\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.gcroot(i8** %ptrloc, i8* %metadata)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.gcroot\f[R]\[aq] intrinsic declares the existence of
a GC root to the code generator, and allows some metadata to be
associated with it.
.SS Arguments:
.PP
The first argument specifies the address of a stack object that contains
the root pointer.
The second pointer (which must be either a constant or a global value
address) contains the meta-data to be associated with the root.
.SS Semantics:
.PP
At runtime, a call to this intrinsic stores a null pointer into the
\[dq]ptrloc\[dq] location.
At compile-time, the code generator generates information to allow the
runtime to find the pointer at GC safe points.
The \[aq]\f[V]llvm.gcroot\f[R]\[aq] intrinsic may only be used in a
function which \f[V]specifies a GC algorithm <gc>\f[R].
.SS \[aq]\f[V]llvm.gcread\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.gcread(i8* %ObjPtr, i8** %Ptr)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.gcread\f[R]\[aq] intrinsic identifies reads of
references from heap locations, allowing garbage collector
implementations that require read barriers.
.SS Arguments:
.PP
The second argument is the address to read from, which should be an
address allocated from the garbage collector.
The first object is a pointer to the start of the referenced object, if
needed by the language runtime (otherwise null).
.SS Semantics:
.PP
The \[aq]\f[V]llvm.gcread\f[R]\[aq] intrinsic has the same semantics as
a load instruction, but may be replaced with substantially more complex
code by the garbage collector runtime, as needed.
The \[aq]\f[V]llvm.gcread\f[R]\[aq] intrinsic may only be used in a
function which \f[V]specifies a GC
algorithm <gc>\f[R].
.SS \[aq]\f[V]llvm.gcwrite\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.gcwrite(i8* %P1, i8* %Obj, i8** %P2)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.gcwrite\f[R]\[aq] intrinsic identifies writes of
references to heap locations, allowing garbage collector implementations
that require write barriers (such as generational or reference counting
collectors).
.SS Arguments:
.PP
The first argument is the reference to store, the second is the start of
the object to store it to, and the third is the address of the field of
Obj to store to.
If the runtime does not require a pointer to the object, Obj may be
null.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.gcwrite\f[R]\[aq] intrinsic has the same semantics as
a store instruction, but may be replaced with substantially more complex
code by the garbage collector runtime, as needed.
The \[aq]\f[V]llvm.gcwrite\f[R]\[aq] intrinsic may only be used in a
function which \f[V]specifies a GC
algorithm <gc>\f[R].
.SS \[aq]llvm.experimental.gc.statepoint\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare token
  \[at]llvm.experimental.gc.statepoint(i64 <id>, i32 <num patch bytes>,
                 func_type* elementtype(func_type) <target>,
                 i64 <#call args>, i64 <flags>,
                 ... (call parameters),
                 i64 0, i64 0)
\f[R]
.fi
.SS Overview:
.PP
The statepoint intrinsic represents a call which is parse-able by the
runtime.
.SS Operands:
.PP
The \[aq]id\[aq] operand is a constant integer that is reported as the
ID field in the generated stackmap.
LLVM does not interpret this parameter in any way and its meaning is up
to the statepoint user to decide.
Note that LLVM is free to duplicate code containing statepoint calls,
and this may transform IR that had a unique \[aq]id\[aq] per lexical
call to statepoint to IR that does not.
.PP
If \[aq]num patch bytes\[aq] is non-zero then the call instruction
corresponding to the statepoint is not emitted and LLVM emits \[aq]num
patch bytes\[aq] bytes of nops in its place.
LLVM will emit code to prepare the function arguments and retrieve the
function return value in accordance to the calling convention; the
former before the nop sequence and the latter after the nop sequence.
It is expected that the user will patch over the \[aq]num patch
bytes\[aq] bytes of nops with a calling sequence specific to their
runtime before executing the generated machine code.
There are no guarantees with respect to the alignment of the nop
sequence.
Unlike \f[V]StackMaps\f[R] statepoints do not have a concept of shadow
bytes.
Note that semantically the statepoint still represents a call or invoke
to \[aq]target\[aq], and the nop sequence after patching is expected to
represent an operation equivalent to a call or invoke to
\[aq]target\[aq].
.PP
The \[aq]target\[aq] operand is the function actually being called.
The operand must have an \f[V]elementtype <attr_elementtype>\f[R]
attribute specifying the function type of the target.
The target can be specified as either a symbolic LLVM function, or as an
arbitrary Value of pointer type.
Note that the function type must match the signature of the callee and
the types of the \[aq]call parameters\[aq] arguments.
.PP
The \[aq]#call args\[aq] operand is the number of arguments to the
actual call.
It must exactly match the number of arguments passed in the \[aq]call
parameters\[aq] variable length section.
.PP
The \[aq]flags\[aq] operand is used to specify extra information about
the statepoint.
This is currently only used to mark certain statepoints as GC
transitions.
This operand is a 64-bit integer with the following layout, where bit 0
is the least significant bit:
.RS
.PP
.TS
tab(@);
lw(7.8n) lw(50.6n).
T{
Bit #
T}@T{
Usage
T}
_
T{
.RS
.PP
0
.RE
T}@T{
Set if the statepoint is a GC transition, cleared otherwise.
T}
T{
.RS
.PP
1-63
.RE
T}@T{
Reserved for future use; must be cleared.
T}
.TE
.RE
.PP
The \[aq]call parameters\[aq] arguments are simply the arguments which
need to be passed to the call target.
They will be lowered according to the specified calling convention and
otherwise handled like a normal call instruction.
The number of arguments must exactly match what is specified in \[aq]#
call args\[aq].
The types must match the signature of \[aq]target\[aq].
.PP
The \[aq]call parameter\[aq] attributes must be followed by two \[aq]i64
0\[aq] constants.
These were originally the length prefixes for \[aq]gc transition
parameter\[aq] and \[aq]deopt parameter\[aq] arguments, but the role of
these parameter sets have been entirely replaced with the corresponding
operand bundles.
In a future revision, these now redundant arguments will be removed.
.SS Semantics:
.PP
A statepoint is assumed to read and write all memory.
As a result, memory operations can not be reordered past a statepoint.
It is illegal to mark a statepoint as being either \[aq]readonly\[aq] or
\[aq]readnone\[aq].
.PP
Note that legal IR can not perform any memory operation on a \[aq]gc
pointer\[aq] argument of the statepoint in a location statically
reachable from the statepoint.
Instead, the explicitly relocated value (from a \f[V]gc.relocate\f[R])
must be used.
.SS \[aq]llvm.experimental.gc.result\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare type*
  \[at]llvm.experimental.gc.result(token %statepoint_token)
\f[R]
.fi
.SS Overview:
.PP
\f[V]gc.result\f[R] extracts the result of the original call instruction
which was replaced by the \f[V]gc.statepoint\f[R].
The \f[V]gc.result\f[R] intrinsic is actually a family of three
intrinsics due to an implementation limitation.
Other than the type of the return value, the semantics are the same.
.SS Operands:
.PP
The first and only argument is the \f[V]gc.statepoint\f[R] which starts
the safepoint sequence of which this \f[V]gc.result\f[R] is a part.
Despite the typing of this as a generic token, \f[I]only\f[R] the value
defined by a \f[V]gc.statepoint\f[R] is legal here.
.SS Semantics:
.PP
The \f[V]gc.result\f[R] represents the return value of the call target
of the \f[V]statepoint\f[R].
The type of the \f[V]gc.result\f[R] must exactly match the type of the
target.
If the call target returns void, there will be no \f[V]gc.result\f[R].
.PP
A \f[V]gc.result\f[R] is modeled as a \[aq]readnone\[aq] pure function.
It has no side effects since it is just a projection of the return value
of the previous call represented by the \f[V]gc.statepoint\f[R].
.SS \[aq]llvm.experimental.gc.relocate\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <pointer type>
  \[at]llvm.experimental.gc.relocate(token %statepoint_token,
                                 i32 %base_offset,
                                 i32 %pointer_offset)
\f[R]
.fi
.SS Overview:
.PP
A \f[V]gc.relocate\f[R] returns the potentially relocated value of a
pointer at the safepoint.
.SS Operands:
.PP
The first argument is the \f[V]gc.statepoint\f[R] which starts the
safepoint sequence of which this \f[V]gc.relocation\f[R] is a part.
Despite the typing of this as a generic token, \f[I]only\f[R] the value
defined by a \f[V]gc.statepoint\f[R] is legal here.
.PP
The second and third arguments are both indices into operands of the
corresponding statepoint\[aq]s \f[V]gc-live <ob_gc_live>\f[R] operand
bundle.
.PP
The second argument is an index which specifies the allocation for the
pointer being relocated.
The associated value must be within the object with which the pointer
being relocated is associated.
The optimizer is free to change \f[I]which\f[R] interior derived pointer
is reported, provided that it does not replace an actual base pointer
with another interior derived pointer.
Collectors are allowed to rely on the base pointer operand remaining an
actual base pointer if so constructed.
.PP
The third argument is an index which specify the (potentially) derived
pointer being relocated.
It is legal for this index to be the same as the second argument
if-and-only-if a base pointer is being relocated.
.SS Semantics:
.PP
The return value of \f[V]gc.relocate\f[R] is the potentially relocated
value of the pointer specified by its arguments.
It is unspecified how the value of the returned pointer relates to the
argument to the \f[V]gc.statepoint\f[R] other than that a) it points to
the same source language object with the same offset, and b) the
\[aq]based-on\[aq] relationship of the newly relocated pointers is a
projection of the unrelocated pointers.
In particular, the integer value of the pointer returned is unspecified.
.PP
A \f[V]gc.relocate\f[R] is modeled as a \f[V]readnone\f[R] pure
function.
It has no side effects since it is just a way to extract information
about work done during the actual call modeled by the
\f[V]gc.statepoint\f[R].
.SS \[aq]llvm.experimental.gc.get.pointer.base\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <pointer type>
  \[at]llvm.experimental.gc.get.pointer.base(
    <pointer type> readnone nocapture %derived_ptr)
    nounwind readnone willreturn
\f[R]
.fi
.SS Overview:
.PP
\f[V]gc.get.pointer.base\f[R] for a derived pointer returns its base
pointer.
.SS Operands:
.PP
The only argument is a pointer which is based on some object with an
unknown offset from the base of said object.
.SS Semantics:
.PP
This intrinsic is used in the abstract machine model for GC to represent
the base pointer for an arbitrary derived pointer.
.PP
This intrinsic is inlined by the \f[V]RewriteStatepointsForGC\f[R] pass
by replacing all uses of this callsite with the offset of a derived
pointer from its base pointer value.
The replacement is done as part of the lowering to the explicit
statepoint model.
.PP
The return pointer type must be the same as the type of the parameter.
.SS \[aq]llvm.experimental.gc.get.pointer.offset\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i64
  \[at]llvm.experimental.gc.get.pointer.offset(
    <pointer type> readnone nocapture %derived_ptr)
    nounwind readnone willreturn
\f[R]
.fi
.SS Overview:
.PP
\f[V]gc.get.pointer.offset\f[R] for a derived pointer returns the offset
from its base pointer.
.SS Operands:
.PP
The only argument is a pointer which is based on some object with an
unknown offset from the base of said object.
.SS Semantics:
.PP
This intrinsic is used in the abstract machine model for GC to represent
the offset of an arbitrary derived pointer from its base pointer.
.PP
This intrinsic is inlined by the \f[V]RewriteStatepointsForGC\f[R] pass
by replacing all uses of this callsite with the offset of a derived
pointer from its base pointer value.
The replacement is done as part of the lowering to the explicit
statepoint model.
.PP
Basically this call calculates difference between the derived pointer
and its base pointer (see \f[V]gc.get.pointer.base\f[R]) both ptrtoint
casted.
But this cast done outside the \f[V]RewriteStatepointsForGC\f[R] pass
could result in the pointers lost for further lowering from the abstract
model to the explicit physical one.
.SS Code Generator Intrinsics
.PP
These intrinsics are provided by LLVM to expose special features that
may only be implemented with code generator support.
.SS \[aq]\f[V]llvm.returnaddress\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.returnaddress(i32 <level>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.returnaddress\f[R]\[aq] intrinsic attempts to compute
a target-specific value indicating the return address of the current
function or one of its callers.
.SS Arguments:
.PP
The argument to this intrinsic indicates which function to return the
address for.
Zero indicates the calling function, one indicates its caller, etc.
The argument is \f[B]required\f[R] to be a constant integer value.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.returnaddress\f[R]\[aq] intrinsic either returns a
pointer indicating the return address of the specified call frame, or
zero if it cannot be identified.
The value returned by this intrinsic is likely to be incorrect or 0 for
arguments other than zero, so it should only be used for debugging
purposes.
.PP
Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.
.SS \[aq]\f[V]llvm.addressofreturnaddress\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.addressofreturnaddress()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.addressofreturnaddress\f[R]\[aq] intrinsic returns a
target-specific pointer to the place in the stack frame where the return
address of the current function is stored.
.SS Semantics:
.PP
Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.
.PP
This intrinsic is only implemented for x86 and aarch64.
.SS \[aq]\f[V]llvm.sponentry\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.sponentry()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.sponentry\f[R]\[aq] intrinsic returns the stack
pointer value at the entry of the current function calling this
intrinsic.
.SS Semantics:
.PP
Note this intrinsic is only verified on AArch64 and ARM.
.SS \[aq]\f[V]llvm.frameaddress\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.frameaddress(i32 <level>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.frameaddress\f[R]\[aq] intrinsic attempts to return
the target-specific frame pointer value for the specified stack frame.
.SS Arguments:
.PP
The argument to this intrinsic indicates which function to return the
frame pointer for.
Zero indicates the calling function, one indicates its caller, etc.
The argument is \f[B]required\f[R] to be a constant integer value.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.frameaddress\f[R]\[aq] intrinsic either returns a
pointer indicating the frame address of the specified call frame, or
zero if it cannot be identified.
The value returned by this intrinsic is likely to be incorrect or 0 for
arguments other than zero, so it should only be used for debugging
purposes.
.PP
Note that calling this intrinsic does not prevent function inlining or
other aggressive transformations, so the value returned may not be that
of the obvious source-language caller.
.SS \[aq]\f[V]llvm.swift.async.context.addr\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8** \[at]llvm.swift.async.context.addr()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.swift.async.context.addr\f[R]\[aq] intrinsic returns
a pointer to the part of the extended frame record containing the
asynchronous context of a Swift execution.
.SS Semantics:
.PP
If the caller has a \f[V]swiftasync\f[R] parameter, that argument will
initially be stored at the returned address.
If not, it will be initialized to null.
.SS \[aq]\f[V]llvm.localescape\f[R]\[aq] and \[aq]\f[V]llvm.localrecover\f[R]\[aq] Intrinsics
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.localescape(...)
declare i8* \[at]llvm.localrecover(i8* %func, i8* %fp, i32 %idx)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.localescape\f[R]\[aq] intrinsic escapes offsets of a
collection of static allocas, and the
\[aq]\f[V]llvm.localrecover\f[R]\[aq] intrinsic applies those offsets to
a live frame pointer to recover the address of the allocation.
The offset is computed during frame layout of the caller of
\f[V]llvm.localescape\f[R].
.SS Arguments:
.PP
All arguments to \[aq]\f[V]llvm.localescape\f[R]\[aq] must be pointers
to static allocas or casts of static allocas.
Each function can only call \[aq]\f[V]llvm.localescape\f[R]\[aq] once,
and it can only do so from the entry block.
.PP
The \f[V]func\f[R] argument to \[aq]\f[V]llvm.localrecover\f[R]\[aq]
must be a constant bitcasted pointer to a function defined in the
current module.
The code generator cannot determine the frame allocation offset of
functions defined in other modules.
.PP
The \f[V]fp\f[R] argument to \[aq]\f[V]llvm.localrecover\f[R]\[aq] must
be a frame pointer of a call frame that is currently live.
The return value of \[aq]\f[V]llvm.localaddress\f[R]\[aq] is one way to
produce such a value, but various runtimes also expose a suitable
pointer in platform-specific ways.
.PP
The \f[V]idx\f[R] argument to \[aq]\f[V]llvm.localrecover\f[R]\[aq]
indicates which alloca passed to \[aq]\f[V]llvm.localescape\f[R]\[aq] to
recover.
It is zero-indexed.
.SS Semantics:
.PP
These intrinsics allow a group of functions to share access to a set of
local stack allocations of a one parent function.
The parent function may call the \[aq]\f[V]llvm.localescape\f[R]\[aq]
intrinsic once from the function entry block, and the child functions
can use \[aq]\f[V]llvm.localrecover\f[R]\[aq] to access the escaped
allocas.
The \[aq]\f[V]llvm.localescape\f[R]\[aq] intrinsic blocks inlining, as
inlining changes where the escaped allocas are allocated, which would
break attempts to use \[aq]\f[V]llvm.localrecover\f[R]\[aq].
.SS \[aq]\f[V]llvm.seh.try.begin\f[R]\[aq] and \[aq]\f[V]llvm.seh.try.end\f[R]\[aq] Intrinsics
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.seh.try.begin()
declare void \[at]llvm.seh.try.end()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.seh.try.begin\f[R]\[aq] and
\[aq]\f[V]llvm.seh.try.end\f[R]\[aq] intrinsics mark the boundary of a
_try region for Windows SEH Asynchrous Exception Handling.
.SS Semantics:
.PP
When a C-function is compiled with Windows SEH Asynchrous Exception
option, -feh_asynch (aka MSVC -EHa), these two intrinsics are injected
to mark _try boundary and to prevent potential exceptions from being
moved across boundary.
Any set of operations can then be confined to the region by reading
their leaf inputs via volatile loads and writing their root outputs via
volatile stores.
.SS \[aq]\f[V]llvm.seh.scope.begin\f[R]\[aq] and \[aq]\f[V]llvm.seh.scope.end\f[R]\[aq] Intrinsics
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.seh.scope.begin()
declare void \[at]llvm.seh.scope.end()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.seh.scope.begin\f[R]\[aq] and
\[aq]\f[V]llvm.seh.scope.end\f[R]\[aq] intrinsics mark the boundary of a
CPP object lifetime for Windows SEH Asynchrous Exception Handling (MSVC
option -EHa).
.SS Semantics:
.PP
LLVM\[aq]s ordinary exception-handling representation associates EH
cleanups and handlers only with \f[V]invoke\f[R]s, which normally
correspond only to call sites.
To support arbitrary faulting instructions, it must be possible to
recover the current EH scope for any instruction.
Turning every operation in LLVM that could fault into an
\f[V]invoke\f[R] of a new, potentially-throwing intrinsic would require
adding a large number of intrinsics, impede optimization of those
operations, and make compilation slower by introducing many extra basic
blocks.
These intrinsics can be used instead to mark the region protected by a
cleanup, such as for a local C++ object with a non-trivial destructor.
\f[V]llvm.seh.scope.begin\f[R] is used to mark the start of the region;
it is always called with \f[V]invoke\f[R], with the unwind block being
the desired unwind destination for any potentially-throwing instructions
within the region.
llvm.seh.scope.end is used to mark when the scope ends and the EH
cleanup is no longer required (e.g.
because the destructor is being called).
.SS \[aq]\f[V]llvm.read_register\f[R]\[aq], \[aq]\f[V]llvm.read_volatile_register\f[R]\[aq], and \[aq]\f[V]llvm.write_register\f[R]\[aq] Intrinsics
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.read_register.i32(metadata)
declare i64 \[at]llvm.read_register.i64(metadata)
declare i32 \[at]llvm.read_volatile_register.i32(metadata)
declare i64 \[at]llvm.read_volatile_register.i64(metadata)
declare void \[at]llvm.write_register.i32(metadata, i32 \[at]value)
declare void \[at]llvm.write_register.i64(metadata, i64 \[at]value)
!0 = !{!\[dq]sp\[rs]00\[dq]}
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.read_register\f[R]\[aq],
\[aq]\f[V]llvm.read_volatile_register\f[R]\[aq], and
\[aq]\f[V]llvm.write_register\f[R]\[aq] intrinsics provide access to the
named register.
The register must be valid on the architecture being compiled to.
The type needs to be compatible with the register being read.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.read_register\f[R]\[aq] and
\[aq]\f[V]llvm.read_volatile_register\f[R]\[aq] intrinsics return the
current value of the register, where possible.
The \[aq]\f[V]llvm.write_register\f[R]\[aq] intrinsic sets the current
value of the register, where possible.
.PP
A call to \[aq]\f[V]llvm.read_volatile_register\f[R]\[aq] is assumed to
have side-effects and possibly return a different value each time (e.g.
for a timer register).
.PP
This is useful to implement named register global variables that need to
always be mapped to a specific register, as is common practice on
bare-metal programs including OS kernels.
.PP
The compiler doesn\[aq]t check for register availability or use of the
used register in surrounding code, including inline assembly.
Because of that, allocatable registers are not supported.
.PP
Warning: So far it only works with the stack pointer on selected
architectures (ARM, AArch64, PowerPC and x86_64).
Significant amount of work is needed to support other registers and even
more so, allocatable registers.
.SS \[aq]\f[V]llvm.stacksave\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.stacksave()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.stacksave\f[R]\[aq] intrinsic is used to remember the
current state of the function stack, for use with
\f[V]llvm.stackrestore <int_stackrestore>\f[R].
This is useful for implementing language features like scoped automatic
variable sized arrays in C99.
.SS Semantics:
.PP
This intrinsic returns an opaque pointer value that can be passed to
\f[V]llvm.stackrestore <int_stackrestore>\f[R].
When an \f[V]llvm.stackrestore\f[R] intrinsic is executed with a value
saved from \f[V]llvm.stacksave\f[R], it effectively restores the state
of the stack to the state it was in when the \f[V]llvm.stacksave\f[R]
intrinsic executed.
In practice, this pops any \f[V]alloca <i_alloca>\f[R] blocks from the
stack that were allocated after the \f[V]llvm.stacksave\f[R] was
executed.
.SS \[aq]\f[V]llvm.stackrestore\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.stackrestore(i8* %ptr)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.stackrestore\f[R]\[aq] intrinsic is used to restore
the state of the function stack to the state it was in when the
corresponding \f[V]llvm.stacksave <int_stacksave>\f[R] intrinsic
executed.
This is useful for implementing language features like scoped automatic
variable sized arrays in C99.
.SS Semantics:
.PP
See the description for \f[V]llvm.stacksave <int_stacksave>\f[R].
.SS \[aq]\f[V]llvm.get.dynamic.area.offset\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.get.dynamic.area.offset.i32()
declare i64 \[at]llvm.get.dynamic.area.offset.i64()
\f[R]
.fi
.SS Overview:
.RS
.PP
The \[aq]\f[V]llvm.get.dynamic.area.offset.*\f[R]\[aq] intrinsic family
is used to get the offset from native stack pointer to the address of
the most recent dynamic alloca on the caller\[aq]s stack.
These intrinsics are intended for use in combination with
\f[V]llvm.stacksave <int_stacksave>\f[R] to get a pointer to the most
recent dynamic alloca.
This is useful, for example, for AddressSanitizer\[aq]s stack
unpoisoning routines.
.RE
.SS Semantics:
.RS
.PP
These intrinsics return a non-negative integer value that can be used to
get the address of the most recent dynamic alloca, allocated by
\f[V]alloca <i_alloca>\f[R] on the caller\[aq]s stack.
In particular, for targets where stack grows downwards, adding this
offset to the native stack pointer would get the address of the most
recent dynamic alloca.
For targets where stack grows upwards, the situation is a bit more
complicated, because subtracting this value from stack pointer would get
the address one past the end of the most recent dynamic alloca.
.PP
Although for most targets llvm.get.dynamic.area.offset
<int_get_dynamic_area_offset> returns just a zero, for others, such as
PowerPC and PowerPC64, it returns a compile-time-known constant value.
.PP
The return value type of
\f[V]llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>\f[R]
must match the target\[aq]s default address space\[aq]s (address space
0) pointer type.
.RE
.SS \[aq]\f[V]llvm.prefetch\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.prefetch(i8* <address>, i32 <rw>, i32 <locality>, i32 <cache type>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.prefetch\f[R]\[aq] intrinsic is a hint to the code
generator to insert a prefetch instruction if supported; otherwise, it
is a noop.
Prefetches have no effect on the behavior of the program but can change
its performance characteristics.
.SS Arguments:
.PP
\f[V]address\f[R] is the address to be prefetched, \f[V]rw\f[R] is the
specifier determining if the fetch should be for a read (0) or write
(1), and \f[V]locality\f[R] is a temporal locality specifier ranging
from (0) - no locality, to (3) - extremely local keep in cache.
The \f[V]cache type\f[R] specifies whether the prefetch is performed on
the data (1) or instruction (0) cache.
The \f[V]rw\f[R], \f[V]locality\f[R] and \f[V]cache type\f[R] arguments
must be constant integers.
.SS Semantics:
.PP
This intrinsic does not modify the behavior of the program.
In particular, prefetches cannot trap and do not produce a value.
On targets that support this intrinsic, the prefetch can provide hints
to the processor cache for better performance.
.SS \[aq]\f[V]llvm.pcmarker\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.pcmarker(i32 <id>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.pcmarker\f[R]\[aq] intrinsic is a method to export a
Program Counter (PC) in a region of code to simulators and other tools.
The method is target specific, but it is expected that the marker will
use exported symbols to transmit the PC of the marker.
The marker makes no guarantees that it will remain with any specific
instruction after optimizations.
It is possible that the presence of a marker will inhibit optimizations.
The intended use is to be inserted after optimizations to allow
correlations of simulation runs.
.SS Arguments:
.PP
\f[V]id\f[R] is a numerical id identifying the marker.
.SS Semantics:
.PP
This intrinsic does not modify the behavior of the program.
Backends that do not support this intrinsic may ignore it.
.SS \[aq]\f[V]llvm.readcyclecounter\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i64 \[at]llvm.readcyclecounter()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.readcyclecounter\f[R]\[aq] intrinsic provides access
to the cycle counter register (or similar low latency, high accuracy
clocks) on those targets that support it.
On X86, it should map to RDTSC.
On Alpha, it should map to RPCC.
As the backing counters overflow quickly (on the order of 9 seconds on
alpha), this should only be used for small timings.
.SS Semantics:
.PP
When directly supported, reading the cycle counter should not modify any
memory.
Implementations are allowed to either return an application specific
value or a system wide value.
On backends without support, this is lowered to a constant 0.
.PP
Note that runtime support may be conditional on the privilege-level code
is running at and the host platform.
.SS \[aq]\f[V]llvm.clear_cache\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.clear_cache(i8*, i8*)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.clear_cache\f[R]\[aq] intrinsic ensures visibility of
modifications in the specified range to the execution unit of the
processor.
On targets with non-unified instruction and data cache, the
implementation flushes the instruction cache.
.SS Semantics:
.PP
On platforms with coherent instruction and data caches (e.g.
x86), this intrinsic is a nop.
On platforms with non-coherent instruction and data cache (e.g.
ARM, MIPS), the intrinsic is lowered either to appropriate instructions
or a system call, if cache flushing requires special privileges.
.PP
The default behavior is to emit a call to \f[V]__clear_cache\f[R] from
the run time library.
.PP
This intrinsic does \f[I]not\f[R] empty the instruction pipeline.
Modifications of the current function are outside the scope of the
intrinsic.
.SS \[aq]\f[V]llvm.instrprof.increment\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.instrprof.increment(i8* <name>, i64 <hash>,
                                       i32 <num-counters>, i32 <index>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.instrprof.increment\f[R]\[aq] intrinsic can be
emitted by a frontend for use with instrumentation based profiling.
These will be lowered by the \f[V]-instrprof\f[R] pass to generate
execution counts of a program at runtime.
.SS Arguments:
.PP
The first argument is a pointer to a global variable containing the name
of the entity being instrumented.
This should generally be the (mangled) function name for a set of
counters.
.PP
The second argument is a hash value that can be used by the consumer of
the profile data to detect changes to the instrumented source, and the
third is the number of counters associated with \f[V]name\f[R].
It is an error if \f[V]hash\f[R] or \f[V]num-counters\f[R] differ
between two instances of \f[V]instrprof.increment\f[R] that refer to the
same name.
.PP
The last argument refers to which of the counters for \f[V]name\f[R]
should be incremented.
It should be a value between 0 and \f[V]num-counters\f[R].
.SS Semantics:
.PP
This intrinsic represents an increment of a profiling counter.
It will cause the \f[V]-instrprof\f[R] pass to generate the appropriate
data structures and the code to increment the appropriate value, in a
format that can be written out by a compiler runtime and consumed via
the \f[V]llvm-profdata\f[R] tool.
.SS \[aq]\f[V]llvm.instrprof.increment.step\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.instrprof.increment.step(i8* <name>, i64 <hash>,
                                            i32 <num-counters>,
                                            i32 <index>, i64 <step>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.instrprof.increment.step\f[R]\[aq] intrinsic is an
extension to the \[aq]\f[V]llvm.instrprof.increment\f[R]\[aq] intrinsic
with an additional fifth argument to specify the step of the increment.
.SS Arguments:
.PP
The first four arguments are the same as
\[aq]\f[V]llvm.instrprof.increment\f[R]\[aq] intrinsic.
.PP
The last argument specifies the value of the increment of the counter
variable.
.SS Semantics:
.PP
See description of \[aq]\f[V]llvm.instrprof.increment\f[R]\[aq]
intrinsic.
.SS \[aq]\f[V]llvm.instrprof.cover\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.instrprof.cover(i8* <name>, i64 <hash>,
                                   i32 <num-counters>, i32 <index>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.instrprof.cover\f[R]\[aq] intrinsic is used to
implement coverage instrumentation.
.SS Arguments:
.PP
The arguments are the same as the first four arguments of
\[aq]\f[V]llvm.instrprof.increment\f[R]\[aq].
.SS Semantics:
.PP
Similar to the \[aq]\f[V]llvm.instrprof.increment\f[R]\[aq] intrinsic,
but it stores zero to the profiling variable to signify that the
function has been covered.
We store zero because this is more efficient on some targets.
.SS \[aq]\f[V]llvm.instrprof.value.profile\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.instrprof.value.profile(i8* <name>, i64 <hash>,
                                           i64 <value>, i32 <value_kind>,
                                           i32 <index>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.instrprof.value.profile\f[R]\[aq] intrinsic can be
emitted by a frontend for use with instrumentation based profiling.
This will be lowered by the \f[V]-instrprof\f[R] pass to find out the
target values, instrumented expressions take in a program at runtime.
.SS Arguments:
.PP
The first argument is a pointer to a global variable containing the name
of the entity being instrumented.
\f[V]name\f[R] should generally be the (mangled) function name for a set
of counters.
.PP
The second argument is a hash value that can be used by the consumer of
the profile data to detect changes to the instrumented source.
It is an error if \f[V]hash\f[R] differs between two instances of
\f[V]llvm.instrprof.*\f[R] that refer to the same name.
.PP
The third argument is the value of the expression being profiled.
The profiled expression\[aq]s value should be representable as an
unsigned 64-bit value.
The fourth argument represents the kind of value profiling that is being
done.
The supported value profiling kinds are enumerated through the
\f[V]InstrProfValueKind\f[R] type declared in the
\f[V]<include/llvm/ProfileData/InstrProf.h>\f[R] header file.
The last argument is the index of the instrumented expression within
\f[V]name\f[R].
It should be >= 0.
.SS Semantics:
.PP
This intrinsic represents the point where a call to a runtime routine
should be inserted for value profiling of target expressions.
\f[V]-instrprof\f[R] pass will generate the appropriate data structures
and replace the \f[V]llvm.instrprof.value.profile\f[R] intrinsic with
the call to the profile runtime library with proper arguments.
.SS \[aq]\f[V]llvm.thread.pointer\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.thread.pointer()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.thread.pointer\f[R]\[aq] intrinsic returns the value
of the thread pointer.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.thread.pointer\f[R]\[aq] intrinsic returns a pointer
to the TLS area for the current thread.
The exact semantics of this value are target specific: it may point to
the start of TLS area, to the end, or somewhere in the middle.
Depending on the target, this intrinsic may read a register, call a
helper function, read from an alternate memory space, or perform other
operations necessary to locate the TLS area.
Not all targets support this intrinsic.
.SS \[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare token \[at]llvm.call.preallocated.setup(i32 %num_args)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] intrinsic returns a
token which can be used with a call\[aq]s
\f[V]\[dq]preallocated\[dq]\f[R] operand bundle to indicate that certain
arguments are allocated and initialized before the call.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] intrinsic returns a
token which is associated with at most one call.
The token can be passed to
\[aq]\f[V]\[at]llvm.call.preallocated.arg\f[R]\[aq] to get a pointer to
get that corresponding argument.
The token must be the parameter to a \f[V]\[dq]preallocated\[dq]\f[R]
operand bundle for the corresponding call.
.PP
Nested calls to \[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] are
allowed, but must be properly nested.
e.g.
.PP
:: code-block:: llvm
.RS
.PP
%t1 = call token \[at]llvm.call.preallocated.setup(i32 0) %t2 = call
token \[at]llvm.call.preallocated.setup(i32 0) call void foo()
[\[dq]preallocated\[dq](token %t2)] call void foo()
[\[dq]preallocated\[dq](token %t1)]
.RE
.PP
is allowed, but not
.PP
:: code-block:: llvm
.RS
.PP
%t1 = call token \[at]llvm.call.preallocated.setup(i32 0) %t2 = call
token \[at]llvm.call.preallocated.setup(i32 0) call void foo()
[\[dq]preallocated\[dq](token %t1)] call void foo()
[\[dq]preallocated\[dq](token %t2)]
.RE
.SS \[aq]\f[V]llvm.call.preallocated.arg\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.call.preallocated.arg(token %setup_token, i32 %arg_index)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.call.preallocated.arg\f[R]\[aq] intrinsic returns a
pointer to the corresponding preallocated argument for the preallocated
call.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.call.preallocated.arg\f[R]\[aq] intrinsic returns a
pointer to the \f[V]%arg_index\f[R]th argument with the
\f[V]preallocated\f[R] attribute for the call associated with the
\f[V]%setup_token\f[R], which must be from
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq].
.PP
A call to \[aq]\f[V]llvm.call.preallocated.arg\f[R]\[aq] must have a
call site \f[V]preallocated\f[R] attribute.
The type of the \f[V]preallocated\f[R] attribute must match the type
used by the \f[V]preallocated\f[R] attribute of the corresponding
argument at the preallocated call.
The type is used in the case that an
\f[V]llvm.call.preallocated.setup\f[R] does not have a corresponding
call (e.g.
due to DCE), where otherwise we cannot know how large the arguments are.
.PP
It is undefined behavior if this is called with a token from an
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] if another
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] has already been called
or if the preallocated call corresponding to the
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] has already been
called.
.SS \[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.call.preallocated.teardown(token %setup_token)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] intrinsic cleans
up the stack created by a
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq].
.SS Semantics:
.PP
The token argument must be a
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq].
.PP
The \[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] intrinsic cleans
up the stack allocated by the corresponding
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq].
Exactly one of this or the preallocated call must be called to prevent
stack leaks.
It is undefined behavior to call both a
\[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] and the preallocated
call for a given \[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq].
.PP
For example, if the stack is allocated for a preallocated call by a
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq], then an initializer
function called on an allocated argument throws an exception, there
should be a \[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] in the
exception handler to prevent stack leaks.
.PP
Following the nesting rules in
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq], nested calls to
\[aq]\f[V]llvm.call.preallocated.setup\f[R]\[aq] and
\[aq]\f[V]llvm.call.preallocated.teardown\f[R]\[aq] are allowed but must
be properly nested.
.SS Example:
.IP
.nf
\f[C]
%cs = call token \[at]llvm.call.preallocated.setup(i32 1)
%x = call i8* \[at]llvm.call.preallocated.arg(token %cs, i32 0) preallocated(i32)
%y = bitcast i8* %x to i32*
invoke void \[at]constructor(i32* %y) to label %conta unwind label %contb
conta:
call void \[at]foo1(i32* preallocated(i32) %y) [\[dq]preallocated\[dq](token %cs)]
ret void
contb:
%s = catchswitch within none [label %catch] unwind to caller
catch:
%p = catchpad within %s []
call void \[at]llvm.call.preallocated.teardown(token %cs)
ret void
\f[R]
.fi
.SS Standard C/C++ Library Intrinsics
.PP
LLVM provides intrinsics for a few important standard C/C++ library
functions.
These intrinsics allow source-language front-ends to pass information
about the alignment of the pointer arguments to the code generator,
providing opportunity for more efficient code generation.
.SS \[aq]\f[V]llvm.abs.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.abs\f[R] on any integer bit width or any vector of
integer elements.
.IP
.nf
\f[C]
declare i32 \[at]llvm.abs.i32(i32 <src>, i1 <is_int_min_poison>)
declare <4 x i32> \[at]llvm.abs.v4i32(<4 x i32> <src>, i1 <is_int_min_poison>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.abs\f[R]\[aq] family of intrinsic functions returns
the absolute value of an argument.
.SS Arguments:
.PP
The first argument is the value for which the absolute value is to be
returned.
This argument may be of any integer type or a vector with integer
element type.
The return type must match the first argument type.
.PP
The second argument must be a constant and is a flag to indicate whether
the result value of the \[aq]\f[V]llvm.abs\f[R]\[aq] intrinsic is a
\f[V]poison value <poisonvalues>\f[R] if the argument is statically or
dynamically an \f[V]INT_MIN\f[R] value.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.abs\f[R]\[aq] intrinsic returns the magnitude (always
positive) of the argument or each element of a vector argument.\[dq].
If the argument is \f[V]INT_MIN\f[R], then the result is also
\f[V]INT_MIN\f[R] if \f[V]is_int_min_poison == 0\f[R] and
\f[V]poison\f[R] otherwise.
.SS \[aq]\f[V]llvm.smax.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]\[at]llvm.smax\f[R] on any integer bit width or any
vector of integer elements.
.IP
.nf
\f[C]
declare i32 \[at]llvm.smax.i32(i32 %a, i32 %b)
declare <4 x i32> \[at]llvm.smax.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
Return the larger of \f[V]%a\f[R] and \f[V]%b\f[R] comparing the values
as signed integers.
Vector intrinsics operate on a per-element basis.
The larger element of \f[V]%a\f[R] and \f[V]%b\f[R] at a given index is
returned for that index.
.SS Arguments:
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) may be of any integer type
or a vector with integer element type.
The argument types must match each other, and the return type must match
the argument type.
.SS \[aq]\f[V]llvm.smin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]\[at]llvm.smin\f[R] on any integer bit width or any
vector of integer elements.
.IP
.nf
\f[C]
declare i32 \[at]llvm.smin.i32(i32 %a, i32 %b)
declare <4 x i32> \[at]llvm.smin.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
Return the smaller of \f[V]%a\f[R] and \f[V]%b\f[R] comparing the values
as signed integers.
Vector intrinsics operate on a per-element basis.
The smaller element of \f[V]%a\f[R] and \f[V]%b\f[R] at a given index is
returned for that index.
.SS Arguments:
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) may be of any integer type
or a vector with integer element type.
The argument types must match each other, and the return type must match
the argument type.
.SS \[aq]\f[V]llvm.umax.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]\[at]llvm.umax\f[R] on any integer bit width or any
vector of integer elements.
.IP
.nf
\f[C]
declare i32 \[at]llvm.umax.i32(i32 %a, i32 %b)
declare <4 x i32> \[at]llvm.umax.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
Return the larger of \f[V]%a\f[R] and \f[V]%b\f[R] comparing the values
as unsigned integers.
Vector intrinsics operate on a per-element basis.
The larger element of \f[V]%a\f[R] and \f[V]%b\f[R] at a given index is
returned for that index.
.SS Arguments:
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) may be of any integer type
or a vector with integer element type.
The argument types must match each other, and the return type must match
the argument type.
.SS \[aq]\f[V]llvm.umin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]\[at]llvm.umin\f[R] on any integer bit width or any
vector of integer elements.
.IP
.nf
\f[C]
declare i32 \[at]llvm.umin.i32(i32 %a, i32 %b)
declare <4 x i32> \[at]llvm.umin.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
Return the smaller of \f[V]%a\f[R] and \f[V]%b\f[R] comparing the values
as unsigned integers.
Vector intrinsics operate on a per-element basis.
The smaller element of \f[V]%a\f[R] and \f[V]%b\f[R] at a given index is
returned for that index.
.SS Arguments:
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) may be of any integer type
or a vector with integer element type.
The argument types must match each other, and the return type must match
the argument type.
.SS \[aq]\f[V]llvm.memcpy\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memcpy\f[R] on any integer bit width and for
different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memcpy.p0i8.p0i8.i32(i8* <dest>, i8* <src>,
                                        i32 <len>, i1 <isvolatile>)
declare void \[at]llvm.memcpy.p0i8.p0i8.i64(i8* <dest>, i8* <src>,
                                        i64 <len>, i1 <isvolatile>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memcpy.*\f[R]\[aq] intrinsics copy a block of memory
from the source location to the destination location.
.PP
Note that, unlike the standard libc function, the
\f[V]llvm.memcpy.*\f[R] intrinsics do not return a value, takes extra
isvolatile arguments and the pointers can be in specified address
spaces.
.SS Arguments:
.PP
The first argument is a pointer to the destination, the second is a
pointer to the source.
The third argument is an integer argument specifying the number of bytes
to copy, and the fourth is a boolean indicating a volatile access.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first and second arguments.
.PP
If the \f[V]isvolatile\f[R] parameter is \f[V]true\f[R], the
\f[V]llvm.memcpy\f[R] call is a \f[V]volatile operation <volatile>\f[R].
The detailed access behavior is not very cleanly specified and it is
unwise to depend on it.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memcpy.*\f[R]\[aq] intrinsics copy a block of memory
from the source location to the destination location, which must either
be equal or non-overlapping.
It copies \[dq]len\[dq] bytes of memory over.
If the argument is known to be aligned to some boundary, this can be
specified as an attribute on the argument.
.PP
If \f[V]<len>\f[R] is 0, it is no-op modulo the behavior of attributes
attached to the arguments.
If \f[V]<len>\f[R] is not a well-defined value, the behavior is
undefined.
If \f[V]<len>\f[R] is not zero, both \f[V]<dest>\f[R] and
\f[V]<src>\f[R] should be well-defined, otherwise the behavior is
undefined.
.SS \[aq]\f[V]llvm.memcpy.inline\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memcpy.inline\f[R] on any integer bit width and
for different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memcpy.inline.p0i8.p0i8.i32(i8* <dest>, i8* <src>,
                                               i32 <len>, i1 <isvolatile>)
declare void \[at]llvm.memcpy.inline.p0i8.p0i8.i64(i8* <dest>, i8* <src>,
                                               i64 <len>, i1 <isvolatile>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memcpy.inline.*\f[R]\[aq] intrinsics copy a block of
memory from the source location to the destination location and
guarantees that no external functions are called.
.PP
Note that, unlike the standard libc function, the
\f[V]llvm.memcpy.inline.*\f[R] intrinsics do not return a value, takes
extra isvolatile arguments and the pointers can be in specified address
spaces.
.SS Arguments:
.PP
The first argument is a pointer to the destination, the second is a
pointer to the source.
The third argument is a constant integer argument specifying the number
of bytes to copy, and the fourth is a boolean indicating a volatile
access.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first and second arguments.
.PP
If the \f[V]isvolatile\f[R] parameter is \f[V]true\f[R], the
\f[V]llvm.memcpy.inline\f[R] call is a
\f[V]volatile operation <volatile>\f[R].
The detailed access behavior is not very cleanly specified and it is
unwise to depend on it.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memcpy.inline.*\f[R]\[aq] intrinsics copy a block of
memory from the source location to the destination location, which are
not allowed to overlap.
It copies \[dq]len\[dq] bytes of memory over.
If the argument is known to be aligned to some boundary, this can be
specified as an attribute on the argument.
The behavior of \[aq]\f[V]llvm.memcpy.inline.*\f[R]\[aq] is equivalent
to the behavior of \[aq]\f[V]llvm.memcpy.*\f[R]\[aq], but the generated
code is guaranteed not to call any external functions.
.SS \[aq]\f[V]llvm.memmove\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use llvm.memmove on any integer bit width and for different
address space.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memmove.p0i8.p0i8.i32(i8* <dest>, i8* <src>,
                                         i32 <len>, i1 <isvolatile>)
declare void \[at]llvm.memmove.p0i8.p0i8.i64(i8* <dest>, i8* <src>,
                                         i64 <len>, i1 <isvolatile>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memmove.*\f[R]\[aq] intrinsics move a block of memory
from the source location to the destination location.
It is similar to the \[aq]\f[V]llvm.memcpy\f[R]\[aq] intrinsic but
allows the two memory locations to overlap.
.PP
Note that, unlike the standard libc function, the
\f[V]llvm.memmove.*\f[R] intrinsics do not return a value, takes an
extra isvolatile argument and the pointers can be in specified address
spaces.
.SS Arguments:
.PP
The first argument is a pointer to the destination, the second is a
pointer to the source.
The third argument is an integer argument specifying the number of bytes
to copy, and the fourth is a boolean indicating a volatile access.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first and second arguments.
.PP
If the \f[V]isvolatile\f[R] parameter is \f[V]true\f[R], the
\f[V]llvm.memmove\f[R] call is a
\f[V]volatile operation <volatile>\f[R].
The detailed access behavior is not very cleanly specified and it is
unwise to depend on it.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memmove.*\f[R]\[aq] intrinsics copy a block of memory
from the source location to the destination location, which may overlap.
It copies \[dq]len\[dq] bytes of memory over.
If the argument is known to be aligned to some boundary, this can be
specified as an attribute on the argument.
.PP
If \f[V]<len>\f[R] is 0, it is no-op modulo the behavior of attributes
attached to the arguments.
If \f[V]<len>\f[R] is not a well-defined value, the behavior is
undefined.
If \f[V]<len>\f[R] is not zero, both \f[V]<dest>\f[R] and
\f[V]<src>\f[R] should be well-defined, otherwise the behavior is
undefined.
.SS \[aq]\f[V]llvm.memset.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use llvm.memset on any integer bit width and for different
address spaces.
However, not all targets support all bit widths.
.IP
.nf
\f[C]
declare void \[at]llvm.memset.p0i8.i32(i8* <dest>, i8 <val>,
                                   i32 <len>, i1 <isvolatile>)
declare void \[at]llvm.memset.p0i8.i64(i8* <dest>, i8 <val>,
                                   i64 <len>, i1 <isvolatile>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memset.*\f[R]\[aq] intrinsics fill a block of memory
with a particular byte value.
.PP
Note that, unlike the standard libc function, the \f[V]llvm.memset\f[R]
intrinsic does not return a value and takes an extra volatile argument.
Also, the destination can be in an arbitrary address space.
.SS Arguments:
.PP
The first argument is a pointer to the destination to fill, the second
is the byte value with which to fill it, the third argument is an
integer argument specifying the number of bytes to fill, and the fourth
is a boolean indicating a volatile access.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first arguments.
.PP
If the \f[V]isvolatile\f[R] parameter is \f[V]true\f[R], the
\f[V]llvm.memset\f[R] call is a \f[V]volatile operation <volatile>\f[R].
The detailed access behavior is not very cleanly specified and it is
unwise to depend on it.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memset.*\f[R]\[aq] intrinsics fill \[dq]len\[dq]
bytes of memory starting at the destination location.
If the argument is known to be aligned to some boundary, this can be
specified as an attribute on the argument.
.PP
If \f[V]<len>\f[R] is 0, it is no-op modulo the behavior of attributes
attached to the arguments.
If \f[V]<len>\f[R] is not a well-defined value, the behavior is
undefined.
If \f[V]<len>\f[R] is not zero, \f[V]<dest>\f[R] should be well-defined,
otherwise the behavior is undefined.
.SS \[aq]\f[V]llvm.memset.inline\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memset.inline\f[R] on any integer bit width and
for different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memset.inline.p0i8.p0i8.i32(i8* <dest>, i8 <val>,
                                               i32 <len>,
                                               i1 <isvolatile>)
declare void \[at]llvm.memset.inline.p0i8.p0i8.i64(i8* <dest>, i8 <val>,
                                               i64 <len>,
                                               i1 <isvolatile>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memset.inline.*\f[R]\[aq] intrinsics fill a block of
memory with a particular byte value and guarantees that no external
functions are called.
.PP
Note that, unlike the standard libc function, the
\f[V]llvm.memset.inline.*\f[R] intrinsics do not return a value, take an
extra isvolatile argument and the pointer can be in specified address
spaces.
.SS Arguments:
.PP
The first argument is a pointer to the destination to fill, the second
is the byte value with which to fill it, the third argument is a
constant integer argument specifying the number of bytes to fill, and
the fourth is a boolean indicating a volatile access.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first argument.
.PP
If the \f[V]isvolatile\f[R] parameter is \f[V]true\f[R], the
\f[V]llvm.memset.inline\f[R] call is a
\f[V]volatile operation <volatile>\f[R].
The detailed access behavior is not very cleanly specified and it is
unwise to depend on it.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memset.inline.*\f[R]\[aq] intrinsics fill
\[dq]len\[dq] bytes of memory starting at the destination location.
If the argument is known to be aligned to some boundary, this can be
specified as an attribute on the argument.
.PP
\f[V]len\f[R] must be a constant expression.
If \f[V]<len>\f[R] is 0, it is no-op modulo the behavior of attributes
attached to the arguments.
If \f[V]<len>\f[R] is not a well-defined value, the behavior is
undefined.
If \f[V]<len>\f[R] is not zero, \f[V]<dest>\f[R] should be well-defined,
otherwise the behavior is undefined.
.PP
The behavior of \[aq]\f[V]llvm.memset.inline.*\f[R]\[aq] is equivalent
to the behavior of \[aq]\f[V]llvm.memset.*\f[R]\[aq], but the generated
code is guaranteed not to call any external functions.
.SS \[aq]\f[V]llvm.sqrt.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sqrt\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.sqrt.f32(float %Val)
declare double    \[at]llvm.sqrt.f64(double %Val)
declare x86_fp80  \[at]llvm.sqrt.f80(x86_fp80 %Val)
declare fp128     \[at]llvm.sqrt.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.sqrt.ppcf128(ppc_fp128 %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.sqrt\f[R]\[aq] intrinsics return the square root of
the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]sqrt\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
For types specified by IEEE-754, the result matches a conforming libm
implementation.
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.powi.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.powi\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.PP
Generally, the only supported type for the exponent is the one matching
with the C type \f[V]int\f[R].
.IP
.nf
\f[C]
declare float     \[at]llvm.powi.f32.i32(float  %Val, i32 %power)
declare double    \[at]llvm.powi.f64.i16(double %Val, i16 %power)
declare x86_fp80  \[at]llvm.powi.f80.i32(x86_fp80  %Val, i32 %power)
declare fp128     \[at]llvm.powi.f128.i32(fp128 %Val, i32 %power)
declare ppc_fp128 \[at]llvm.powi.ppcf128.i32(ppc_fp128  %Val, i32 %power)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.powi.*\f[R]\[aq] intrinsics return the first operand
raised to the specified (positive or negative) power.
The order of evaluation of multiplications is not defined.
When a vector of floating-point type is used, the second argument
remains a scalar integer value.
.SS Arguments:
.PP
The second argument is an integer power, and the first is a value to
raise to that power.
.SS Semantics:
.PP
This function returns the first value raised to the second power with an
unspecified sequence of rounding operations.
.SS \[aq]\f[V]llvm.sin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sin\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.sin.f32(float  %Val)
declare double    \[at]llvm.sin.f64(double %Val)
declare x86_fp80  \[at]llvm.sin.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.sin.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.sin.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.sin.*\f[R]\[aq] intrinsics return the sine of the
operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]sin\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.cos.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.cos\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.cos.f32(float  %Val)
declare double    \[at]llvm.cos.f64(double %Val)
declare x86_fp80  \[at]llvm.cos.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.cos.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.cos.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.cos.*\f[R]\[aq] intrinsics return the cosine of the
operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]cos\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.pow.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.pow\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.pow.f32(float  %Val, float %Power)
declare double    \[at]llvm.pow.f64(double %Val, double %Power)
declare x86_fp80  \[at]llvm.pow.f80(x86_fp80  %Val, x86_fp80 %Power)
declare fp128     \[at]llvm.pow.f128(fp128 %Val, fp128 %Power)
declare ppc_fp128 \[at]llvm.pow.ppcf128(ppc_fp128  %Val, ppc_fp128 Power)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.pow.*\f[R]\[aq] intrinsics return the first operand
raised to the specified (positive or negative) power.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]pow\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.exp.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.exp\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.exp.f32(float  %Val)
declare double    \[at]llvm.exp.f64(double %Val)
declare x86_fp80  \[at]llvm.exp.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.exp.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.exp.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.exp.*\f[R]\[aq] intrinsics compute the base-e
exponential of the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]exp\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.exp2.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.exp2\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.exp2.f32(float  %Val)
declare double    \[at]llvm.exp2.f64(double %Val)
declare x86_fp80  \[at]llvm.exp2.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.exp2.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.exp2.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.exp2.*\f[R]\[aq] intrinsics compute the base-2
exponential of the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]exp2\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.log.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.log\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.log.f32(float  %Val)
declare double    \[at]llvm.log.f64(double %Val)
declare x86_fp80  \[at]llvm.log.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.log.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.log.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.log.*\f[R]\[aq] intrinsics compute the base-e
logarithm of the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]log\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.log10.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.log10\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.log10.f32(float  %Val)
declare double    \[at]llvm.log10.f64(double %Val)
declare x86_fp80  \[at]llvm.log10.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.log10.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.log10.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.log10.*\f[R]\[aq] intrinsics compute the base-10
logarithm of the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]log10\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.log2.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.log2\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.log2.f32(float  %Val)
declare double    \[at]llvm.log2.f64(double %Val)
declare x86_fp80  \[at]llvm.log2.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.log2.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.log2.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.log2.*\f[R]\[aq] intrinsics compute the base-2
logarithm of the specified value.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]log2\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.fma.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fma\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.fma.f32(float  %a, float  %b, float  %c)
declare double    \[at]llvm.fma.f64(double %a, double %b, double %c)
declare x86_fp80  \[at]llvm.fma.f80(x86_fp80 %a, x86_fp80 %b, x86_fp80 %c)
declare fp128     \[at]llvm.fma.f128(fp128 %a, fp128 %b, fp128 %c)
declare ppc_fp128 \[at]llvm.fma.ppcf128(ppc_fp128 %a, ppc_fp128 %b, ppc_fp128 %c)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fma.*\f[R]\[aq] intrinsics perform the fused
multiply-add operation.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Return the same value as a corresponding libm \[aq]\f[V]fma\f[R]\[aq]
function but without trapping or setting \f[V]errno\f[R].
.PP
When specified with the fast-math-flag \[aq]afn\[aq], the result may be
approximated using a less accurate calculation.
.SS \[aq]\f[V]llvm.fabs.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fabs\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.fabs.f32(float  %Val)
declare double    \[at]llvm.fabs.f64(double %Val)
declare x86_fp80  \[at]llvm.fabs.f80(x86_fp80 %Val)
declare fp128     \[at]llvm.fabs.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.fabs.ppcf128(ppc_fp128 %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fabs.*\f[R]\[aq] intrinsics return the absolute value
of the operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]fabs\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.minnum.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.minnum\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.minnum.f32(float %Val0, float %Val1)
declare double    \[at]llvm.minnum.f64(double %Val0, double %Val1)
declare x86_fp80  \[at]llvm.minnum.f80(x86_fp80 %Val0, x86_fp80 %Val1)
declare fp128     \[at]llvm.minnum.f128(fp128 %Val0, fp128 %Val1)
declare ppc_fp128 \[at]llvm.minnum.ppcf128(ppc_fp128 %Val0, ppc_fp128 %Val1)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.minnum.*\f[R]\[aq] intrinsics return the minimum of
the two arguments.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Follows the IEEE-754 semantics for minNum, except for handling of
signaling NaNs.
This match\[aq]s the behavior of libm\[aq]s fmin.
.PP
If either operand is a NaN, returns the other non-NaN operand.
Returns NaN only if both operands are NaN.
The returned NaN is always quiet.
If the operands compare equal, returns a value that compares equal to
both operands.
This means that fmin(+/-0.0, +/-0.0) could return either -0.0 or 0.0.
.PP
Unlike the IEEE-754 2008 behavior, this does not distinguish between
signaling and quiet NaN inputs.
If a target\[aq]s implementation follows the standard and returns a
quiet NaN if either input is a signaling NaN, the intrinsic lowering is
responsible for quieting the inputs to correctly return the non-NaN
input (e.g.
by using the equivalent of \f[V]llvm.canonicalize\f[R]).
.SS \[aq]\f[V]llvm.maxnum.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.maxnum\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.maxnum.f32(float  %Val0, float  %Val1)
declare double    \[at]llvm.maxnum.f64(double %Val0, double %Val1)
declare x86_fp80  \[at]llvm.maxnum.f80(x86_fp80  %Val0, x86_fp80  %Val1)
declare fp128     \[at]llvm.maxnum.f128(fp128 %Val0, fp128 %Val1)
declare ppc_fp128 \[at]llvm.maxnum.ppcf128(ppc_fp128  %Val0, ppc_fp128  %Val1)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.maxnum.*\f[R]\[aq] intrinsics return the maximum of
the two arguments.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
Follows the IEEE-754 semantics for maxNum except for the handling of
signaling NaNs.
This matches the behavior of libm\[aq]s fmax.
.PP
If either operand is a NaN, returns the other non-NaN operand.
Returns NaN only if both operands are NaN.
The returned NaN is always quiet.
If the operands compare equal, returns a value that compares equal to
both operands.
This means that fmax(+/-0.0, +/-0.0) could return either -0.0 or 0.0.
.PP
Unlike the IEEE-754 2008 behavior, this does not distinguish between
signaling and quiet NaN inputs.
If a target\[aq]s implementation follows the standard and returns a
quiet NaN if either input is a signaling NaN, the intrinsic lowering is
responsible for quieting the inputs to correctly return the non-NaN
input (e.g.
by using the equivalent of \f[V]llvm.canonicalize\f[R]).
.SS \[aq]\f[V]llvm.minimum.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.minimum\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.minimum.f32(float %Val0, float %Val1)
declare double    \[at]llvm.minimum.f64(double %Val0, double %Val1)
declare x86_fp80  \[at]llvm.minimum.f80(x86_fp80 %Val0, x86_fp80 %Val1)
declare fp128     \[at]llvm.minimum.f128(fp128 %Val0, fp128 %Val1)
declare ppc_fp128 \[at]llvm.minimum.ppcf128(ppc_fp128 %Val0, ppc_fp128 %Val1)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.minimum.*\f[R]\[aq] intrinsics return the minimum of
the two arguments, propagating NaNs and treating -0.0 as less than +0.0.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
If either operand is a NaN, returns NaN.
Otherwise returns the lesser of the two arguments.
-0.0 is considered to be less than +0.0 for this intrinsic.
Note that these are the semantics specified in the draft of IEEE
754-2018.
.SS \[aq]\f[V]llvm.maximum.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.maximum\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.maximum.f32(float %Val0, float %Val1)
declare double    \[at]llvm.maximum.f64(double %Val0, double %Val1)
declare x86_fp80  \[at]llvm.maximum.f80(x86_fp80 %Val0, x86_fp80 %Val1)
declare fp128     \[at]llvm.maximum.f128(fp128 %Val0, fp128 %Val1)
declare ppc_fp128 \[at]llvm.maximum.ppcf128(ppc_fp128 %Val0, ppc_fp128 %Val1)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.maximum.*\f[R]\[aq] intrinsics return the maximum of
the two arguments, propagating NaNs and treating -0.0 as less than +0.0.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
If either operand is a NaN, returns NaN.
Otherwise returns the greater of the two arguments.
-0.0 is considered to be less than +0.0 for this intrinsic.
Note that these are the semantics specified in the draft of IEEE
754-2018.
.SS \[aq]\f[V]llvm.copysign.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.copysign\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.copysign.f32(float  %Mag, float  %Sgn)
declare double    \[at]llvm.copysign.f64(double %Mag, double %Sgn)
declare x86_fp80  \[at]llvm.copysign.f80(x86_fp80  %Mag, x86_fp80  %Sgn)
declare fp128     \[at]llvm.copysign.f128(fp128 %Mag, fp128 %Sgn)
declare ppc_fp128 \[at]llvm.copysign.ppcf128(ppc_fp128  %Mag, ppc_fp128  %Sgn)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.copysign.*\f[R]\[aq] intrinsics return a value with
the magnitude of the first operand and the sign of the second operand.
.SS Arguments:
.PP
The arguments and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]copysign\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.floor.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.floor\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.floor.f32(float  %Val)
declare double    \[at]llvm.floor.f64(double %Val)
declare x86_fp80  \[at]llvm.floor.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.floor.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.floor.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.floor.*\f[R]\[aq] intrinsics return the floor of the
operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]floor\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.ceil.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.ceil\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.ceil.f32(float  %Val)
declare double    \[at]llvm.ceil.f64(double %Val)
declare x86_fp80  \[at]llvm.ceil.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.ceil.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.ceil.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ceil.*\f[R]\[aq] intrinsics return the ceiling of the
operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]ceil\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.trunc.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.trunc\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.trunc.f32(float  %Val)
declare double    \[at]llvm.trunc.f64(double %Val)
declare x86_fp80  \[at]llvm.trunc.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.trunc.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.trunc.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.trunc.*\f[R]\[aq] intrinsics returns the operand
rounded to the nearest integer not larger in magnitude than the operand.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]trunc\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.rint.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.rint\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.rint.f32(float  %Val)
declare double    \[at]llvm.rint.f64(double %Val)
declare x86_fp80  \[at]llvm.rint.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.rint.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.rint.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.rint.*\f[R]\[aq] intrinsics returns the operand
rounded to the nearest integer.
It may raise an inexact floating-point exception if the operand
isn\[aq]t an integer.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]rint\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.nearbyint.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.nearbyint\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.nearbyint.f32(float  %Val)
declare double    \[at]llvm.nearbyint.f64(double %Val)
declare x86_fp80  \[at]llvm.nearbyint.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.nearbyint.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.nearbyint.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.nearbyint.*\f[R]\[aq] intrinsics returns the operand
rounded to the nearest integer.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]nearbyint\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.round.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.round\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.round.f32(float  %Val)
declare double    \[at]llvm.round.f64(double %Val)
declare x86_fp80  \[at]llvm.round.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.round.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.round.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.round.*\f[R]\[aq] intrinsics returns the operand
rounded to the nearest integer.
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]round\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.roundeven.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.roundeven\f[R] on any floating-point or vector of
floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare float     \[at]llvm.roundeven.f32(float  %Val)
declare double    \[at]llvm.roundeven.f64(double %Val)
declare x86_fp80  \[at]llvm.roundeven.f80(x86_fp80  %Val)
declare fp128     \[at]llvm.roundeven.f128(fp128 %Val)
declare ppc_fp128 \[at]llvm.roundeven.ppcf128(ppc_fp128  %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.roundeven.*\f[R]\[aq] intrinsics returns the operand
rounded to the nearest integer in floating-point format rounding halfway
cases to even (that is, to the nearest value that is an even integer).
.SS Arguments:
.PP
The argument and return value are floating-point numbers of the same
type.
.SS Semantics:
.PP
This function implements IEEE-754 operation
\f[V]roundToIntegralTiesToEven\f[R].
It also behaves in the same way as C standard function
\f[V]roundeven\f[R], except that it does not raise floating point
exceptions.
.SS \[aq]\f[V]llvm.lround.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.lround\f[R] on any floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare i32 \[at]llvm.lround.i32.f32(float %Val)
declare i32 \[at]llvm.lround.i32.f64(double %Val)
declare i32 \[at]llvm.lround.i32.f80(float %Val)
declare i32 \[at]llvm.lround.i32.f128(double %Val)
declare i32 \[at]llvm.lround.i32.ppcf128(double %Val)

declare i64 \[at]llvm.lround.i64.f32(float %Val)
declare i64 \[at]llvm.lround.i64.f64(double %Val)
declare i64 \[at]llvm.lround.i64.f80(float %Val)
declare i64 \[at]llvm.lround.i64.f128(double %Val)
declare i64 \[at]llvm.lround.i64.ppcf128(double %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.lround.*\f[R]\[aq] intrinsics return the operand
rounded to the nearest integer with ties away from zero.
.SS Arguments:
.PP
The argument is a floating-point number and the return value is an
integer type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]lround\f[R]
functions would, but without setting errno.
.SS \[aq]\f[V]llvm.llround.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.llround\f[R] on any floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare i64 \[at]llvm.lround.i64.f32(float %Val)
declare i64 \[at]llvm.lround.i64.f64(double %Val)
declare i64 \[at]llvm.lround.i64.f80(float %Val)
declare i64 \[at]llvm.lround.i64.f128(double %Val)
declare i64 \[at]llvm.lround.i64.ppcf128(double %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.llround.*\f[R]\[aq] intrinsics return the operand
rounded to the nearest integer with ties away from zero.
.SS Arguments:
.PP
The argument is a floating-point number and the return value is an
integer type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]llround\f[R]
functions would, but without setting errno.
.SS \[aq]\f[V]llvm.lrint.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.lrint\f[R] on any floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare i32 \[at]llvm.lrint.i32.f32(float %Val)
declare i32 \[at]llvm.lrint.i32.f64(double %Val)
declare i32 \[at]llvm.lrint.i32.f80(float %Val)
declare i32 \[at]llvm.lrint.i32.f128(double %Val)
declare i32 \[at]llvm.lrint.i32.ppcf128(double %Val)

declare i64 \[at]llvm.lrint.i64.f32(float %Val)
declare i64 \[at]llvm.lrint.i64.f64(double %Val)
declare i64 \[at]llvm.lrint.i64.f80(float %Val)
declare i64 \[at]llvm.lrint.i64.f128(double %Val)
declare i64 \[at]llvm.lrint.i64.ppcf128(double %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.lrint.*\f[R]\[aq] intrinsics return the operand
rounded to the nearest integer.
.SS Arguments:
.PP
The argument is a floating-point number and the return value is an
integer type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]lrint\f[R]
functions would, but without setting errno.
.SS \[aq]\f[V]llvm.llrint.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.llrint\f[R] on any floating-point type.
Not all targets support all types however.
.IP
.nf
\f[C]
declare i64 \[at]llvm.llrint.i64.f32(float %Val)
declare i64 \[at]llvm.llrint.i64.f64(double %Val)
declare i64 \[at]llvm.llrint.i64.f80(float %Val)
declare i64 \[at]llvm.llrint.i64.f128(double %Val)
declare i64 \[at]llvm.llrint.i64.ppcf128(double %Val)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.llrint.*\f[R]\[aq] intrinsics return the operand
rounded to the nearest integer.
.SS Arguments:
.PP
The argument is a floating-point number and the return value is an
integer type.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]llrint\f[R]
functions would, but without setting errno.
.SS Bit Manipulation Intrinsics
.PP
LLVM provides intrinsics for a few important bit manipulation
operations.
These allow efficient code generation for some algorithms.
.SS \[aq]\f[V]llvm.bitreverse.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic function.
You can use bitreverse on any integer type.
.IP
.nf
\f[C]
declare i16 \[at]llvm.bitreverse.i16(i16 <id>)
declare i32 \[at]llvm.bitreverse.i32(i32 <id>)
declare i64 \[at]llvm.bitreverse.i64(i64 <id>)
declare <4 x i32> \[at]llvm.bitreverse.v4i32(<4 x i32> <id>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.bitreverse\f[R]\[aq] family of intrinsics is used to
reverse the bitpattern of an integer value or vector of integer values;
for example \f[V]0b10110110\f[R] becomes \f[V]0b01101101\f[R].
.SS Semantics:
.PP
The \f[V]llvm.bitreverse.iN\f[R] intrinsic returns an iN value that has
bit \f[V]M\f[R] in the input moved to bit \f[V]N-M-1\f[R] in the output.
The vector intrinsics, such as \f[V]llvm.bitreverse.v4i32\f[R], operate
on a per-element basis and the element order is not affected.
.SS \[aq]\f[V]llvm.bswap.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic function.
You can use bswap on any integer type that is an even number of bytes
(i.e.
BitWidth % 16 == 0).
.IP
.nf
\f[C]
declare i16 \[at]llvm.bswap.i16(i16 <id>)
declare i32 \[at]llvm.bswap.i32(i32 <id>)
declare i64 \[at]llvm.bswap.i64(i64 <id>)
declare <4 x i32> \[at]llvm.bswap.v4i32(<4 x i32> <id>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.bswap\f[R]\[aq] family of intrinsics is used to byte
swap an integer value or vector of integer values with an even number of
bytes (positive multiple of 16 bits).
.SS Semantics:
.PP
The \f[V]llvm.bswap.i16\f[R] intrinsic returns an i16 value that has the
high and low byte of the input i16 swapped.
Similarly, the \f[V]llvm.bswap.i32\f[R] intrinsic returns an i32 value
that has the four bytes of the input i32 swapped, so that if the input
bytes are numbered 0, 1, 2, 3 then the returned i32 will have its bytes
in 3, 2, 1, 0 order.
The \f[V]llvm.bswap.i48\f[R], \f[V]llvm.bswap.i64\f[R] and other
intrinsics extend this concept to additional even-byte lengths (6 bytes,
8 bytes and more, respectively).
The vector intrinsics, such as \f[V]llvm.bswap.v4i32\f[R], operate on a
per-element basis and the element order is not affected.
.SS \[aq]\f[V]llvm.ctpop.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use llvm.ctpop on any integer bit width, or on any vector with
integer elements.
Not all targets support all bit widths or vector types, however.
.IP
.nf
\f[C]
declare i8 \[at]llvm.ctpop.i8(i8  <src>)
declare i16 \[at]llvm.ctpop.i16(i16 <src>)
declare i32 \[at]llvm.ctpop.i32(i32 <src>)
declare i64 \[at]llvm.ctpop.i64(i64 <src>)
declare i256 \[at]llvm.ctpop.i256(i256 <src>)
declare <2 x i32> \[at]llvm.ctpop.v2i32(<2 x i32> <src>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ctpop\f[R]\[aq] family of intrinsics counts the
number of bits set in a value.
.SS Arguments:
.PP
The only argument is the value to be counted.
The argument may be of any integer type, or a vector with integer
elements.
The return type must match the argument type.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.ctpop\f[R]\[aq] intrinsic counts the 1\[aq]s in a
variable, or within each element of a vector.
.SS \[aq]\f[V]llvm.ctlz.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.ctlz\f[R] on any integer bit width, or any vector
whose elements are integers.
Not all targets support all bit widths or vector types, however.
.IP
.nf
\f[C]
declare i8   \[at]llvm.ctlz.i8  (i8   <src>, i1 <is_zero_poison>)
declare <2 x i37> \[at]llvm.ctlz.v2i37(<2 x i37> <src>, i1 <is_zero_poison>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ctlz\f[R]\[aq] family of intrinsic functions counts
the number of leading zeros in a variable.
.SS Arguments:
.PP
The first argument is the value to be counted.
This argument may be of any integer type, or a vector with integer
element type.
The return type must match the first argument type.
.PP
The second argument is a constant flag that indicates whether the
intrinsic returns a valid result if the first argument is zero.
If the first argument is zero and the second argument is true, the
result is poison.
Historically some architectures did not provide a defined result for
zero values as efficiently, and many algorithms are now predicated on
avoiding zero-value inputs.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.ctlz\f[R]\[aq] intrinsic counts the leading (most
significant) zeros in a variable, or within each element of the vector.
If \f[V]src == 0\f[R] then the result is the size in bits of the type of
\f[V]src\f[R] if \f[V]is_zero_poison == 0\f[R] and \f[V]poison\f[R]
otherwise.
For example, \f[V]llvm.ctlz(i32 2) = 30\f[R].
.SS \[aq]\f[V]llvm.cttz.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.cttz\f[R] on any integer bit width, or any vector
of integer elements.
Not all targets support all bit widths or vector types, however.
.IP
.nf
\f[C]
declare i42   \[at]llvm.cttz.i42  (i42   <src>, i1 <is_zero_poison>)
declare <2 x i32> \[at]llvm.cttz.v2i32(<2 x i32> <src>, i1 <is_zero_poison>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.cttz\f[R]\[aq] family of intrinsic functions counts
the number of trailing zeros.
.SS Arguments:
.PP
The first argument is the value to be counted.
This argument may be of any integer type, or a vector with integer
element type.
The return type must match the first argument type.
.PP
The second argument is a constant flag that indicates whether the
intrinsic returns a valid result if the first argument is zero.
If the first argument is zero and the second argument is true, the
result is poison.
Historically some architectures did not provide a defined result for
zero values as efficiently, and many algorithms are now predicated on
avoiding zero-value inputs.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.cttz\f[R]\[aq] intrinsic counts the trailing (least
significant) zeros in a variable, or within each element of a vector.
If \f[V]src == 0\f[R] then the result is the size in bits of the type of
\f[V]src\f[R] if \f[V]is_zero_poison == 0\f[R] and \f[V]poison\f[R]
otherwise.
For example, \f[V]llvm.cttz(2) = 1\f[R].
.SS \[aq]\f[V]llvm.fshl.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fshl\f[R] on any integer bit width or any vector
of integer elements.
Not all targets support all bit widths or vector types, however.
.IP
.nf
\f[C]
declare i8  \[at]llvm.fshl.i8 (i8 %a, i8 %b, i8 %c)
declare i67 \[at]llvm.fshl.i67(i67 %a, i67 %b, i67 %c)
declare <2 x i32> \[at]llvm.fshl.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fshl\f[R]\[aq] family of intrinsic functions performs
a funnel shift left: the first two values are concatenated as { %a : %b
} (%a is the most significant bits of the wide value), the combined
value is shifted left, and the most significant bits are extracted to
produce a result that is the same size as the original arguments.
If the first 2 arguments are identical, this is equivalent to a rotate
left operation.
For vector types, the operation occurs for each element of the vector.
The shift argument is treated as an unsigned amount modulo the element
size of the arguments.
.SS Arguments:
.PP
The first two arguments are the values to be concatenated.
The third argument is the shift amount.
The arguments may be any integer type or a vector with integer element
type.
All arguments and the return value must have the same type.
.SS Example:
.IP
.nf
\f[C]
%r = call i8 \[at]llvm.fshl.i8(i8 %x, i8 %y, i8 %z)  ; %r = i8: msb_extract((concat(x, y) << (z % 8)), 8)
%r = call i8 \[at]llvm.fshl.i8(i8 255, i8 0, i8 15)  ; %r = i8: 128 (0b10000000)
%r = call i8 \[at]llvm.fshl.i8(i8 15, i8 15, i8 11)  ; %r = i8: 120 (0b01111000)
%r = call i8 \[at]llvm.fshl.i8(i8 0, i8 255, i8 8)   ; %r = i8: 0   (0b00000000)
\f[R]
.fi
.SS \[aq]\f[V]llvm.fshr.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fshr\f[R] on any integer bit width or any vector
of integer elements.
Not all targets support all bit widths or vector types, however.
.IP
.nf
\f[C]
declare i8  \[at]llvm.fshr.i8 (i8 %a, i8 %b, i8 %c)
declare i67 \[at]llvm.fshr.i67(i67 %a, i67 %b, i67 %c)
declare <2 x i32> \[at]llvm.fshr.v2i32(<2 x i32> %a, <2 x i32> %b, <2 x i32> %c)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fshr\f[R]\[aq] family of intrinsic functions performs
a funnel shift right: the first two values are concatenated as { %a : %b
} (%a is the most significant bits of the wide value), the combined
value is shifted right, and the least significant bits are extracted to
produce a result that is the same size as the original arguments.
If the first 2 arguments are identical, this is equivalent to a rotate
right operation.
For vector types, the operation occurs for each element of the vector.
The shift argument is treated as an unsigned amount modulo the element
size of the arguments.
.SS Arguments:
.PP
The first two arguments are the values to be concatenated.
The third argument is the shift amount.
The arguments may be any integer type or a vector with integer element
type.
All arguments and the return value must have the same type.
.SS Example:
.IP
.nf
\f[C]
%r = call i8 \[at]llvm.fshr.i8(i8 %x, i8 %y, i8 %z)  ; %r = i8: lsb_extract((concat(x, y) >> (z % 8)), 8)
%r = call i8 \[at]llvm.fshr.i8(i8 255, i8 0, i8 15)  ; %r = i8: 254 (0b11111110)
%r = call i8 \[at]llvm.fshr.i8(i8 15, i8 15, i8 11)  ; %r = i8: 225 (0b11100001)
%r = call i8 \[at]llvm.fshr.i8(i8 0, i8 255, i8 8)   ; %r = i8: 255 (0b11111111)
\f[R]
.fi
.SS Arithmetic with Overflow Intrinsics
.PP
LLVM provides intrinsics for fast arithmetic overflow checking.
.PP
Each of these intrinsics returns a two-element struct.
The first element of this struct contains the result of the
corresponding arithmetic operation modulo 2^n^, where n is the bit width
of the result.
Therefore, for example, the first element of the struct returned by
\f[V]llvm.sadd.with.overflow.i32\f[R] is always the same as the result
of a 32-bit \f[V]add\f[R] instruction with the same operands, where the
\f[V]add\f[R] is \f[I]not\f[R] modified by an \f[V]nsw\f[R] or
\f[V]nuw\f[R] flag.
.PP
The second element of the result is an \f[V]i1\f[R] that is 1 if the
arithmetic operation overflowed and 0 otherwise.
An operation overflows if, for any values of its operands \f[V]A\f[R]
and \f[V]B\f[R] and for any \f[V]N\f[R] larger than the operands\[aq]
width, \f[V]ext(A op B) to iN\f[R] is not equal to
\f[V](ext(A) to iN) op (ext(B) to iN)\f[R] where \f[V]ext\f[R] is
\f[V]sext\f[R] for signed overflow and \f[V]zext\f[R] for unsigned
overflow, and \f[V]op\f[R] is the underlying arithmetic operation.
.PP
The behavior of these intrinsics is well-defined for all argument
values.
.SS \[aq]\f[V]llvm.sadd.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sadd.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.sadd.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.sadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.sadd.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed addition of the two arguments, and indicate
whether an overflow occurred during the signed summation.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed addition.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.sadd.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed addition of the two variables.
They return a structure --- the first element of which is the signed
summation, and the second element of which is a bit specifying if the
signed summation resulted in an overflow.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.sadd.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %overflow, label %normal
\f[R]
.fi
.SS \[aq]\f[V]llvm.uadd.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.uadd.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.uadd.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.uadd.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.uadd.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.uadd.with.overflow\f[R]\[aq] family of intrinsic
functions perform an unsigned addition of the two arguments, and
indicate whether a carry occurred during the unsigned summation.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned addition.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.uadd.with.overflow\f[R]\[aq] family of intrinsic
functions perform an unsigned addition of the two arguments.
They return a structure --- the first element of which is the sum, and
the second element of which is a bit specifying if the unsigned
summation resulted in a carry.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.uadd.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %carry, label %normal
\f[R]
.fi
.SS \[aq]\f[V]llvm.ssub.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.ssub.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.ssub.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.ssub.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.ssub.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ssub.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed subtraction of the two arguments, and
indicate whether an overflow occurred during the signed subtraction.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed subtraction.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.ssub.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed subtraction of the two arguments.
They return a structure --- the first element of which is the
subtraction, and the second element of which is a bit specifying if the
signed subtraction resulted in an overflow.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.ssub.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %overflow, label %normal
\f[R]
.fi
.SS \[aq]\f[V]llvm.usub.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.usub.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.usub.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.usub.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.usub.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.usub.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.usub.with.overflow\f[R]\[aq] family of intrinsic
functions perform an unsigned subtraction of the two arguments, and
indicate whether an overflow occurred during the unsigned subtraction.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned subtraction.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.usub.with.overflow\f[R]\[aq] family of intrinsic
functions perform an unsigned subtraction of the two arguments.
They return a structure ---the first element of which is the
subtraction, and the second element of which is a bit specifying if the
unsigned subtraction resulted in an overflow.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.usub.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %overflow, label %normal
\f[R]
.fi
.SS \[aq]\f[V]llvm.smul.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.smul.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.smul.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.smul.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.smul.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.smul.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.smul.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed multiplication of the two arguments, and
indicate whether an overflow occurred during the signed multiplication.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed multiplication.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.smul.with.overflow\f[R]\[aq] family of intrinsic
functions perform a signed multiplication of the two arguments.
They return a structure ---the first element of which is the
multiplication, and the second element of which is a bit specifying if
the signed multiplication resulted in an overflow.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.smul.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %overflow, label %normal
\f[R]
.fi
.SS \[aq]\f[V]llvm.umul.with.overflow.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.umul.with.overflow\f[R] on any integer bit width
or vectors of integers.
.IP
.nf
\f[C]
declare {i16, i1} \[at]llvm.umul.with.overflow.i16(i16 %a, i16 %b)
declare {i32, i1} \[at]llvm.umul.with.overflow.i32(i32 %a, i32 %b)
declare {i64, i1} \[at]llvm.umul.with.overflow.i64(i64 %a, i64 %b)
declare {<4 x i32>, <4 x i1>} \[at]llvm.umul.with.overflow.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.umul.with.overflow\f[R]\[aq] family of intrinsic
functions perform a unsigned multiplication of the two arguments, and
indicate whether an overflow occurred during the unsigned
multiplication.
.SS Arguments:
.PP
The arguments (%a and %b) and the first element of the result structure
may be of integer types of any bit width, but they must have the same
bit width.
The second element of the result structure must be of type \f[V]i1\f[R].
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned multiplication.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.umul.with.overflow\f[R]\[aq] family of intrinsic
functions perform an unsigned multiplication of the two arguments.
They return a structure ---the first element of which is the
multiplication, and the second element of which is a bit specifying if
the unsigned multiplication resulted in an overflow.
.SS Examples:
.IP
.nf
\f[C]
%res = call {i32, i1} \[at]llvm.umul.with.overflow.i32(i32 %a, i32 %b)
%sum = extractvalue {i32, i1} %res, 0
%obit = extractvalue {i32, i1} %res, 1
br i1 %obit, label %overflow, label %normal
\f[R]
.fi
.SS Saturation Arithmetic Intrinsics
.PP
Saturation arithmetic is a version of arithmetic in which operations are
limited to a fixed range between a minimum and maximum value.
If the result of an operation is greater than the maximum value, the
result is set (or \[dq]clamped\[dq]) to this maximum.
If it is below the minimum, it is clamped to this minimum.
.SS \[aq]\f[V]llvm.sadd.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sadd.sat\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.sadd.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.sadd.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.sadd.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.sadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.sadd.sat\f[R]\[aq] family of intrinsic functions
perform signed saturating addition on the 2 arguments.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed addition.
.SS Semantics:
.PP
The maximum value this operation can clamp to is the largest signed
value representable by the bit width of the arguments.
The minimum value is the smallest signed value representable by this bit
width.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.sadd.sat.i4(i4 1, i4 2)  ; %res = 3
%res = call i4 \[at]llvm.sadd.sat.i4(i4 5, i4 6)  ; %res = 7
%res = call i4 \[at]llvm.sadd.sat.i4(i4 -4, i4 2)  ; %res = -2
%res = call i4 \[at]llvm.sadd.sat.i4(i4 -4, i4 -5)  ; %res = -8
\f[R]
.fi
.SS \[aq]\f[V]llvm.uadd.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.uadd.sat\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.uadd.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.uadd.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.uadd.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.uadd.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.uadd.sat\f[R]\[aq] family of intrinsic functions
perform unsigned saturating addition on the 2 arguments.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned addition.
.SS Semantics:
.PP
The maximum value this operation can clamp to is the largest unsigned
value representable by the bit width of the arguments.
Because this is an unsigned operation, the result will never saturate
towards zero.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.uadd.sat.i4(i4 1, i4 2)  ; %res = 3
%res = call i4 \[at]llvm.uadd.sat.i4(i4 5, i4 6)  ; %res = 11
%res = call i4 \[at]llvm.uadd.sat.i4(i4 8, i4 8)  ; %res = 15
\f[R]
.fi
.SS \[aq]\f[V]llvm.ssub.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.ssub.sat\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.ssub.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.ssub.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.ssub.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.ssub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.ssub.sat\f[R]\[aq] family of intrinsic functions
perform signed saturating subtraction on the 2 arguments.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed subtraction.
.SS Semantics:
.PP
The maximum value this operation can clamp to is the largest signed
value representable by the bit width of the arguments.
The minimum value is the smallest signed value representable by this bit
width.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.ssub.sat.i4(i4 2, i4 1)  ; %res = 1
%res = call i4 \[at]llvm.ssub.sat.i4(i4 2, i4 6)  ; %res = -4
%res = call i4 \[at]llvm.ssub.sat.i4(i4 -4, i4 5)  ; %res = -8
%res = call i4 \[at]llvm.ssub.sat.i4(i4 4, i4 -5)  ; %res = 7
\f[R]
.fi
.SS \[aq]\f[V]llvm.usub.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.usub.sat\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.usub.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.usub.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.usub.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.usub.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.usub.sat\f[R]\[aq] family of intrinsic functions
perform unsigned saturating subtraction on the 2 arguments.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned subtraction.
.SS Semantics:
.PP
The minimum value this operation can clamp to is 0, which is the
smallest unsigned value representable by the bit width of the unsigned
arguments.
Because this is an unsigned operation, the result will never saturate
towards the largest possible value representable by this bit width.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.usub.sat.i4(i4 2, i4 1)  ; %res = 1
%res = call i4 \[at]llvm.usub.sat.i4(i4 2, i4 6)  ; %res = 0
\f[R]
.fi
.SS \[aq]\f[V]llvm.sshl.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sshl.sat\f[R] on integers or vectors of integers
of any bit width.
.IP
.nf
\f[C]
declare i16 \[at]llvm.sshl.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.sshl.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.sshl.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.sshl.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.sshl.sat\f[R]\[aq] family of intrinsic functions
perform signed saturating left shift on the first argument.
.SS Arguments
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) and the result may be of
integer types of any bit width, but they must have the same bit width.
\f[V]%a\f[R] is the value to be shifted, and \f[V]%b\f[R] is the amount
to shift by.
If \f[V]b\f[R] is (statically or dynamically) equal to or larger than
the integer bit width of the arguments, the result is a
\f[V]poison value <poisonvalues>\f[R].
If the arguments are vectors, each vector element of \f[V]a\f[R] is
shifted by the corresponding shift amount in \f[V]b\f[R].
.SS Semantics:
.PP
The maximum value this operation can clamp to is the largest signed
value representable by the bit width of the arguments.
The minimum value is the smallest signed value representable by this bit
width.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.sshl.sat.i4(i4 2, i4 1)  ; %res = 4
%res = call i4 \[at]llvm.sshl.sat.i4(i4 2, i4 2)  ; %res = 7
%res = call i4 \[at]llvm.sshl.sat.i4(i4 -5, i4 1)  ; %res = -8
%res = call i4 \[at]llvm.sshl.sat.i4(i4 -1, i4 1)  ; %res = -2
\f[R]
.fi
.SS \[aq]\f[V]llvm.ushl.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.ushl.sat\f[R] on integers or vectors of integers
of any bit width.
.IP
.nf
\f[C]
declare i16 \[at]llvm.ushl.sat.i16(i16 %a, i16 %b)
declare i32 \[at]llvm.ushl.sat.i32(i32 %a, i32 %b)
declare i64 \[at]llvm.ushl.sat.i64(i64 %a, i64 %b)
declare <4 x i32> \[at]llvm.ushl.sat.v4i32(<4 x i32> %a, <4 x i32> %b)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.ushl.sat\f[R]\[aq] family of intrinsic functions
perform unsigned saturating left shift on the first argument.
.SS Arguments
.PP
The arguments (\f[V]%a\f[R] and \f[V]%b\f[R]) and the result may be of
integer types of any bit width, but they must have the same bit width.
\f[V]%a\f[R] is the value to be shifted, and \f[V]%b\f[R] is the amount
to shift by.
If \f[V]b\f[R] is (statically or dynamically) equal to or larger than
the integer bit width of the arguments, the result is a
\f[V]poison value <poisonvalues>\f[R].
If the arguments are vectors, each vector element of \f[V]a\f[R] is
shifted by the corresponding shift amount in \f[V]b\f[R].
.SS Semantics:
.PP
The maximum value this operation can clamp to is the largest unsigned
value representable by the bit width of the arguments.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.ushl.sat.i4(i4 2, i4 1)  ; %res = 4
%res = call i4 \[at]llvm.ushl.sat.i4(i4 3, i4 3)  ; %res = 15
\f[R]
.fi
.SS Fixed Point Arithmetic Intrinsics
.PP
A fixed point number represents a real data type for a number that has a
fixed number of digits after a radix point (equivalent to the decimal
point \[aq].\[aq]).
The number of digits after the radix point is referred as the scale.
These are useful for representing fractional values to a specific
precision.
The following intrinsics perform fixed point arithmetic operations on 2
operands of the same scale, specified as the third argument.
.PP
The \f[V]llvm.*mul.fix\f[R] family of intrinsic functions represents a
multiplication of fixed point numbers through scaled integers.
Therefore, fixed point multiplication can be represented as
.IP
.nf
\f[C]
%result = call i4 \[at]llvm.smul.fix.i4(i4 %a, i4 %b, i32 %scale)

; Expands to
%a2 = sext i4 %a to i8
%b2 = sext i4 %b to i8
%mul = mul nsw nuw i8 %a2, %b2
%scale2 = trunc i32 %scale to i8
%r = ashr i8 %mul, i8 %scale2  ; this is for a target rounding down towards negative infinity
%result = trunc i8 %r to i4
\f[R]
.fi
.PP
The \f[V]llvm.*div.fix\f[R] family of intrinsic functions represents a
division of fixed point numbers through scaled integers.
Fixed point division can be represented as:
.IP
.nf
\f[C]
%result call i4 \[at]llvm.sdiv.fix.i4(i4 %a, i4 %b, i32 %scale)

; Expands to
%a2 = sext i4 %a to i8
%b2 = sext i4 %b to i8
%scale2 = trunc i32 %scale to i8
%a3 = shl i8 %a2, %scale2
%r = sdiv i8 %a3, %b2 ; this is for a target rounding towards zero
%result = trunc i8 %r to i4
\f[R]
.fi
.PP
For each of these functions, if the result cannot be represented exactly
with the provided scale, the result is rounded.
Rounding is unspecified since preferred rounding may vary for different
targets.
Rounding is specified through a target hook.
Different pipelines should legalize or optimize this using the rounding
specified by this hook if it is provided.
Operations like constant folding, instruction combining, KnownBits, and
ValueTracking should also use this hook, if provided, and not assume the
direction of rounding.
A rounded result must always be within one unit of precision from the
true result.
That is, the error between the returned result and the true result must
be less than 1/2\[ha](scale).
.SS \[aq]\f[V]llvm.smul.fix.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.smul.fix\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.smul.fix.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.smul.fix.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.smul.fix.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.smul.fix.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.smul.fix\f[R]\[aq] family of intrinsic functions
perform signed fixed point multiplication on 2 arguments of the same
scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
The arguments may also work with int vectors of the same length and int
size.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed fixed point multiplication.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point multiplication on the 2 arguments of
a specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
It is undefined behavior if the result value does not fit within the
range of the fixed point type.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.smul.fix.i4(i4 3, i4 2, i32 0)  ; %res = 6 (2 x 3 = 6)
%res = call i4 \[at]llvm.smul.fix.i4(i4 3, i4 2, i32 1)  ; %res = 3 (1.5 x 1 = 1.5)
%res = call i4 \[at]llvm.smul.fix.i4(i4 3, i4 -2, i32 1)  ; %res = -3 (1.5 x -1 = -1.5)

; The result in the following could be rounded up to -2 or down to -2.5
%res = call i4 \[at]llvm.smul.fix.i4(i4 3, i4 -3, i32 1)  ; %res = -5 (or -4) (1.5 x -1.5 = -2.25)
\f[R]
.fi
.SS \[aq]\f[V]llvm.umul.fix.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.umul.fix\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.umul.fix.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.umul.fix.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.umul.fix.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.umul.fix.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.umul.fix\f[R]\[aq] family of intrinsic functions
perform unsigned fixed point multiplication on 2 arguments of the same
scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
The arguments may also work with int vectors of the same length and int
size.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned fixed point multiplication.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs unsigned fixed point multiplication on the 2
arguments of a specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
It is undefined behavior if the result value does not fit within the
range of the fixed point type.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.umul.fix.i4(i4 3, i4 2, i32 0)  ; %res = 6 (2 x 3 = 6)
%res = call i4 \[at]llvm.umul.fix.i4(i4 3, i4 2, i32 1)  ; %res = 3 (1.5 x 1 = 1.5)

; The result in the following could be rounded down to 3.5 or up to 4
%res = call i4 \[at]llvm.umul.fix.i4(i4 15, i4 1, i32 1)  ; %res = 7 (or 8) (7.5 x 0.5 = 3.75)
\f[R]
.fi
.SS \[aq]\f[V]llvm.smul.fix.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.smul.fix.sat\f[R] on any integer bit width or
vectors of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.smul.fix.sat.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.smul.fix.sat.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.smul.fix.sat.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.smul.fix.sat.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.smul.fix.sat\f[R]\[aq] family of intrinsic functions
perform signed fixed point saturating multiplication on 2 arguments of
the same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed fixed point multiplication.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point multiplication on the 2 arguments of
a specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
The maximum value this operation can clamp to is the largest signed
value representable by the bit width of the first 2 arguments.
The minimum value is the smallest signed value representable by this bit
width.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 3, i4 2, i32 0)  ; %res = 6 (2 x 3 = 6)
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 3, i4 2, i32 1)  ; %res = 3 (1.5 x 1 = 1.5)
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 3, i4 -2, i32 1)  ; %res = -3 (1.5 x -1 = -1.5)

; The result in the following could be rounded up to -2 or down to -2.5
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 3, i4 -3, i32 1)  ; %res = -5 (or -4) (1.5 x -1.5 = -2.25)

; Saturation
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 7, i4 2, i32 0)  ; %res = 7
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 7, i4 4, i32 2)  ; %res = 7
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 -8, i4 5, i32 2)  ; %res = -8
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 -8, i4 -2, i32 1)  ; %res = 7

; Scale can affect the saturation result
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 2, i4 4, i32 0)  ; %res = 7 (2 x 4 -> clamped to 7)
%res = call i4 \[at]llvm.smul.fix.sat.i4(i4 2, i4 4, i32 1)  ; %res = 4 (1 x 2 = 2)
\f[R]
.fi
.SS \[aq]\f[V]llvm.umul.fix.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.umul.fix.sat\f[R] on any integer bit width or
vectors of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.umul.fix.sat.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.umul.fix.sat.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.umul.fix.sat.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.umul.fix.sat.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.umul.fix.sat\f[R]\[aq] family of intrinsic functions
perform unsigned fixed point saturating multiplication on 2 arguments of
the same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned fixed point multiplication.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point multiplication on the 2 arguments of
a specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
The maximum value this operation can clamp to is the largest unsigned
value representable by the bit width of the first 2 arguments.
The minimum value is the smallest unsigned value representable by this
bit width (zero).
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 3, i4 2, i32 0)  ; %res = 6 (2 x 3 = 6)
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 3, i4 2, i32 1)  ; %res = 3 (1.5 x 1 = 1.5)

; The result in the following could be rounded down to 2 or up to 2.5
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 3, i4 3, i32 1)  ; %res = 4 (or 5) (1.5 x 1.5 = 2.25)

; Saturation
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 8, i4 2, i32 0)  ; %res = 15 (8 x 2 -> clamped to 15)
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 8, i4 8, i32 2)  ; %res = 15 (2 x 2 -> clamped to 3.75)

; Scale can affect the saturation result
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 2, i4 4, i32 0)  ; %res = 7 (2 x 4 -> clamped to 7)
%res = call i4 \[at]llvm.umul.fix.sat.i4(i4 2, i4 4, i32 1)  ; %res = 4 (1 x 2 = 2)
\f[R]
.fi
.SS \[aq]\f[V]llvm.sdiv.fix.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sdiv.fix\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.sdiv.fix.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.sdiv.fix.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.sdiv.fix.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.sdiv.fix.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.sdiv.fix\f[R]\[aq] family of intrinsic functions
perform signed fixed point division on 2 arguments of the same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
The arguments may also work with int vectors of the same length and int
size.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed fixed point division.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point division on the 2 arguments of a
specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
It is undefined behavior if the result value does not fit within the
range of the fixed point type, or if the second argument is zero.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.sdiv.fix.i4(i4 6, i4 2, i32 0)  ; %res = 3 (6 / 2 = 3)
%res = call i4 \[at]llvm.sdiv.fix.i4(i4 6, i4 4, i32 1)  ; %res = 3 (3 / 2 = 1.5)
%res = call i4 \[at]llvm.sdiv.fix.i4(i4 3, i4 -2, i32 1) ; %res = -3 (1.5 / -1 = -1.5)

; The result in the following could be rounded up to 1 or down to 0.5
%res = call i4 \[at]llvm.sdiv.fix.i4(i4 3, i4 4, i32 1)  ; %res = 2 (or 1) (1.5 / 2 = 0.75)
\f[R]
.fi
.SS \[aq]\f[V]llvm.udiv.fix.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.udiv.fix\f[R] on any integer bit width or vectors
of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.udiv.fix.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.udiv.fix.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.udiv.fix.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.udiv.fix.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.udiv.fix\f[R]\[aq] family of intrinsic functions
perform unsigned fixed point division on 2 arguments of the same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
The arguments may also work with int vectors of the same length and int
size.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned fixed point division.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point division on the 2 arguments of a
specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
It is undefined behavior if the result value does not fit within the
range of the fixed point type, or if the second argument is zero.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.udiv.fix.i4(i4 6, i4 2, i32 0)  ; %res = 3 (6 / 2 = 3)
%res = call i4 \[at]llvm.udiv.fix.i4(i4 6, i4 4, i32 1)  ; %res = 3 (3 / 2 = 1.5)
%res = call i4 \[at]llvm.udiv.fix.i4(i4 1, i4 -8, i32 4) ; %res = 2 (0.0625 / 0.5 = 0.125)

; The result in the following could be rounded up to 1 or down to 0.5
%res = call i4 \[at]llvm.udiv.fix.i4(i4 3, i4 4, i32 1)  ; %res = 2 (or 1) (1.5 / 2 = 0.75)
\f[R]
.fi
.SS \[aq]\f[V]llvm.sdiv.fix.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.sdiv.fix.sat\f[R] on any integer bit width or
vectors of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.sdiv.fix.sat.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.sdiv.fix.sat.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.sdiv.fix.sat.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.sdiv.fix.sat.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.sdiv.fix.sat\f[R]\[aq] family of intrinsic functions
perform signed fixed point saturating division on 2 arguments of the
same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
signed fixed point division.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point division on the 2 arguments of a
specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
The maximum value this operation can clamp to is the largest signed
value representable by the bit width of the first 2 arguments.
The minimum value is the smallest signed value representable by this bit
width.
.PP
It is undefined behavior if the second argument is zero.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 6, i4 2, i32 0)  ; %res = 3 (6 / 2 = 3)
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 6, i4 4, i32 1)  ; %res = 3 (3 / 2 = 1.5)
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 3, i4 -2, i32 1) ; %res = -3 (1.5 / -1 = -1.5)

; The result in the following could be rounded up to 1 or down to 0.5
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 3, i4 4, i32 1)  ; %res = 2 (or 1) (1.5 / 2 = 0.75)

; Saturation
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 -8, i4 -1, i32 0)  ; %res = 7 (-8 / -1 = 8 => 7)
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 4, i4 2, i32 2)  ; %res = 7 (1 / 0.5 = 2 => 1.75)
%res = call i4 \[at]llvm.sdiv.fix.sat.i4(i4 -4, i4 1, i32 2)  ; %res = -8 (-1 / 0.25 = -4 => -2)
\f[R]
.fi
.SS \[aq]\f[V]llvm.udiv.fix.sat.*\f[R]\[aq] Intrinsics
.SS Syntax
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.udiv.fix.sat\f[R] on any integer bit width or
vectors of integers.
.IP
.nf
\f[C]
declare i16 \[at]llvm.udiv.fix.sat.i16(i16 %a, i16 %b, i32 %scale)
declare i32 \[at]llvm.udiv.fix.sat.i32(i32 %a, i32 %b, i32 %scale)
declare i64 \[at]llvm.udiv.fix.sat.i64(i64 %a, i64 %b, i32 %scale)
declare <4 x i32> \[at]llvm.udiv.fix.sat.v4i32(<4 x i32> %a, <4 x i32> %b, i32 %scale)
\f[R]
.fi
.SS Overview
.PP
The \[aq]\f[V]llvm.udiv.fix.sat\f[R]\[aq] family of intrinsic functions
perform unsigned fixed point saturating division on 2 arguments of the
same scale.
.SS Arguments
.PP
The arguments (%a and %b) and the result may be of integer types of any
bit width, but they must have the same bit width.
\f[V]%a\f[R] and \f[V]%b\f[R] are the two values that will undergo
unsigned fixed point division.
The argument \f[V]%scale\f[R] represents the scale of both operands, and
must be a constant integer.
.SS Semantics:
.PP
This operation performs fixed point division on the 2 arguments of a
specified scale.
The result will also be returned in the same scale specified in the
third argument.
.PP
If the result value cannot be precisely represented in the given scale,
the value is rounded up or down to the closest representable value.
The rounding direction is unspecified.
.PP
The maximum value this operation can clamp to is the largest unsigned
value representable by the bit width of the first 2 arguments.
The minimum value is the smallest unsigned value representable by this
bit width (zero).
.PP
It is undefined behavior if the second argument is zero.
.SS Examples
.IP
.nf
\f[C]
%res = call i4 \[at]llvm.udiv.fix.sat.i4(i4 6, i4 2, i32 0)  ; %res = 3 (6 / 2 = 3)
%res = call i4 \[at]llvm.udiv.fix.sat.i4(i4 6, i4 4, i32 1)  ; %res = 3 (3 / 2 = 1.5)

; The result in the following could be rounded down to 0.5 or up to 1
%res = call i4 \[at]llvm.udiv.fix.sat.i4(i4 3, i4 4, i32 1)  ; %res = 1 (or 2) (1.5 / 2 = 0.75)

; Saturation
%res = call i4 \[at]llvm.udiv.fix.sat.i4(i4 8, i4 2, i32 2)  ; %res = 15 (2 / 0.5 = 4 => 3.75)
\f[R]
.fi
.SS Specialised Arithmetic Intrinsics
.SS \[aq]\f[V]llvm.canonicalize.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.canonicalize.f32(float %a)
declare double \[at]llvm.canonicalize.f64(double %b)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.canonicalize.*\f[R]\[aq] intrinsic returns the
platform specific canonical encoding of a floating-point number.
This canonicalization is useful for implementing certain numeric
primitives such as frexp.
The canonical encoding is defined by IEEE-754-2008 to be:
.IP
.nf
\f[C]
2.1.8 canonical encoding: The preferred encoding of a floating-point
representation in a format. Applied to declets, significands of finite
numbers, infinities, and NaNs, especially in decimal formats.
\f[R]
.fi
.PP
This operation can also be considered equivalent to the IEEE-754-2008
conversion of a floating-point value to the same format.
NaNs are handled according to section 6.2.
.PP
Examples of non-canonical encodings:
.IP \[bu] 2
x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals.
These are converted to a canonical representation per hardware-specific
protocol.
.IP \[bu] 2
Many normal decimal floating-point numbers have non-canonical
alternative encodings.
.IP \[bu] 2
Some machines, like GPUs or ARMv7 NEON, do not support subnormal values.
These are treated as non-canonical encodings of zero and will be flushed
to a zero of the same sign by this operation.
.PP
Note that per IEEE-754-2008 6.2, systems that support signaling NaNs
with default exception handling must signal an invalid exception, and
produce a quiet NaN result.
.PP
This function should always be implementable as multiplication by 1.0,
provided that the compiler does not constant fold the operation.
Likewise, division by 1.0 and \f[V]llvm.minnum(x, x)\f[R] are possible
implementations.
Addition with -0.0 is also sufficient provided that the rounding mode is
not -Infinity.
.PP
\f[V]\[at]llvm.canonicalize\f[R] must preserve the equality relation.
That is:
.IP \[bu] 2
\f[V](\[at]llvm.canonicalize(x) == x)\f[R] is equivalent to
\f[V](x == x)\f[R]
.IP \[bu] 2
\f[V](\[at]llvm.canonicalize(x) == \[at]llvm.canonicalize(y))\f[R] is
equivalent to to \f[V](x == y)\f[R]
.PP
Additionally, the sign of zero must be conserved:
\f[V]\[at]llvm.canonicalize(-0.0) = -0.0\f[R] and
\f[V]\[at]llvm.canonicalize(+0.0) = +0.0\f[R]
.PP
The payload bits of a NaN must be conserved, with two exceptions.
First, environments which use only a single canonical representation of
NaN must perform said canonicalization.
Second, SNaNs must be quieted per the usual methods.
.PP
The canonicalization operation may be optimized away if:
.IP \[bu] 2
The input is known to be canonical.
For example, it was produced by a floating-point operation that is
required by the standard to be canonical.
.IP \[bu] 2
The result is consumed only by (or fused with) other floating-point
operations.
That is, the bits of the floating-point value are not examined.
.SS \[aq]\f[V]llvm.fmuladd.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.fmuladd.f32(float %a, float %b, float %c)
declare double \[at]llvm.fmuladd.f64(double %a, double %b, double %c)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fmuladd.*\f[R]\[aq] intrinsic functions represent
multiply-add expressions that can be fused if the code generator
determines that (a) the target instruction set has support for a fused
operation, and (b) that the fused operation is more efficient than the
equivalent, separate pair of mul and add instructions.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.fmuladd.*\f[R]\[aq] intrinsics each take three
arguments: two multiplicands, a and b, and an addend c.
.SS Semantics:
.PP
The expression:
.IP
.nf
\f[C]
%0 = call float \[at]llvm.fmuladd.f32(%a, %b, %c)
\f[R]
.fi
.PP
is equivalent to the expression a * b + c, except that it is unspecified
whether rounding will be performed between the multiplication and
addition steps.
Fusion is not guaranteed, even if the target platform supports it.
If a fused multiply-add is required, the corresponding
\f[V]llvm.fma <int_fma>\f[R] intrinsic function should be used instead.
This never sets errno, just as \[aq]\f[V]llvm.fma.*\f[R]\[aq].
.SS Examples:
.IP
.nf
\f[C]
%r2 = call float \[at]llvm.fmuladd.f32(float %a, float %b, float %c) ; yields float:r2 = (a * b) + c
\f[R]
.fi
.SS Hardware-Loop Intrinsics
.PP
LLVM support several intrinsics to mark a loop as a hardware-loop.
They are hints to the backend which are required to lower these
intrinsics further to target specific instructions, or revert the
hardware-loop to a normal loop if target specific restriction are not
met and a hardware-loop can\[aq]t be generated.
.PP
These intrinsics may be modified in the future and are not intended to
be used outside the backend.
Thus, front-end and mid-level optimizations should not be generating
these intrinsics.
.SS \[aq]\f[V]llvm.set.loop.iterations.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare void \[at]llvm.set.loop.iterations.i32(i32)
declare void \[at]llvm.set.loop.iterations.i64(i64)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.set.loop.iterations.*\f[R]\[aq] intrinsics are used
to specify the hardware-loop trip count.
They are placed in the loop preheader basic block and are marked as
\f[V]IntrNoDuplicate\f[R] to avoid optimizers duplicating these
instructions.
.SS Arguments:
.PP
The integer operand is the loop trip count of the hardware-loop, and
thus not e.g.
the loop back-edge taken count.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.set.loop.iterations.*\f[R]\[aq] intrinsics do not
perform any arithmetic on their operand.
It\[aq]s a hint to the backend that can use this to set up the
hardware-loop count with a target specific instruction, usually a move
of this value to a special register or a hardware-loop instruction.
.SS \[aq]\f[V]llvm.start.loop.iterations.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.start.loop.iterations.i32(i32)
declare i64 \[at]llvm.start.loop.iterations.i64(i64)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.start.loop.iterations.*\f[R]\[aq] intrinsics are
similar to the \[aq]\f[V]llvm.set.loop.iterations.*\f[R]\[aq]
intrinsics, used to specify the hardware-loop trip count but also
produce a value identical to the input that can be used as the input to
the loop.
They are placed in the loop preheader basic block and the output is
expected to be the input to the phi for the induction variable of the
loop, decremented by the \[aq]\f[V]llvm.loop.decrement.reg.*\f[R]\[aq].
.SS Arguments:
.PP
The integer operand is the loop trip count of the hardware-loop, and
thus not e.g.
the loop back-edge taken count.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.start.loop.iterations.*\f[R]\[aq] intrinsics do not
perform any arithmetic on their operand.
It\[aq]s a hint to the backend that can use this to set up the
hardware-loop count with a target specific instruction, usually a move
of this value to a special register or a hardware-loop instruction.
.SS \[aq]\f[V]llvm.test.set.loop.iterations.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i1 \[at]llvm.test.set.loop.iterations.i32(i32)
declare i1 \[at]llvm.test.set.loop.iterations.i64(i64)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.test.set.loop.iterations.*\f[R]\[aq] intrinsics are
used to specify the the loop trip count, and also test that the given
count is not zero, allowing it to control entry to a while-loop.
They are placed in the loop preheader\[aq]s predecessor basic block, and
are marked as \f[V]IntrNoDuplicate\f[R] to avoid optimizers duplicating
these instructions.
.SS Arguments:
.PP
The integer operand is the loop trip count of the hardware-loop, and
thus not e.g.
the loop back-edge taken count.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.test.set.loop.iterations.*\f[R]\[aq] intrinsics do
not perform any arithmetic on their operand.
It\[aq]s a hint to the backend that can use this to set up the
hardware-loop count with a target specific instruction, usually a move
of this value to a special register or a hardware-loop instruction.
The result is the conditional value of whether the given count is not
zero.
.SS \[aq]\f[V]llvm.test.start.loop.iterations.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare {i32, i1} \[at]llvm.test.start.loop.iterations.i32(i32)
declare {i64, i1} \[at]llvm.test.start.loop.iterations.i64(i64)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.test.start.loop.iterations.*\f[R]\[aq] intrinsics are
similar to the \[aq]\f[V]llvm.test.set.loop.iterations.*\f[R]\[aq] and
\[aq]\f[V]llvm.start.loop.iterations.*\f[R]\[aq] intrinsics, used to
specify the hardware-loop trip count, but also produce a value identical
to the input that can be used as the input to the loop.
The second i1 output controls entry to a while-loop.
.SS Arguments:
.PP
The integer operand is the loop trip count of the hardware-loop, and
thus not e.g.
the loop back-edge taken count.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.test.start.loop.iterations.*\f[R]\[aq] intrinsics do
not perform any arithmetic on their operand.
It\[aq]s a hint to the backend that can use this to set up the
hardware-loop count with a target specific instruction, usually a move
of this value to a special register or a hardware-loop instruction.
The result is a pair of the input and a conditional value of whether the
given count is not zero.
.SS \[aq]\f[V]llvm.loop.decrement.reg.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.loop.decrement.reg.i32(i32, i32)
declare i64 \[at]llvm.loop.decrement.reg.i64(i64, i64)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.loop.decrement.reg.*\f[R]\[aq] intrinsics are used to
lower the loop iteration counter and return an updated value that will
be used in the next loop test check.
.SS Arguments:
.PP
Both arguments must have identical integer types.
The first operand is the loop iteration counter.
The second operand is the maximum number of elements processed in an
iteration.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.loop.decrement.reg.*\f[R]\[aq] intrinsics do an
integer \f[V]SUB\f[R] of its two operands, which is not allowed to wrap.
They return the remaining number of iterations still to be executed, and
can be used together with a \f[V]PHI\f[R], \f[V]ICMP\f[R] and
\f[V]BR\f[R] to control the number of loop iterations executed.
Any optimisations are allowed to treat it is a \f[V]SUB\f[R], and it is
supported by SCEV, so it\[aq]s the backends responsibility to handle
cases where it may be optimised.
These intrinsics are marked as \f[V]IntrNoDuplicate\f[R] to avoid
optimizers duplicating these instructions.
.SS \[aq]\f[V]llvm.loop.decrement.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i1 \[at]llvm.loop.decrement.i32(i32)
declare i1 \[at]llvm.loop.decrement.i64(i64)
\f[R]
.fi
.SS Overview:
.PP
The HardwareLoops pass allows the loop decrement value to be specified
with an option.
It defaults to a loop decrement value of 1, but it can be an unsigned
integer value provided by this option.
The \[aq]\f[V]llvm.loop.decrement.*\f[R]\[aq] intrinsics decrement the
loop iteration counter with this value, and return a false predicate if
the loop should exit, and true otherwise.
This is emitted if the loop counter is not updated via a \f[V]PHI\f[R]
node, which can also be controlled with an option.
.SS Arguments:
.PP
The integer argument is the loop decrement value used to decrement the
loop iteration counter.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.loop.decrement.*\f[R]\[aq] intrinsics do a
\f[V]SUB\f[R] of the loop iteration counter with the given loop
decrement value, and return false if the loop should exit, this
\f[V]SUB\f[R] is not allowed to wrap.
The result is a condition that is used by the conditional branch
controlling the loop.
.SS Vector Reduction Intrinsics
.PP
Horizontal reductions of vectors can be expressed using the following
intrinsics.
Each one takes a vector operand as an input and applies its respective
operation across all elements of the vector, returning a single scalar
result of the same element type.
.SS \[aq]\f[V]llvm.vector.reduce.add.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.add.v4i32(<4 x i32> %a)
declare i64 \[at]llvm.vector.reduce.add.v2i64(<2 x i64> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.add.*\f[R]\[aq] intrinsics do an
integer \f[V]ADD\f[R] reduction of a vector, returning the result as a
scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.fadd.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %a)
declare double \[at]llvm.vector.reduce.fadd.v2f64(double %start_value, <2 x double> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.fadd.*\f[R]\[aq] intrinsics do a
floating-point \f[V]ADD\f[R] reduction of a vector, returning the result
as a scalar.
The return type matches the element-type of the vector input.
.PP
If the intrinsic call has the \[aq]reassoc\[aq] flag set, then the
reduction will not preserve the associativity of an equivalent
scalarized counterpart.
Otherwise the reduction will be \f[I]sequential\f[R], thus implying that
the operation respects the associativity of a scalarized reduction.
That is, the reduction begins with the start value and performs an fadd
operation with consecutively increasing vector element indices.
See the following pseudocode:
.IP
.nf
\f[C]
float sequential_fadd(start_value, input_vector)
  result = start_value
  for i = 0 to length(input_vector)
    result = result + input_vector[i]
  return result
\f[R]
.fi
.SS Arguments:
.PP
The first argument to this intrinsic is a scalar start value for the
reduction.
The type of the start value matches the element-type of the vector
input.
The second argument must be a vector of floating-point values.
.PP
To ignore the start value, negative zero (\f[V]-0.0\f[R]) can be used,
as it is the neutral value of floating point addition.
.SS Examples:
.IP
.nf
\f[C]
%unord = call reassoc float \[at]llvm.vector.reduce.fadd.v4f32(float -0.0, <4 x float> %input) ; relaxed reduction
%ord = call float \[at]llvm.vector.reduce.fadd.v4f32(float %start_value, <4 x float> %input) ; sequential reduction
\f[R]
.fi
.SS \[aq]\f[V]llvm.vector.reduce.mul.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.mul.v4i32(<4 x i32> %a)
declare i64 \[at]llvm.vector.reduce.mul.v2i64(<2 x i64> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.mul.*\f[R]\[aq] intrinsics do an
integer \f[V]MUL\f[R] reduction of a vector, returning the result as a
scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.fmul.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %a)
declare double \[at]llvm.vector.reduce.fmul.v2f64(double %start_value, <2 x double> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.fmul.*\f[R]\[aq] intrinsics do a
floating-point \f[V]MUL\f[R] reduction of a vector, returning the result
as a scalar.
The return type matches the element-type of the vector input.
.PP
If the intrinsic call has the \[aq]reassoc\[aq] flag set, then the
reduction will not preserve the associativity of an equivalent
scalarized counterpart.
Otherwise the reduction will be \f[I]sequential\f[R], thus implying that
the operation respects the associativity of a scalarized reduction.
That is, the reduction begins with the start value and performs an fmul
operation with consecutively increasing vector element indices.
See the following pseudocode:
.IP
.nf
\f[C]
float sequential_fmul(start_value, input_vector)
  result = start_value
  for i = 0 to length(input_vector)
    result = result * input_vector[i]
  return result
\f[R]
.fi
.SS Arguments:
.PP
The first argument to this intrinsic is a scalar start value for the
reduction.
The type of the start value matches the element-type of the vector
input.
The second argument must be a vector of floating-point values.
.PP
To ignore the start value, one (\f[V]1.0\f[R]) can be used, as it is the
neutral value of floating point multiplication.
.SS Examples:
.IP
.nf
\f[C]
%unord = call reassoc float \[at]llvm.vector.reduce.fmul.v4f32(float 1.0, <4 x float> %input) ; relaxed reduction
%ord = call float \[at]llvm.vector.reduce.fmul.v4f32(float %start_value, <4 x float> %input) ; sequential reduction
\f[R]
.fi
.SS \[aq]\f[V]llvm.vector.reduce.and.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.and.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.and.*\f[R]\[aq] intrinsics do a bitwise
\f[V]AND\f[R] reduction of a vector, returning the result as a scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.or.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.or.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.or.*\f[R]\[aq] intrinsics do a bitwise
\f[V]OR\f[R] reduction of a vector, returning the result as a scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.xor.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.xor.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.xor.*\f[R]\[aq] intrinsics do a bitwise
\f[V]XOR\f[R] reduction of a vector, returning the result as a scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.smax.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.smax.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.smax.*\f[R]\[aq] intrinsics do a signed
integer \f[V]MAX\f[R] reduction of a vector, returning the result as a
scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.smin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.smin.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.smin.*\f[R]\[aq] intrinsics do a signed
integer \f[V]MIN\f[R] reduction of a vector, returning the result as a
scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.umax.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.umax.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.umax.*\f[R]\[aq] intrinsics do an
unsigned integer \f[V]MAX\f[R] reduction of a vector, returning the
result as a scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.umin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.vector.reduce.umin.v4i32(<4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.umin.*\f[R]\[aq] intrinsics do an
unsigned integer \f[V]MIN\f[R] reduction of a vector, returning the
result as a scalar.
The return type matches the element-type of the vector input.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of integer values.
.SS \[aq]\f[V]llvm.vector.reduce.fmax.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.vector.reduce.fmax.v4f32(<4 x float> %a)
declare double \[at]llvm.vector.reduce.fmax.v2f64(<2 x double> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.fmax.*\f[R]\[aq] intrinsics do a
floating-point \f[V]MAX\f[R] reduction of a vector, returning the result
as a scalar.
The return type matches the element-type of the vector input.
.PP
This instruction has the same comparison semantics as the
\[aq]\f[V]llvm.maxnum.*\f[R]\[aq] intrinsic.
That is, the result will always be a number unless all elements of the
vector are NaN.
For a vector with maximum element magnitude 0.0 and containing both +0.0
and -0.0 elements, the sign of the result is unspecified.
.PP
If the intrinsic call has the \f[V]nnan\f[R] fast-math flag, then the
operation can assume that NaNs are not present in the input vector.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of floating-point
values.
.SS \[aq]\f[V]llvm.vector.reduce.fmin.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare float \[at]llvm.vector.reduce.fmin.v4f32(<4 x float> %a)
declare double \[at]llvm.vector.reduce.fmin.v2f64(<2 x double> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.reduce.fmin.*\f[R]\[aq] intrinsics do a
floating-point \f[V]MIN\f[R] reduction of a vector, returning the result
as a scalar.
The return type matches the element-type of the vector input.
.PP
This instruction has the same comparison semantics as the
\[aq]\f[V]llvm.minnum.*\f[R]\[aq] intrinsic.
That is, the result will always be a number unless all elements of the
vector are NaN.
For a vector with minimum element magnitude 0.0 and containing both +0.0
and -0.0 elements, the sign of the result is unspecified.
.PP
If the intrinsic call has the \f[V]nnan\f[R] fast-math flag, then the
operation can assume that NaNs are not present in the input vector.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector of floating-point
values.
.SS \[aq]\f[V]llvm.vector.insert\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
; Insert fixed type into scalable type
declare <vscale x 4 x float> \[at]llvm.vector.insert.nxv4f32.v4f32(<vscale x 4 x float> %vec, <4 x float> %subvec, i64 <idx>)
declare <vscale x 2 x double> \[at]llvm.vector.insert.nxv2f64.v2f64(<vscale x 2 x double> %vec, <2 x double> %subvec, i64 <idx>)

; Insert scalable type into scalable type
declare <vscale x 4 x float> \[at]llvm.vector.insert.nxv4f64.nxv2f64(<vscale x 4 x float> %vec, <vscale x 2 x float> %subvec, i64 <idx>)

; Insert fixed type into fixed type
declare <4 x double> \[at]llvm.vector.insert.v4f64.v2f64(<4 x double> %vec, <2 x double> %subvec, i64 <idx>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.insert.*\f[R]\[aq] intrinsics insert a vector
into another vector starting from a given index.
The return type matches the type of the vector we insert into.
Conceptually, this can be used to build a scalable vector out of
non-scalable vectors, however this intrinsic can also be used on purely
fixed types.
.PP
Scalable vectors can only be inserted into other scalable vectors.
.SS Arguments:
.PP
The \f[V]vec\f[R] is the vector which \f[V]subvec\f[R] will be inserted
into.
The \f[V]subvec\f[R] is the vector that will be inserted.
.PP
\f[V]idx\f[R] represents the starting element number at which
\f[V]subvec\f[R] will be inserted.
\f[V]idx\f[R] must be a constant multiple of \f[V]subvec\f[R]\[aq]s
known minimum vector length.
If \f[V]subvec\f[R] is a scalable vector, \f[V]idx\f[R] is first scaled
by the runtime scaling factor of \f[V]subvec\f[R].
The elements of \f[V]vec\f[R] starting at \f[V]idx\f[R] are overwritten
with \f[V]subvec\f[R].
Elements \f[V]idx\f[R] through (\f[V]idx\f[R] +
num_elements(\f[V]subvec\f[R]) - 1) must be valid \f[V]vec\f[R] indices.
If this condition cannot be determined statically but is false at
runtime, then the result vector is undefined.
.SS \[aq]\f[V]llvm.vector.extract\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
; Extract fixed type from scalable type
declare <4 x float> \[at]llvm.vector.extract.v4f32.nxv4f32(<vscale x 4 x float> %vec, i64 <idx>)
declare <2 x double> \[at]llvm.vector.extract.v2f64.nxv2f64(<vscale x 2 x double> %vec, i64 <idx>)

; Extract scalable type from scalable type
declare <vscale x 2 x float> \[at]llvm.vector.extract.nxv2f32.nxv4f32(<vscale x 4 x float> %vec, i64 <idx>)

; Extract fixed type from fixed type
declare <2 x double> \[at]llvm.vector.extract.v2f64.v4f64(<4 x double> %vec, i64 <idx>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vector.extract.*\f[R]\[aq] intrinsics extract a
vector from within another vector starting from a given index.
The return type must be explicitly specified.
Conceptually, this can be used to decompose a scalable vector into
non-scalable parts, however this intrinsic can also be used on purely
fixed types.
.PP
Scalable vectors can only be extracted from other scalable vectors.
.SS Arguments:
.PP
The \f[V]vec\f[R] is the vector from which we will extract a subvector.
.PP
The \f[V]idx\f[R] specifies the starting element number within
\f[V]vec\f[R] from which a subvector is extracted.
\f[V]idx\f[R] must be a constant multiple of the known-minimum vector
length of the result type.
If the result type is a scalable vector, \f[V]idx\f[R] is first scaled
by the result type\[aq]s runtime scaling factor.
Elements \f[V]idx\f[R] through (\f[V]idx\f[R] +
num_elements(result_type) - 1) must be valid vector indices.
If this condition cannot be determined statically but is false at
runtime, then the result vector is undefined.
The \f[V]idx\f[R] parameter must be a vector index constant type (for
most targets this will be an integer pointer type).
.SS \[aq]\f[V]llvm.experimental.vector.reverse\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <2 x i8> \[at]llvm.experimental.vector.reverse.v2i8(<2 x i8> %a)
declare <vscale x 4 x i32> \[at]llvm.experimental.vector.reverse.nxv4i32(<vscale x 4 x i32> %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.vector.reverse.*\f[R]\[aq] intrinsics
reverse a vector.
The intrinsic takes a single vector and returns a vector of matching
type but with the original lane order reversed.
These intrinsics work for both fixed and scalable vectors.
While this intrinsic is marked as experimental the recommended way to
express reverse operations for fixed-width vectors is still to use a
shufflevector, as that may allow for more optimization opportunities.
.SS Arguments:
.PP
The argument to this intrinsic must be a vector.
.SS \[aq]\f[V]llvm.experimental.vector.splice\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <2 x double> \[at]llvm.experimental.vector.splice.v2f64(<2 x double> %vec1, <2 x double> %vec2, i32 %imm)
declare <vscale x 4 x i32> \[at]llvm.experimental.vector.splice.nxv4i32(<vscale x 4 x i32> %vec1, <vscale x 4 x i32> %vec2, i32 %imm)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.vector.splice.*\f[R]\[aq] intrinsics
construct a vector by concatenating elements from the first input vector
with elements of the second input vector, returning a vector of the same
type as the input vectors.
The signed immediate, modulo the number of elements in the vector, is
the index into the first vector from which to extract the result value.
This means conceptually that for a positive immediate, a vector is
extracted from \f[V]concat(%vec1, %vec2)\f[R] starting at index
\f[V]imm\f[R], whereas for a negative immediate, it extracts
\f[V]-imm\f[R] trailing elements from the first vector, and the
remaining elements from \f[V]%vec2\f[R].
.PP
These intrinsics work for both fixed and scalable vectors.
While this intrinsic is marked as experimental, the recommended way to
express this operation for fixed-width vectors is still to use a
shufflevector, as that may allow for more optimization opportunities.
.PP
For example:
.IP
.nf
\f[C]
llvm.experimental.vector.splice(<A,B,C,D>, <E,F,G,H>, 1)  ==> <B, C, D, E> ; index
llvm.experimental.vector.splice(<A,B,C,D>, <E,F,G,H>, -3) ==> <B, C, D, E> ; trailing elements
\f[R]
.fi
.SS Arguments:
.PP
The first two operands are vectors with the same type.
The start index is imm modulo the runtime number of elements in the
source vector.
For a fixed-width vector <N x eltty>, imm is a signed integer constant
in the range -N <= imm < N.
For a scalable vector <vscale x N x eltty>, imm is a signed integer
constant in the range -X <= imm < X where X=vscale_range_min * N.
.SS \[aq]\f[V]llvm.experimental.stepvector\f[R]\[aq] Intrinsic
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.experimental.stepvector\f[R] to generate a vector
whose lane values comprise the linear sequence <0, 1, 2, ...>.
It is primarily intended for scalable vectors.
.IP
.nf
\f[C]
declare <vscale x 4 x i32> \[at]llvm.experimental.stepvector.nxv4i32()
declare <vscale x 8 x i16> \[at]llvm.experimental.stepvector.nxv8i16()
\f[R]
.fi
.PP
The \[aq]\f[V]llvm.experimental.stepvector\f[R]\[aq] intrinsics are used
to create vectors of integers whose elements contain a linear sequence
of values starting from 0 with a step of 1.
This experimental intrinsic can only be used for vectors with integer
elements that are at least 8 bits in size.
If the sequence value exceeds the allowed limit for the element type
then the result for that lane is undefined.
.PP
These intrinsics work for both fixed and scalable vectors.
While this intrinsic is marked as experimental, the recommended way to
express this operation for fixed-width vectors is still to generate a
constant vector instead.
.SS Arguments:
.PP
None.
.SS Matrix Intrinsics
.PP
Operations on matrixes requiring shape information (like number of
rows/columns or the memory layout) can be expressed using the matrix
intrinsics.
These intrinsics require matrix dimensions to be passed as immediate
arguments, and matrixes are passed and returned as vectors.
This means that for a \f[V]R\f[R] x \f[V]C\f[R] matrix, element
\f[V]i\f[R] of column \f[V]j\f[R] is at index \f[V]j * R + i\f[R] in the
corresponding vector, with indices starting at 0.
Currently column-major layout is assumed.
The intrinsics support both integer and floating point matrixes.
.SS \[aq]\f[V]llvm.matrix.transpose.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare vectorty \[at]llvm.matrix.transpose.*(vectorty %In, i32 <Rows>, i32 <Cols>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.matrix.transpose.*\f[R]\[aq] intrinsics treat
\f[V]%In\f[R] as a \f[V]<Rows> x <Cols>\f[R] matrix and return the
transposed matrix in the result vector.
.SS Arguments:
.PP
The first argument \f[V]%In\f[R] is a vector that corresponds to a
\f[V]<Rows> x <Cols>\f[R] matrix.
Thus, arguments \f[V]<Rows>\f[R] and \f[V]<Cols>\f[R] correspond to the
number of rows and columns, respectively, and must be positive, constant
integers.
The returned vector must have \f[V]<Rows> * <Cols>\f[R] elements, and
have the same float or integer element type as \f[V]%In\f[R].
.SS \[aq]\f[V]llvm.matrix.multiply.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare vectorty \[at]llvm.matrix.multiply.*(vectorty %A, vectorty %B, i32 <OuterRows>, i32 <Inner>, i32 <OuterColumns>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.matrix.multiply.*\f[R]\[aq] intrinsics treat
\f[V]%A\f[R] as a \f[V]<OuterRows> x <Inner>\f[R] matrix, \f[V]%B\f[R]
as a \f[V]<Inner> x <OuterColumns>\f[R] matrix, and multiplies them.
The result matrix is returned in the result vector.
.SS Arguments:
.PP
The first vector argument \f[V]%A\f[R] corresponds to a matrix with
\f[V]<OuterRows> * <Inner>\f[R] elements, and the second argument
\f[V]%B\f[R] to a matrix with \f[V]<Inner> * <OuterColumns>\f[R]
elements.
Arguments \f[V]<OuterRows>\f[R], \f[V]<Inner>\f[R] and
\f[V]<OuterColumns>\f[R] must be positive, constant integers.
The returned vector must have \f[V]<OuterRows> * <OuterColumns>\f[R]
elements.
Vectors \f[V]%A\f[R], \f[V]%B\f[R], and the returned vector all have the
same float or integer element type.
.SS \[aq]\f[V]llvm.matrix.column.major.load.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare vectorty \[at]llvm.matrix.column.major.load.*(
    ptrty %Ptr, i64 %Stride, i1 <IsVolatile>, i32 <Rows>, i32 <Cols>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.matrix.column.major.load.*\f[R]\[aq] intrinsics load
a \f[V]<Rows> x <Cols>\f[R] matrix using a stride of \f[V]%Stride\f[R]
to compute the start address of the different columns.
The offset is computed using \f[V]%Stride\f[R]\[aq]s bitwidth.
This allows for convenient loading of sub matrixes.
If \f[V]<IsVolatile>\f[R] is true, the intrinsic is considered a
\f[V]volatile memory access <volatile>\f[R].
The result matrix is returned in the result vector.
If the \f[V]%Ptr\f[R] argument is known to be aligned to some boundary,
this can be specified as an attribute on the argument.
.SS Arguments:
.PP
The first argument \f[V]%Ptr\f[R] is a pointer type to the returned
vector type, and corresponds to the start address to load from.
The second argument \f[V]%Stride\f[R] is a positive, constant integer
with \f[V]%Stride >= <Rows>\f[R].
\f[V]%Stride\f[R] is used to compute the column memory addresses.
I.e., for a column \f[V]C\f[R], its start memory addresses is calculated
with \f[V]%Ptr + C * %Stride\f[R].
The third Argument \f[V]<IsVolatile>\f[R] is a boolean value.
The fourth and fifth arguments, \f[V]<Rows>\f[R] and \f[V]<Cols>\f[R],
correspond to the number of rows and columns, respectively, and must be
positive, constant integers.
The returned vector must have \f[V]<Rows> * <Cols>\f[R] elements.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the \f[V]%Ptr\f[R] arguments.
.SS \[aq]\f[V]llvm.matrix.column.major.store.*\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.matrix.column.major.store.*(
    vectorty %In, ptrty %Ptr, i64 %Stride, i1 <IsVolatile>, i32 <Rows>, i32 <Cols>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.matrix.column.major.store.*\f[R]\[aq] intrinsics
store the \f[V]<Rows> x <Cols>\f[R] matrix in \f[V]%In\f[R] to memory
using a stride of \f[V]%Stride\f[R] between columns.
The offset is computed using \f[V]%Stride\f[R]\[aq]s bitwidth.
If \f[V]<IsVolatile>\f[R] is true, the intrinsic is considered a
\f[V]volatile memory access <volatile>\f[R].
.PP
If the \f[V]%Ptr\f[R] argument is known to be aligned to some boundary,
this can be specified as an attribute on the argument.
.SS Arguments:
.PP
The first argument \f[V]%In\f[R] is a vector that corresponds to a
\f[V]<Rows> x <Cols>\f[R] matrix to be stored to memory.
The second argument \f[V]%Ptr\f[R] is a pointer to the vector type of
\f[V]%In\f[R], and is the start address of the matrix in memory.
The third argument \f[V]%Stride\f[R] is a positive, constant integer
with \f[V]%Stride >= <Rows>\f[R].
\f[V]%Stride\f[R] is used to compute the column memory addresses.
I.e., for a column \f[V]C\f[R], its start memory addresses is calculated
with \f[V]%Ptr + C * %Stride\f[R].
The fourth argument \f[V]<IsVolatile>\f[R] is a boolean value.
The arguments \f[V]<Rows>\f[R] and \f[V]<Cols>\f[R] correspond to the
number of rows and columns, respectively, and must be positive, constant
integers.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the \f[V]%Ptr\f[R] arguments.
.SS Half Precision Floating-Point Intrinsics
.PP
For most target platforms, half precision floating-point is a
storage-only format.
This means that it is a dense encoding (in memory) but does not support
computation in the format.
.PP
This means that code must first load the half-precision floating-point
value as an i16, then convert it to float with
\f[V]llvm.convert.from.fp16 <int_convert_from_fp16>\f[R].
Computation can then be performed on the float value (including
extending to double etc).
To store the value back to memory, it is first converted to float if
needed, then converted to i16 with
\f[V]llvm.convert.to.fp16 <int_convert_to_fp16>\f[R], then storing as an
i16 value.
.SS \[aq]\f[V]llvm.convert.to.fp16\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i16 \[at]llvm.convert.to.fp16.f32(float %a)
declare i16 \[at]llvm.convert.to.fp16.f64(double %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.convert.to.fp16\f[R]\[aq] intrinsic function performs
a conversion from a conventional floating-point type to half precision
floating-point format.
.SS Arguments:
.PP
The intrinsic function contains single argument - the value to be
converted.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.convert.to.fp16\f[R]\[aq] intrinsic function performs
a conversion from a conventional floating-point format to half precision
floating-point format.
The return value is an \f[V]i16\f[R] which contains the converted
number.
.SS Examples:
.IP
.nf
\f[C]
%res = call i16 \[at]llvm.convert.to.fp16.f32(float %a)
store i16 %res, i16* \[at]x, align 2
\f[R]
.fi
.SS \[aq]\f[V]llvm.convert.from.fp16\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare float \[at]llvm.convert.from.fp16.f32(i16 %a)
declare double \[at]llvm.convert.from.fp16.f64(i16 %a)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.convert.from.fp16\f[R]\[aq] intrinsic function
performs a conversion from half precision floating-point format to
single precision floating-point format.
.SS Arguments:
.PP
The intrinsic function contains single argument - the value to be
converted.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.convert.from.fp16\f[R]\[aq] intrinsic function
performs a conversion from half single precision floating-point format
to single precision floating-point format.
The input half-float value is represented by an \f[V]i16\f[R] value.
.SS Examples:
.IP
.nf
\f[C]
%a = load i16, i16* \[at]x, align 2
%res = call float \[at]llvm.convert.from.fp16(i16 %a)
\f[R]
.fi
.SS Saturating floating-point to integer conversions
.PP
The \f[V]fptoui\f[R] and \f[V]fptosi\f[R] instructions return a
\f[V]poison value <poisonvalues>\f[R] if the rounded-towards-zero value
is not representable by the result type.
These intrinsics provide an alternative conversion, which will saturate
towards the smallest and largest representable integer values instead.
.SS \[aq]\f[V]llvm.fptoui.sat.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fptoui.sat\f[R] on any floating-point argument
type and any integer result type, or vectors thereof.
Not all targets may support all types, however.
.IP
.nf
\f[C]
declare i32 \[at]llvm.fptoui.sat.i32.f32(float %f)
declare i19 \[at]llvm.fptoui.sat.i19.f64(double %f)
declare <4 x i100> \[at]llvm.fptoui.sat.v4i100.v4f128(<4 x fp128> %f)
\f[R]
.fi
.SS Overview:
.PP
This intrinsic converts the argument into an unsigned integer using
saturating semantics.
.SS Arguments:
.PP
The argument may be any floating-point or vector of floating-point type.
The return value may be any integer or vector of integer type.
The number of vector elements in argument and return must be the same.
.SS Semantics:
.PP
The conversion to integer is performed subject to the following rules:
.IP \[bu] 2
If the argument is any NaN, zero is returned.
.IP \[bu] 2
If the argument is smaller than zero (this includes negative infinity),
zero is returned.
.IP \[bu] 2
If the argument is larger than the largest representable unsigned
integer of the result type (this includes positive infinity), the
largest representable unsigned integer is returned.
.IP \[bu] 2
Otherwise, the result of rounding the argument towards zero is returned.
.SS Example:
.IP
.nf
\f[C]
%a = call i8 \[at]llvm.fptoui.sat.i8.f32(float 123.9)              ; yields i8: 123
%b = call i8 \[at]llvm.fptoui.sat.i8.f32(float -5.7)               ; yields i8:   0
%c = call i8 \[at]llvm.fptoui.sat.i8.f32(float 377.0)              ; yields i8: 255
%d = call i8 \[at]llvm.fptoui.sat.i8.f32(float 0xFFF8000000000000) ; yields i8:   0
\f[R]
.fi
.SS \[aq]\f[V]llvm.fptosi.sat.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.fptosi.sat\f[R] on any floating-point argument
type and any integer result type, or vectors thereof.
Not all targets may support all types, however.
.IP
.nf
\f[C]
declare i32 \[at]llvm.fptosi.sat.i32.f32(float %f)
declare i19 \[at]llvm.fptosi.sat.i19.f64(double %f)
declare <4 x i100> \[at]llvm.fptosi.sat.v4i100.v4f128(<4 x fp128> %f)
\f[R]
.fi
.SS Overview:
.PP
This intrinsic converts the argument into a signed integer using
saturating semantics.
.SS Arguments:
.PP
The argument may be any floating-point or vector of floating-point type.
The return value may be any integer or vector of integer type.
The number of vector elements in argument and return must be the same.
.SS Semantics:
.PP
The conversion to integer is performed subject to the following rules:
.IP \[bu] 2
If the argument is any NaN, zero is returned.
.IP \[bu] 2
If the argument is smaller than the smallest representable signed
integer of the result type (this includes negative infinity), the
smallest representable signed integer is returned.
.IP \[bu] 2
If the argument is larger than the largest representable signed integer
of the result type (this includes positive infinity), the largest
representable signed integer is returned.
.IP \[bu] 2
Otherwise, the result of rounding the argument towards zero is returned.
.SS Example:
.IP
.nf
\f[C]
%a = call i8 \[at]llvm.fptosi.sat.i8.f32(float 23.9)               ; yields i8:   23
%b = call i8 \[at]llvm.fptosi.sat.i8.f32(float -130.8)             ; yields i8: -128
%c = call i8 \[at]llvm.fptosi.sat.i8.f32(float 999.0)              ; yields i8:  127
%d = call i8 \[at]llvm.fptosi.sat.i8.f32(float 0xFFF8000000000000) ; yields i8:    0
\f[R]
.fi
.SS Debugger Intrinsics
.PP
The LLVM debugger intrinsics (which all start with \f[V]llvm.dbg.\f[R]
prefix), are described in the LLVM Source Level Debugging document.
.SS Exception Handling Intrinsics
.PP
The LLVM exception handling intrinsics (which all start with
\f[V]llvm.eh.\f[R] prefix), are described in the LLVM Exception Handling
document.
.SS Pointer Authentication Intrinsics
.PP
The LLVM pointer authentication intrinsics (which all start with
\f[V]llvm.ptrauth.\f[R] prefix), are described in the Pointer
Authentication document.
.SS Trampoline Intrinsics
.PP
These intrinsics make it possible to excise one parameter, marked with
the \f[V]nest <nest>\f[R] attribute, from a function.
The result is a callable function pointer lacking the nest parameter -
the caller does not need to provide a value for it.
Instead, the value to use is stored in advance in a
\[dq]trampoline\[dq], a block of memory usually allocated on the stack,
which also contains code to splice the nest value into the argument
list.
This is used to implement the GCC nested function address extension.
.PP
For example, if the function is
\f[V]i32 f(i8* nest %c, i32 %x, i32 %y)\f[R] then the resulting function
pointer has signature \f[V]i32 (i32, i32)*\f[R].
It can be created as follows:
.IP
.nf
\f[C]
%tramp = alloca [10 x i8], align 4 ; size and alignment only correct for X86
%tramp1 = getelementptr [10 x i8], [10 x i8]* %tramp, i32 0, i32 0
call i8* \[at]llvm.init.trampoline(i8* %tramp1, i8* bitcast (i32 (i8*, i32, i32)* \[at]f to i8*), i8* %nval)
%p = call i8* \[at]llvm.adjust.trampoline(i8* %tramp1)
%fp = bitcast i8* %p to i32 (i32, i32)*
\f[R]
.fi
.PP
The call \f[V]%val = call i32 %fp(i32 %x, i32 %y)\f[R] is then
equivalent to \f[V]%val = call i32 %f(i8* %nval, i32 %x, i32 %y)\f[R].
.SS \[aq]\f[V]llvm.init.trampoline\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.init.trampoline(i8* <tramp>, i8* <func>, i8* <nval>)
\f[R]
.fi
.SS Overview:
.PP
This fills the memory pointed to by \f[V]tramp\f[R] with executable
code, turning it into a trampoline.
.SS Arguments:
.PP
The \f[V]llvm.init.trampoline\f[R] intrinsic takes three arguments, all
pointers.
The \f[V]tramp\f[R] argument must point to a sufficiently large and
sufficiently aligned block of memory; this memory is written to by the
intrinsic.
Note that the size and the alignment are target-specific -LLVM currently
provides no portable way of determining them, so a front-end that
generates this intrinsic needs to have some target-specific knowledge.
The \f[V]func\f[R] argument must hold a function bitcast to an
\f[V]i8*\f[R].
.SS Semantics:
.PP
The block of memory pointed to by \f[V]tramp\f[R] is filled with target
dependent code, turning it into a function.
Then \f[V]tramp\f[R] needs to be passed to
\f[V]llvm.adjust.trampoline <int_at>\f[R] to get a pointer which can be
\f[V]bitcast (to a new function) and called <int_trampoline>\f[R].
The new function\[aq]s signature is the same as that of \f[V]func\f[R]
with any arguments marked with the \f[V]nest\f[R] attribute removed.
At most one such \f[V]nest\f[R] argument is allowed, and it must be of
pointer type.
Calling the new function is equivalent to calling \f[V]func\f[R] with
the same argument list, but with \f[V]nval\f[R] used for the missing
\f[V]nest\f[R] argument.
If, after calling \f[V]llvm.init.trampoline\f[R], the memory pointed to
by \f[V]tramp\f[R] is modified, then the effect of any later call to the
returned function pointer is undefined.
.SS \[aq]\f[V]llvm.adjust.trampoline\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.adjust.trampoline(i8* <tramp>)
\f[R]
.fi
.SS Overview:
.PP
This performs any required machine-specific adjustment to the address of
a trampoline (passed as \f[V]tramp\f[R]).
.SS Arguments:
.PP
\f[V]tramp\f[R] must point to a block of memory which already has
trampoline code filled in by a previous call to
\f[V]llvm.init.trampoline <int_it>\f[R].
.SS Semantics:
.PP
On some architectures the address of the code to be executed needs to be
different than the address where the trampoline is actually stored.
This intrinsic returns the executable address corresponding to
\f[V]tramp\f[R] after performing the required machine specific
adjustments.
The pointer returned can then be
\f[V]bitcast and executed <int_trampoline>\f[R].
.SS Vector Predication Intrinsics
.PP
VP intrinsics are intended for predicated SIMD/vector code.
A typical VP operation takes a vector mask and an explicit vector length
parameter as in:
.IP
.nf
\f[C]
<W x T> llvm.vp.<opcode>.*(<W x T> %x, <W x T> %y, <W x i1> %mask, i32 %evl)
\f[R]
.fi
.PP
The vector mask parameter (%mask) always has a vector of i1 type, for
example <32 x i1>.
The explicit vector length parameter always has the type i32 and is an
unsigned integer value.
The explicit vector length parameter (%evl) is in the range:
.IP
.nf
\f[C]
0 <= %evl <= W,  where W is the number of vector elements
\f[R]
.fi
.PP
Note that for \f[V]scalable vector types <t_vector>\f[R] \f[V]W\f[R] is
the runtime length of the vector.
.PP
The VP intrinsic has undefined behavior if \f[V]%evl > W\f[R].
The explicit vector length (%evl) creates a mask, %EVLmask, with all
elements \f[V]0 <= i < %evl\f[R] set to True, and all other lanes
\f[V]%evl <= i < W\f[R] to False.
A new mask %M is calculated with an element-wise AND from %mask and
%EVLmask:
.IP
.nf
\f[C]
M = %mask AND %EVLmask
\f[R]
.fi
.PP
A vector operation \f[V]<opcode>\f[R] on vectors \f[V]A\f[R] and
\f[V]B\f[R] calculates:
.IP
.nf
\f[C]
A <opcode> B =  {  A[i] <opcode> B[i]   M[i] = True, and
                {  undef otherwise
\f[R]
.fi
.SS Optimization Hint
.PP
Some targets, such as AVX512, do not support the %evl parameter in
hardware.
The use of an effective %evl is discouraged for those targets.
The function \f[V]TargetTransformInfo::hasActiveVectorLength()\f[R]
returns true when the target has native support for %evl.
.SS \[aq]\f[V]llvm.vp.select.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.select.v16i32 (<16 x i1> <condition>, <16 x i32> <on_true>, <16 x i32> <on_false>, i32 <evl>)
declare <vscale x 4 x i64>  \[at]llvm.vp.select.nxv4i64 (<vscale x 4 x i1> <condition>, <vscale x 4 x i64> <on_true>, <vscale x 4 x i64> <on_false>, i32 <evl>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.select\f[R]\[aq] intrinsic is used to choose one
value based on a condition vector, without IR-level branching.
.SS Arguments:
.PP
The first operand is a vector of \f[V]i1\f[R] and indicates the
condition.
The second operand is the value that is selected where the condition
vector is true.
The third operand is the value that is selected where the condition
vector is false.
The vectors must be of the same size.
The fourth operand is the explicit vector length.
.IP "1." 3
The optional \f[V]fast-math flags\f[R] marker indicates that the select
has one or more \f[V]fast-math flags <fastmath>\f[R].
These are optimization hints to enable otherwise unsafe floating-point
optimizations.
Fast-math flags are only valid for selects that return a floating-point
scalar or vector type, or an array (nested to any depth) of
floating-point scalar or vector types.
.SS Semantics:
.PP
The intrinsic selects lanes from the second and third operand depending
on a condition vector.
.PP
All result lanes at positions greater or equal than \f[V]%evl\f[R] are
undefined.
For all lanes below \f[V]%evl\f[R] where the condition vector is true
the lane is taken from the second operand.
Otherwise, the lane is taken from the third operand.
.SS Example:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.select.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %evl)

;;; Expansion.
;; Any result is legal on lanes at and above %evl.
%also.r = select <4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.merge.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.merge.v16i32 (<16 x i1> <condition>, <16 x i32> <on_true>, <16 x i32> <on_false>, i32 <pivot>)
declare <vscale x 4 x i64>  \[at]llvm.vp.merge.nxv4i64 (<vscale x 4 x i1> <condition>, <vscale x 4 x i64> <on_true>, <vscale x 4 x i64> <on_false>, i32 <pivot>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.merge\f[R]\[aq] intrinsic is used to choose one
value based on a condition vector and an index operand, without IR-level
branching.
.SS Arguments:
.PP
The first operand is a vector of \f[V]i1\f[R] and indicates the
condition.
The second operand is the value that is merged where the condition
vector is true.
The third operand is the value that is selected where the condition
vector is false or the lane position is greater equal than the pivot.
The fourth operand is the pivot.
.IP "1." 3
The optional \f[V]fast-math flags\f[R] marker indicates that the merge
has one or more \f[V]fast-math flags <fastmath>\f[R].
These are optimization hints to enable otherwise unsafe floating-point
optimizations.
Fast-math flags are only valid for merges that return a floating-point
scalar or vector type, or an array (nested to any depth) of
floating-point scalar or vector types.
.SS Semantics:
.PP
The intrinsic selects lanes from the second and third operand depending
on a condition vector and pivot value.
.PP
For all lanes where the condition vector is true and the lane position
is less than \f[V]%pivot\f[R] the lane is taken from the second operand.
Otherwise, the lane is taken from the third operand.
.SS Example:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.merge.v4i32(<4 x i1> %cond, <4 x i32> %on_true, <4 x i32> %on_false, i32 %pivot)

;;; Expansion.
;; Lanes at and above %pivot are taken from %on_false
%atfirst = insertelement <4 x i32> undef, i32 %pivot, i32 0
%splat = shufflevector <4 x i32> %atfirst, <4 x i32> poison, <4 x i32> zeroinitializer
%pivotmask = icmp ult <4 x i32> <i32 0, i32 1, i32 2, i32 3>, <4 x i32> %splat
%mergemask = and <4 x i1> %cond, <4 x i1> %pivotmask
%also.r = select <4 x i1> %mergemask, <4 x i32> %on_true, <4 x i32> %on_false
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.add.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.add.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.add.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.add.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer addition of two vectors of integers.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.add\f[R]\[aq] intrinsic performs integer addition
(\f[V]add <i_add>\f[R]) of the first and second vector operand on each
enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.add.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = add <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.sub.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.sub.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.sub.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.sub.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer subtraction of two vectors of integers.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.sub\f[R]\[aq] intrinsic performs integer
subtraction (\f[V]sub <i_sub>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.sub.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = sub <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.mul.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.mul.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.mul.nxv46i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.mul.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer multiplication of two vectors of integers.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.mul\f[R]\[aq] intrinsic performs integer
multiplication (\f[V]mul <i_mul>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.mul.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = mul <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.sdiv.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.sdiv.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.sdiv.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.sdiv.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated, signed division of two vectors of integers.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.sdiv\f[R]\[aq] intrinsic performs signed division
(\f[V]sdiv <i_sdiv>\f[R]) of the first and second vector operand on each
enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.sdiv.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = sdiv <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.udiv.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.udiv.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.udiv.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.udiv.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated, unsigned division of two vectors of integers.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.udiv\f[R]\[aq] intrinsic performs unsigned
division (\f[V]udiv <i_udiv>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.udiv.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = udiv <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.srem.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.srem.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.srem.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.srem.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated computations of the signed remainder of two integer vectors.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.srem\f[R]\[aq] intrinsic computes the remainder of
the signed division (\f[V]srem <i_srem>\f[R]) of the first and second
vector operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.srem.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = srem <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.urem.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.urem.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.urem.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.urem.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated computation of the unsigned remainder of two integer vectors.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.urem\f[R]\[aq] intrinsic computes the remainder of
the unsigned division (\f[V]urem <i_urem>\f[R]) of the first and second
vector operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.urem.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = urem <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.ashr.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.ashr.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.ashr.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.ashr.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated arithmetic right-shift.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.ashr\f[R]\[aq] intrinsic computes the arithmetic
right shift (\f[V]ashr <i_ashr>\f[R]) of the first operand by the second
operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.ashr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = ashr <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.lshr.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.lshr.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.lshr.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.lshr.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated logical right-shift.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.lshr\f[R]\[aq] intrinsic computes the logical
right shift (\f[V]lshr <i_lshr>\f[R]) of the first operand by the second
operand on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.lshr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = lshr <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.shl.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.shl.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.shl.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.shl.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated left shift.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.shl\f[R]\[aq] intrinsic computes the left shift
(\f[V]shl <i_shl>\f[R]) of the first operand by the second operand on
each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.shl.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = shl <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.or.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.or.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.or.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.or.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated or.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.or\f[R]\[aq] intrinsic performs a bitwise or
(\f[V]or <i_or>\f[R]) of the first two operands on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.or.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = or <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.and.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.and.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.and.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.and.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated and.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.and\f[R]\[aq] intrinsic performs a bitwise and
(\f[V]and <i_or>\f[R]) of the first two operands on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.and.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = and <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.xor.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.xor.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.xor.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.xor.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Vector-predicated, bitwise xor.
.SS Arguments:
.PP
The first two operands and the result have the same vector of integer
type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.xor\f[R]\[aq] intrinsic performs a bitwise xor
(\f[V]xor <i_xor>\f[R]) of the first two operands on each enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.xor.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = xor <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fadd.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fadd.v16f32 (<16 x float> <left_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fadd.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fadd.v256f64 (<256 x double> <left_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point addition of two vectors of floating-point
values.
.SS Arguments:
.PP
The first two operands and the result have the same vector of
floating-point type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fadd\f[R]\[aq] intrinsic performs floating-point
addition (\f[V]fadd <i_fadd>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fadd.v4f32(<4 x float> %a, <4 x float> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fadd <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fsub.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fsub.v16f32 (<16 x float> <left_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fsub.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fsub.v256f64 (<256 x double> <left_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point subtraction of two vectors of floating-point
values.
.SS Arguments:
.PP
The first two operands and the result have the same vector of
floating-point type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fsub\f[R]\[aq] intrinsic performs floating-point
subtraction (\f[V]fsub <i_fsub>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fsub.v4f32(<4 x float> %a, <4 x float> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fsub <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fmul.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fmul.v16f32 (<16 x float> <left_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fmul.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fmul.v256f64 (<256 x double> <left_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point multiplication of two vectors of
floating-point values.
.SS Arguments:
.PP
The first two operands and the result have the same vector of
floating-point type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fmul\f[R]\[aq] intrinsic performs floating-point
multiplication (\f[V]fmul <i_fmul>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fmul.v4f32(<4 x float> %a, <4 x float> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fmul <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fdiv.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fdiv.v16f32 (<16 x float> <left_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fdiv.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fdiv.v256f64 (<256 x double> <left_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point division of two vectors of floating-point
values.
.SS Arguments:
.PP
The first two operands and the result have the same vector of
floating-point type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fdiv\f[R]\[aq] intrinsic performs floating-point
division (\f[V]fdiv <i_fdiv>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fdiv.v4f32(<4 x float> %a, <4 x float> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fdiv <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.frem.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.frem.v16f32 (<16 x float> <left_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.frem.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.frem.v256f64 (<256 x double> <left_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point remainder of two vectors of floating-point
values.
.SS Arguments:
.PP
The first two operands and the result have the same vector of
floating-point type.
The third operand is the vector mask and has the same number of elements
as the result vector type.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.frem\f[R]\[aq] intrinsic performs floating-point
remainder (\f[V]frem <i_frem>\f[R]) of the first and second vector
operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.frem.v4f32(<4 x float> %a, <4 x float> %b, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = frem <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fneg.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fneg.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fneg.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fneg.v256f64 (<256 x double> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point negation of a vector of floating-point values.
.SS Arguments:
.PP
The first operand and the result have the same vector of floating-point
type.
The second operand is the vector mask and has the same number of
elements as the result vector type.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fneg\f[R]\[aq] intrinsic performs floating-point
negation (\f[V]fneg <i_fneg>\f[R]) of the first vector operand on each
enabled lane.
The result on disabled lanes is undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fneg.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fneg <4 x float> %a
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fma.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fma.v16f32 (<16 x float> <left_op>, <16 x float> <middle_op>, <16 x float> <right_op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.fma.nxv4f32 (<vscale x 4 x float> <left_op>, <vscale x 4 x float> <middle_op>, <vscale x 4 x float> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.fma.v256f64 (<256 x double> <left_op>, <256 x double> <middle_op>, <256 x double> <right_op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point fused multiply-add of two vectors of
floating-point values.
.SS Arguments:
.PP
The first three operands and the result have the same vector of
floating-point type.
The fourth operand is the vector mask and has the same number of
elements as the result vector type.
The fifth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fma\f[R]\[aq] intrinsic performs floating-point
fused multiply-add (\f[V]llvm.fma <int_fma>\f[R]) of the first, second,
and third vector operand on each enabled lane.
The result on disabled lanes is undefined.
The operation is performed in the default floating-point environment.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fma.v4f32(<4 x float> %a, <4 x float> %b, <4 x float> %c, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = call <4 x float> \[at]llvm.fma(<4 x float> %a, <4 x float> %b, <4 x float> %c)
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.add.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.add.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.add.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer \f[V]ADD\f[R] reduction of a vector and a scalar
starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.add\f[R]\[aq] intrinsic performs the
integer \f[V]ADD\f[R] reduction
(\f[V]llvm.vector.reduce.add <int_vector_reduce_add>\f[R]) of the vector
operand \f[V]val\f[R] on each enabled lane, adding it to the scalar
\f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value \f[V]0\f[R]
(i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is equal to
\f[V]start_value\f[R].
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.add.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> zeroinitializer
%reduction = call i32 \[at]llvm.vector.reduce.add.v4i32(<4 x i32> %masked.a)
%also.r = add i32 %reduction, %start
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.fadd.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare float \[at]llvm.vp.reduce.fadd.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare double \[at]llvm.vp.reduce.fadd.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point \f[V]ADD\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar floating-point type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of floating-point values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.fadd\f[R]\[aq] intrinsic performs the
floating-point \f[V]ADD\f[R] reduction
(\f[V]llvm.vector.reduce.fadd <int_vector_reduce_fadd>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, adding it to the
scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value
\f[V]-0.0\f[R] (i.e.
having no effect on the reduction operation).
If no lanes are enabled, the resulting value will be equal to
\f[V]start_value\f[R].
.PP
To ignore the start value, the neutral value can be used.
.PP
See the unpredicated version (\f[V]llvm.vector.reduce.fadd
<int_vector_reduce_fadd>\f[R]) for more detail on the semantics of the
reduction.
.SS Examples:
.IP
.nf
\f[C]
%r = call float \[at]llvm.vp.reduce.fadd.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float -0.0, float -0.0, float -0.0, float -0.0>
%also.r = call float \[at]llvm.vector.reduce.fadd.v4f32(float %start, <4 x float> %masked.a)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.mul.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.mul.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.mul.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer \f[V]MUL\f[R] reduction of a vector and a scalar
starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.mul\f[R]\[aq] intrinsic performs the
integer \f[V]MUL\f[R] reduction
(\f[V]llvm.vector.reduce.mul <int_vector_reduce_mul>\f[R]) of the vector
operand \f[V]val\f[R] on each enabled lane, multiplying it by the scalar
\f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value \f[V]1\f[R]
(i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.mul.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 1, i32 1, i32 1, i32 1>
%reduction = call i32 \[at]llvm.vector.reduce.mul.v4i32(<4 x i32> %masked.a)
%also.r = mul i32 %reduction, %start
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.fmul.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare float \[at]llvm.vp.reduce.fmul.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare double \[at]llvm.vp.reduce.fmul.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point \f[V]MUL\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar floating-point type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of floating-point values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.fmul\f[R]\[aq] intrinsic performs the
floating-point \f[V]MUL\f[R] reduction
(\f[V]llvm.vector.reduce.fmul <int_vector_reduce_fmul>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, multiplying it by the
scalar start_value.
Disabled lanes are treated as containing the neutral value 1.0\[ga]
(i.e.
having no effect on the reduction operation).
If no lanes are enabled, the resulting value will be equal to the
starting value.
.PP
To ignore the start value, the neutral value can be used.
.PP
See the unpredicated version (\f[V]llvm.vector.reduce.fmul
<int_vector_reduce_fmul>\f[R]) for more detail on the semantics.
.SS Examples:
.IP
.nf
\f[C]
%r = call float \[at]llvm.vp.reduce.fmul.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float 1.0, float 1.0, float 1.0, float 1.0>
%also.r = call float \[at]llvm.vector.reduce.fmul.v4f32(float %start, <4 x float> %masked.a)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.and.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.and.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.and.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer \f[V]AND\f[R] reduction of a vector and a scalar
starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.and\f[R]\[aq] intrinsic performs the
integer \f[V]AND\f[R] reduction
(\f[V]llvm.vector.reduce.and <int_vector_reduce_and>\f[R]) of the vector
operand \f[V]val\f[R] on each enabled lane, performing an
\[aq]\f[V]and\f[R]\[aq] of that with with the scalar
\f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value
\f[V]UINT_MAX\f[R], or \f[V]-1\f[R] (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.and.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>
%reduction = call i32 \[at]llvm.vector.reduce.and.v4i32(<4 x i32> %masked.a)
%also.r = and i32 %reduction, %start
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.or.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.or.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.or.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer \f[V]OR\f[R] reduction of a vector and a scalar
starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.or\f[R]\[aq] intrinsic performs the integer
\f[V]OR\f[R] reduction
(\f[V]llvm.vector.reduce.or <int_vector_reduce_or>\f[R]) of the vector
operand \f[V]val\f[R] on each enabled lane, performing an
\[aq]\f[V]or\f[R]\[aq] of that with the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value \f[V]0\f[R]
(i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.or.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
%reduction = call i32 \[at]llvm.vector.reduce.or.v4i32(<4 x i32> %masked.a)
%also.r = or i32 %reduction, %start
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.xor.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.xor.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.xor.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated integer \f[V]XOR\f[R] reduction of a vector and a scalar
starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.xor\f[R]\[aq] intrinsic performs the
integer \f[V]XOR\f[R] reduction
(\f[V]llvm.vector.reduce.xor <int_vector_reduce_xor>\f[R]) of the vector
operand \f[V]val\f[R] on each enabled lane, performing an
\[aq]\f[V]xor\f[R]\[aq] of that with the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value \f[V]0\f[R]
(i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.xor.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
%reduction = call i32 \[at]llvm.vector.reduce.xor.v4i32(<4 x i32> %masked.a)
%also.r = xor i32 %reduction, %start
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.smax.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.smax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.smax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated signed-integer \f[V]MAX\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.smax\f[R]\[aq] intrinsic performs the
signed-integer \f[V]MAX\f[R] reduction
(\f[V]llvm.vector.reduce.smax <int_vector_reduce_smax>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, and taking the
maximum of that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value
\f[V]INT_MIN\f[R] (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i8 \[at]llvm.vp.reduce.smax.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 -128, i8 -128, i8 -128, i8 -128>
%reduction = call i8 \[at]llvm.vector.reduce.smax.v4i8(<4 x i8> %masked.a)
%also.r = call i8 \[at]llvm.smax.i8(i8 %reduction, i8 %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.smin.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.smin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.smin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated signed-integer \f[V]MIN\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.smin\f[R]\[aq] intrinsic performs the
signed-integer \f[V]MIN\f[R] reduction
(\f[V]llvm.vector.reduce.smin <int_vector_reduce_smin>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, and taking the
minimum of that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value
\f[V]INT_MAX\f[R] (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i8 \[at]llvm.vp.reduce.smin.v4i8(i8 %start, <4 x i8> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i8> %a, <4 x i8> <i8 127, i8 127, i8 127, i8 127>
%reduction = call i8 \[at]llvm.vector.reduce.smin.v4i8(<4 x i8> %masked.a)
%also.r = call i8 \[at]llvm.smin.i8(i8 %reduction, i8 %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.umax.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.umax.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.umax.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated unsigned-integer \f[V]MAX\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.umax\f[R]\[aq] intrinsic performs the
unsigned-integer \f[V]MAX\f[R] reduction
(\f[V]llvm.vector.reduce.umax <int_vector_reduce_umax>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, and taking the
maximum of that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value \f[V]0\f[R]
(i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.umax.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
%reduction = call i32 \[at]llvm.vector.reduce.umax.v4i32(<4 x i32> %masked.a)
%also.r = call i32 \[at]llvm.umax.i32(i32 %reduction, i32 %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.umin.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare i32 \[at]llvm.vp.reduce.umin.v4i32(i32 <start_value>, <4 x i32> <val>, <4 x i1> <mask>, i32 <vector_length>)
declare i16 \[at]llvm.vp.reduce.umin.nxv8i16(i16 <start_value>, <vscale x 8 x i16> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated unsigned-integer \f[V]MIN\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar integer type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of integer values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.umin\f[R]\[aq] intrinsic performs the
unsigned-integer \f[V]MIN\f[R] reduction
(\f[V]llvm.vector.reduce.umin <int_vector_reduce_umin>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, taking the minimum of
that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value
\f[V]UINT_MAX\f[R], or \f[V]-1\f[R] (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call i32 \[at]llvm.vp.reduce.umin.v4i32(i32 %start, <4 x i32> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x i32> %a, <4 x i32> <i32 -1, i32 -1, i32 -1, i32 -1>
%reduction = call i32 \[at]llvm.vector.reduce.umin.v4i32(<4 x i32> %masked.a)
%also.r = call i32 \[at]llvm.umin.i32(i32 %reduction, i32 %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.fmax.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare float \[at]llvm.vp.reduce.fmax.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>)
declare double \[at]llvm.vp.reduce.fmax.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point \f[V]MAX\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar floating-point type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of floating-point values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.fmax\f[R]\[aq] intrinsic performs the
floating-point \f[V]MAX\f[R] reduction
(\f[V]llvm.vector.reduce.fmax <int_vector_reduce_fmax>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, taking the maximum of
that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
The neutral value is dependent on the
\f[V]fast-math flags <fastmath>\f[R].
If no flags are set, the neutral value is \f[V]-QNAN\f[R].
If \f[V]nnan\f[R] and \f[V]ninf\f[R] are both set, then the neutral
value is the smallest floating-point value for the result type.
If only \f[V]nnan\f[R] is set then the neutral value is
\f[V]-Infinity\f[R].
.PP
This instruction has the same comparison semantics as the
\f[V]llvm.vector.reduce.fmax <int_vector_reduce_fmax>\f[R] intrinsic
(and thus the \[aq]\f[V]llvm.maxnum.*\f[R]\[aq] intrinsic).
That is, the result will always be a number unless all elements of the
vector and the starting value are \f[V]NaN\f[R].
For a vector with maximum element magnitude \f[V]0.0\f[R] and containing
both \f[V]+0.0\f[R] and \f[V]-0.0\f[R] elements, the sign of the result
is unspecified.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call float \[at]llvm.vp.reduce.fmax.v4f32(float %float, <4 x float> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>
%reduction = call float \[at]llvm.vector.reduce.fmax.v4f32(<4 x float> %masked.a)
%also.r = call float \[at]llvm.maxnum.f32(float %reduction, float %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.reduce.fmin.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare float \[at]llvm.vp.reduce.fmin.v4f32(float <start_value>, <4 x float> <val>, <4 x i1> <mask>, float <vector_length>)
declare double \[at]llvm.vp.reduce.fmin.nxv8f64(double <start_value>, <vscale x 8 x double> <val>, <vscale x 8 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
Predicated floating-point \f[V]MIN\f[R] reduction of a vector and a
scalar starting value, returning the result as a scalar.
.SS Arguments:
.PP
The first operand is the start value of the reduction, which must be a
scalar floating-point type equal to the result type.
The second operand is the vector on which the reduction is performed and
must be a vector of floating-point values whose element type is the
result/start type.
The third operand is the vector mask and is a vector of boolean values
with the same number of elements as the vector operand.
The fourth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.reduce.fmin\f[R]\[aq] intrinsic performs the
floating-point \f[V]MIN\f[R] reduction
(\f[V]llvm.vector.reduce.fmin <int_vector_reduce_fmin>\f[R]) of the
vector operand \f[V]val\f[R] on each enabled lane, taking the minimum of
that and the scalar \f[V]start_value\f[R].
Disabled lanes are treated as containing the neutral value (i.e.
having no effect on the reduction operation).
If the vector length is zero, the result is the start value.
.PP
The neutral value is dependent on the
\f[V]fast-math flags <fastmath>\f[R].
If no flags are set, the neutral value is \f[V]+QNAN\f[R].
If \f[V]nnan\f[R] and \f[V]ninf\f[R] are both set, then the neutral
value is the largest floating-point value for the result type.
If only \f[V]nnan\f[R] is set then the neutral value is
\f[V]+Infinity\f[R].
.PP
This instruction has the same comparison semantics as the
\f[V]llvm.vector.reduce.fmin <int_vector_reduce_fmin>\f[R] intrinsic
(and thus the \[aq]\f[V]llvm.minnum.*\f[R]\[aq] intrinsic).
That is, the result will always be a number unless all elements of the
vector and the starting value are \f[V]NaN\f[R].
For a vector with maximum element magnitude \f[V]0.0\f[R] and containing
both \f[V]+0.0\f[R] and \f[V]-0.0\f[R] elements, the sign of the result
is unspecified.
.PP
To ignore the start value, the neutral value can be used.
.SS Examples:
.IP
.nf
\f[C]
%r = call float \[at]llvm.vp.reduce.fmin.v4f32(float %start, <4 x float> %a, <4 x i1> %mask, i32 %evl)
; %r is equivalent to %also.r, where lanes greater than or equal to %evl
; are treated as though %mask were false for those lanes.

%masked.a = select <4 x i1> %mask, <4 x float> %a, <4 x float> <float QNAN, float QNAN, float QNAN, float QNAN>
%reduction = call float \[at]llvm.vector.reduce.fmin.v4f32(<4 x float> %masked.a)
%also.r = call float \[at]llvm.minnum.f32(float %reduction, float %start)
\f[R]
.fi
.SS \[aq]\f[V]llvm.get.active.lane.mask.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <4 x i1> \[at]llvm.get.active.lane.mask.v4i1.i32(i32 %base, i32 %n)
declare <8 x i1> \[at]llvm.get.active.lane.mask.v8i1.i64(i64 %base, i64 %n)
declare <16 x i1> \[at]llvm.get.active.lane.mask.v16i1.i64(i64 %base, i64 %n)
declare <vscale x 16 x i1> \[at]llvm.get.active.lane.mask.nxv16i1.i64(i64 %base, i64 %n)
\f[R]
.fi
.SS Overview:
.PP
Create a mask representing active and inactive vector lanes.
.SS Arguments:
.PP
Both operands have the same scalar integer type.
The result is a vector with the i1 element type.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.get.active.lane.mask.*\f[R]\[aq] intrinsics are
semantically equivalent to:
.IP
.nf
\f[C]
%m[i] = icmp ult (%base + i), %n
\f[R]
.fi
.PP
where \f[V]%m\f[R] is a vector (mask) of active/inactive lanes with its
elements indexed by \f[V]i\f[R], and \f[V]%base\f[R], \f[V]%n\f[R] are
the two arguments to \f[V]llvm.get.active.lane.mask.*\f[R],
\f[V]%icmp\f[R] is an integer compare and \f[V]ult\f[R] the unsigned
less-than comparison operator.
Overflow cannot occur in \f[V](%base + i)\f[R] and its comparison
against \f[V]%n\f[R] as it is performed in integer numbers and not in
machine numbers.
If \f[V]%n\f[R] is \f[V]0\f[R], then the result is a poison value.
The above is equivalent to:
.IP
.nf
\f[C]
%m = \[at]llvm.get.active.lane.mask(%base, %n)
\f[R]
.fi
.PP
This can, for example, be emitted by the loop vectorizer in which case
\f[V]%base\f[R] is the first element of the vector induction variable
(VIV) and \f[V]%n\f[R] is the loop tripcount.
Thus, these intrinsics perform an element-wise less than comparison of
VIV with the loop tripcount, producing a mask of true/false values
representing active/inactive vector lanes, except if the VIV overflows
in which case they return false in the lanes where the VIV overflows.
The arguments are scalar types to accommodate scalable vector types, for
which it is unknown what the type of the step vector needs to be that
enumerate its lanes without overflow.
.PP
This mask \f[V]%m\f[R] can e.g.
be used in masked load/store instructions.
These intrinsics provide a hint to the backend.
I.e., for a vector loop, the back-edge taken count of the original
scalar loop is explicit as the second argument.
.SS Examples:
.IP
.nf
\f[C]
%active.lane.mask = call <4 x i1> \[at]llvm.get.active.lane.mask.v4i1.i64(i64 %elem0, i64 429)
%wide.masked.load = call <4 x i32> \[at]llvm.masked.load.v4i32.p0v4i32(<4 x i32>* %3, i32 4, <4 x i1> %active.lane.mask, <4 x i32> undef)
\f[R]
.fi
.SS \[aq]\f[V]llvm.experimental.vp.splice\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <2 x double> \[at]llvm.experimental.vp.splice.v2f64(<2 x double> %vec1, <2 x double> %vec2, i32 %imm, <2 x i1> %mask, i32 %evl1, i32 %evl2)
declare <vscale x 4 x i32> \[at]llvm.experimental.vp.splice.nxv4i32(<vscale x 4 x i32> %vec1, <vscale x 4 x i32> %vec2, i32 %imm, <vscale x 4 x i1> %mask, i32 %evl1, i32 %evl2)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.vp.splice.*\f[R]\[aq] intrinsic is the
vector length predicated version of the
\[aq]\f[V]llvm.experimental.vector.splice.*\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
The result and the first two arguments \f[V]vec1\f[R] and \f[V]vec2\f[R]
are vectors with the same type.
The third argument \f[V]imm\f[R] is an immediate signed integer that
indicates the offset index.
The fourth argument \f[V]mask\f[R] is a vector mask and has the same
number of elements as the result.
The last two arguments \f[V]evl1\f[R] and \f[V]evl2\f[R] are unsigned
integers indicating the explicit vector lengths of \f[V]vec1\f[R] and
\f[V]vec2\f[R] respectively.
\f[V]imm\f[R], \f[V]evl1\f[R] and \f[V]evl2\f[R] should respect the
following constraints: \f[V]-evl1 <= imm < evl1\f[R],
\f[V]0 <= evl1 <= VL\f[R] and \f[V]0 <= evl2 <= VL\f[R], where
\f[V]VL\f[R] is the runtime vector factor.
If these constraints are not satisfied the intrinsic has undefined
behaviour.
.SS Semantics:
.PP
Effectively, this intrinsic concatenates \f[V]vec1[0..evl1-1]\f[R] and
\f[V]vec2[0..evl2-1]\f[R] and creates the result vector by selecting the
elements in a window of size \f[V]evl2\f[R], starting at index
\f[V]imm\f[R] (for a positive immediate) of the concatenated vector.
Elements in the result vector beyond \f[V]evl2\f[R] are \f[V]undef\f[R].
If \f[V]imm\f[R] is negative the starting index is \f[V]evl1 + imm\f[R].
The result vector of active vector length \f[V]evl2\f[R] contains
\f[V]evl1 - imm\f[R] (\f[V]-imm\f[R] for negative \f[V]imm\f[R])
elements from indices \f[V][imm..evl1 - 1]\f[R]
(\f[V][evl1 + imm..evl1 -1]\f[R] for negative \f[V]imm\f[R]) of
\f[V]vec1\f[R] followed by the first \f[V]evl2 - (evl1 - imm)\f[R]
(\f[V]evl2 + imm\f[R] for negative \f[V]imm\f[R]) elements of
\f[V]vec2\f[R].
If \f[V]evl1 - imm\f[R] (\f[V]-imm\f[R]) >= \f[V]evl2\f[R], only the
first \f[V]evl2\f[R] elements are considered and the remaining are
\f[V]undef\f[R].
The lanes in the result vector disabled by \f[V]mask\f[R] are
\f[V]undef\f[R].
.SS Examples:
.IP
.nf
\f[C]
llvm.experimental.vp.splice(<A,B,C,D>, <E,F,G,H>, 1, 2, 3)  ==> <B, E, F, undef> ; index
llvm.experimental.vp.splice(<A,B,C,D>, <E,F,G,H>, -2, 3, 2) ==> <B, C, undef, undef> ; trailing elements
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.load\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <4 x float> \[at]llvm.vp.load.v4f32.p0v4f32(<4 x float>* %ptr, <4 x i1> %mask, i32 %evl)
declare <vscale x 2 x i16> \[at]llvm.vp.load.nxv2i16.p0nxv2i16(<vscale x 2 x i16>* %ptr, <vscale x 2 x i1> %mask, i32 %evl)
declare <8 x float> \[at]llvm.vp.load.v8f32.p1v8f32(<8 x float> addrspace(1)* %ptr, <8 x i1> %mask, i32 %evl)
declare <vscale x 1 x i64> \[at]llvm.vp.load.nxv1i64.p6nxv1i64(<vscale x 1 x i64> addrspace(6)* %ptr, <vscale x 1 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.load.*\f[R]\[aq] intrinsic is the vector length
predicated version of the \f[V]llvm.masked.load <int_mload>\f[R]
intrinsic.
.SS Arguments:
.PP
The first operand is the base pointer for the load.
The second operand is a vector of boolean values with the same number of
elements as the return type.
The third is the explicit vector length of the operation.
The return type and underlying type of the base pointer are the same
vector types.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.load\f[R]\[aq] intrinsic reads a vector from
memory in the same way as the \[aq]\f[V]llvm.masked.load\f[R]\[aq]
intrinsic, where the mask is taken from the combination of the
\[aq]\f[V]mask\f[R]\[aq] and \[aq]\f[V]evl\f[R]\[aq] operands in the
usual VP way.
Certain \[aq]\f[V]llvm.masked.load\f[R]\[aq] operands do not have
corresponding operands in \[aq]\f[V]llvm.vp.load\f[R]\[aq]: the
\[aq]\f[V]passthru\f[R]\[aq] operand is implicitly \f[V]undef\f[R]; the
\[aq]\f[V]alignment\f[R]\[aq] operand is taken as the \f[V]align\f[R]
parameter attribute, if provided.
The default alignment is taken as the ABI alignment of the return type
as specified by the \f[V]datalayout string<langref_datalayout>\f[R].
.SS Examples:
.IP
.nf
\f[C]
%r = call <8 x i8> \[at]llvm.vp.load.v8i8.p0v8i8(<8 x i8>* align 2 %ptr, <8 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%also.r = call <8 x i8> \[at]llvm.masked.load.v8i8.p0v8i8(<8 x i8>* %ptr, i32 2, <8 x i1> %mask, <8 x i8> undef)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.store\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare void \[at]llvm.vp.store.v4f32.p0v4f32(<4 x float> %val, <4 x float>* %ptr, <4 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.store.nxv2i16.p0nxv2i16(<vscale x 2 x i16> %val, <vscale x 2 x i16>* %ptr, <vscale x 2 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.store.v8f32.p1v8f32(<8 x float> %val, <8 x float> addrspace(1)* %ptr, <8 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.store.nxv1i64.p6nxv1i64(<vscale x 1 x i64> %val, <vscale x 1 x i64> addrspace(6)* %ptr, <vscale x 1 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.store.*\f[R]\[aq] intrinsic is the vector length
predicated version of the \f[V]llvm.masked.store <int_mstore>\f[R]
intrinsic.
.SS Arguments:
.PP
The first operand is the vector value to be written to memory.
The second operand is the base pointer for the store.
It has the same underlying type as the value operand.
The third operand is a vector of boolean values with the same number of
elements as the return type.
The fourth is the explicit vector length of the operation.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the second operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.store\f[R]\[aq] intrinsic reads a vector from
memory in the same way as the \[aq]\f[V]llvm.masked.store\f[R]\[aq]
intrinsic, where the mask is taken from the combination of the
\[aq]\f[V]mask\f[R]\[aq] and \[aq]\f[V]evl\f[R]\[aq] operands in the
usual VP way.
The alignment of the operation (corresponding to the
\[aq]\f[V]alignment\f[R]\[aq] operand of
\[aq]\f[V]llvm.masked.store\f[R]\[aq]) is specified by the
\f[V]align\f[R] parameter attribute (see above).
If it is not provided then the ABI alignment of the type of the
\[aq]\f[V]value\f[R]\[aq] operand as specified by the \f[V]datalayout
string<langref_datalayout>\f[R] is used instead.
.SS Examples:
.IP
.nf
\f[C]
call void \[at]llvm.vp.store.v8i8.p0v8i8(<8 x i8> %val, <8 x i8>* align 4 %ptr, <8 x i1> %mask, i32 %evl)
;; For all lanes below %evl, the call above is lane-wise equivalent to the call below.

call void \[at]llvm.masked.store.v8i8.p0v8i8(<8 x i8> %val, <8 x i8>* %ptr, i32 4, <8 x i1> %mask)
\f[R]
.fi
.SS \[aq]\f[V]llvm.experimental.vp.strided.load\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <4 x float> \[at]llvm.experimental.vp.strided.load.v4f32.i64(float* %ptr, i64 %stride, <4 x i1> %mask, i32 %evl)
declare <vscale x 2 x i16> \[at]llvm.experimental.vp.strided.load.nxv2i16.i64(i16* %ptr, i64 %stride, <vscale x 2 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.vp.strided.load\f[R]\[aq] intrinsic
loads, into a vector, scalar values from memory locations evenly spaced
apart by \[aq]\f[V]stride\f[R]\[aq] number of bytes, starting from
\[aq]\f[V]ptr\f[R]\[aq].
.SS Arguments:
.PP
The first operand is the base pointer for the load.
The second operand is the stride value expressed in bytes.
The third operand is a vector of boolean values with the same number of
elements as the return type.
The fourth is the explicit vector length of the operation.
The base pointer underlying type matches the type of the scalar elements
of the return operand.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.experimental.vp.strided.load\f[R]\[aq] intrinsic
loads, into a vector, multiple scalar values from memory in the same way
as the \f[V]llvm.vp.gather <int_vp_gather>\f[R] intrinsic, where the
vector of pointers is in the form:
.RS
.PP
\f[V]%ptrs = <%ptr, %ptr + %stride, %ptr + 2 * %stride, ... >\f[R],
.RE
.PP
with \[aq]\f[V]ptr\f[R]\[aq] previously casted to a pointer
\[aq]\f[V]i8\f[R]\[aq], \[aq]\f[V]stride\f[R]\[aq] always interpreted as
a signed integer and all arithmetic occurring in the pointer type.
.SS Examples:
.IP
.nf
\f[C]
%r = call <8 x i64> \[at]llvm.experimental.vp.strided.load.v8i64.i64(i64* %ptr, i64 %stride, <8 x i64> %mask, i32 %evl)
;; The operation can also be expressed like this:

%addr = bitcast i64* %ptr to i8*
;; Create a vector of pointers %addrs in the form:
;; %addrs = <%addr, %addr + %stride, %addr + 2 * %stride, ...>
%ptrs = bitcast <8 x i8* > %addrs to <8 x i64* >
%also.r = call <8 x i64> \[at]llvm.vp.gather.v8i64.v8p0i64(<8 x i64* > %ptrs, <8 x i64> %mask, i32 %evl)
\f[R]
.fi
.SS \[aq]\f[V]llvm.experimental.vp.strided.store\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare void \[at]llvm.experimental.vp.strided.store.v4f32.i64(<4 x float> %val, float* %ptr, i64 %stride, <4 x i1> %mask, i32 %evl)
declare void \[at]llvm.experimental.vp.strided.store.nxv2i16.i64(<vscale x 2 x i16> %val, i16* %ptr, i64 %stride, <vscale x 2 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]\[at]llvm.experimental.vp.strided.store\f[R]\[aq]
intrinsic stores the elements of \[aq]\f[V]val\f[R]\[aq] into memory
locations evenly spaced apart by \[aq]\f[V]stride\f[R]\[aq] number of
bytes, starting from \[aq]\f[V]ptr\f[R]\[aq].
.SS Arguments:
.PP
The first operand is the vector value to be written to memory.
The second operand is the base pointer for the store.
Its underlying type matches the scalar element type of the value
operand.
The third operand is the stride value expressed in bytes.
The fourth operand is a vector of boolean values with the same number of
elements as the return type.
The fifth is the explicit vector length of the operation.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the second operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.experimental.vp.strided.store\f[R]\[aq] intrinsic
stores the elements of \[aq]\f[V]val\f[R]\[aq] in the same way as the
\f[V]llvm.vp.scatter <int_vp_scatter>\f[R] intrinsic, where the vector
of pointers is in the form:
.RS
.PP
\f[V]%ptrs = <%ptr, %ptr + %stride, %ptr + 2 * %stride, ... >\f[R],
.RE
.PP
with \[aq]\f[V]ptr\f[R]\[aq] previously casted to a pointer
\[aq]\f[V]i8\f[R]\[aq], \[aq]\f[V]stride\f[R]\[aq] always interpreted as
a signed integer and all arithmetic occurring in the pointer type.
.SS Examples:
.IP
.nf
\f[C]
call void \[at]llvm.experimental.vp.strided.store.v8i64.i64(<8 x i64> %val, i64* %ptr, i64 %stride, <8 x i1> %mask, i32 %evl)
;; The operation can also be expressed like this:

%addr = bitcast i64* %ptr to i8*
;; Create a vector of pointers %addrs in the form:
;; %addrs = <%addr, %addr + %stride, %addr + 2 * %stride, ...>
%ptrs = bitcast <8 x i8* > %addrs to <8 x i64* >
call void \[at]llvm.vp.scatter.v8i64.v8p0i64(<8 x i64> %val, <8 x i64*> %ptrs, <8 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.gather\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <4 x double> \[at]llvm.vp.gather.v4f64.v4p0f64(<4 x double*> %ptrs, <4 x i1> %mask, i32 %evl)
declare <vscale x 2 x i8> \[at]llvm.vp.gather.nxv2i8.nxv2p0i8(<vscale x 2 x i8*> %ptrs, <vscale x 2 x i1> %mask, i32 %evl)
declare <2 x float> \[at]llvm.vp.gather.v2f32.v2p2f32(<2 x float addrspace(2)*> %ptrs, <2 x i1> %mask, i32 %evl)
declare <vscale x 4 x i32> \[at]llvm.vp.gather.nxv4i32.nxv4p4i32(<vscale x 4 x i32 addrspace(4)*> %ptrs, <vscale x 4 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.gather.*\f[R]\[aq] intrinsic is the vector length
predicated version of the \f[V]llvm.masked.gather <int_mgather>\f[R]
intrinsic.
.SS Arguments:
.PP
The first operand is a vector of pointers which holds all memory
addresses to read.
The second operand is a vector of boolean values with the same number of
elements as the return type.
The third is the explicit vector length of the operation.
The return type and underlying type of the vector of pointers are the
same vector types.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the first operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.gather\f[R]\[aq] intrinsic reads multiple scalar
values from memory in the same way as the
\[aq]\f[V]llvm.masked.gather\f[R]\[aq] intrinsic, where the mask is
taken from the combination of the \[aq]\f[V]mask\f[R]\[aq] and
\[aq]\f[V]evl\f[R]\[aq] operands in the usual VP way.
Certain \[aq]\f[V]llvm.masked.gather\f[R]\[aq] operands do not have
corresponding operands in \[aq]\f[V]llvm.vp.gather\f[R]\[aq]: the
\[aq]\f[V]passthru\f[R]\[aq] operand is implicitly \f[V]undef\f[R]; the
\[aq]\f[V]alignment\f[R]\[aq] operand is taken as the \f[V]align\f[R]
parameter, if provided.
The default alignment is taken as the ABI alignment of the source
addresses as specified by the
\f[V]datalayout string<langref_datalayout>\f[R].
.SS Examples:
.IP
.nf
\f[C]
%r = call <8 x i8> \[at]llvm.vp.gather.v8i8.v8p0i8(<8 x i8*>  align 8 %ptrs, <8 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%also.r = call <8 x i8> \[at]llvm.masked.gather.v8i8.v8p0i8(<8 x i8*> %ptrs, i32 8, <8 x i1> %mask, <8 x i8> undef)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.scatter\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare void \[at]llvm.vp.scatter.v4f64.v4p0f64(<4 x double> %val, <4 x double*> %ptrs, <4 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.scatter.nxv2i8.nxv2p0i8(<vscale x 2 x i8> %val, <vscale x 2 x i8*> %ptrs, <vscale x 2 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.scatter.v2f32.v2p2f32(<2 x float> %val, <2 x float addrspace(2)*> %ptrs, <2 x i1> %mask, i32 %evl)
declare void \[at]llvm.vp.scatter.nxv4i32.nxv4p4i32(<vscale x 4 x i32> %val, <vscale x 4 x i32 addrspace(4)*> %ptrs, <vscale x 4 x i1> %mask, i32 %evl)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.scatter.*\f[R]\[aq] intrinsic is the vector length
predicated version of the \f[V]llvm.masked.scatter <int_mscatter>\f[R]
intrinsic.
.SS Arguments:
.PP
The first operand is a vector value to be written to memory.
The second operand is a vector of pointers, pointing to where the value
elements should be stored.
The third operand is a vector of boolean values with the same number of
elements as the return type.
The fourth is the explicit vector length of the operation.
.PP
The \f[V]align <attr_align>\f[R] parameter attribute can be provided for
the second operand.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.scatter\f[R]\[aq] intrinsic writes multiple scalar
values to memory in the same way as the
\[aq]\f[V]llvm.masked.scatter\f[R]\[aq] intrinsic, where the mask is
taken from the combination of the \[aq]\f[V]mask\f[R]\[aq] and
\[aq]\f[V]evl\f[R]\[aq] operands in the usual VP way.
The \[aq]\f[V]alignment\f[R]\[aq] operand of the
\[aq]\f[V]llvm.masked.scatter\f[R]\[aq] does not have a corresponding
operand in \[aq]\f[V]llvm.vp.scatter\f[R]\[aq]: it is instead provided
via the optional \f[V]align\f[R] parameter attribute on the
vector-of-pointers operand.
Otherwise it is taken as the ABI alignment of the destination addresses
as specified by the \f[V]datalayout
string<langref_datalayout>\f[R].
.SS Examples:
.IP
.nf
\f[C]
call void \[at]llvm.vp.scatter.v8i8.v8p0i8(<8 x i8> %val, <8 x i8*> align 1 %ptrs, <8 x i1> %mask, i32 %evl)
;; For all lanes below %evl, the call above is lane-wise equivalent to the call below.

call void \[at]llvm.masked.scatter.v8i8.v8p0i8(<8 x i8> %val, <8 x i8*> %ptrs, i32 1, <8 x i1> %mask)
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.trunc.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i16>  \[at]llvm.vp.trunc.v16i16.v16i32 (<16 x i32> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i16>  \[at]llvm.vp.trunc.nxv4i16.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.trunc\f[R]\[aq] intrinsic truncates its first
operand to the return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.trunc\f[R]\[aq] intrinsic takes a value to cast as
its first operand.
The return type is the type to cast the value to.
Both types must be vector of \f[V]integer <t_integer>\f[R] type.
The bit size of the value must be larger than the bit size of the return
type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.trunc\f[R]\[aq] intrinsic truncates the high order
bits in value and converts the remaining bits to return type.
Since the source size must be larger than the destination size,
\[aq]\f[V]llvm.vp.trunc\f[R]\[aq] cannot be a \f[I]no-op cast\f[R].
It will always truncate bits.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i16> \[at]llvm.vp.trunc.v4i16.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = trunc <4 x i32> %a to <4 x i16>
%also.r = select <4 x i1> %mask, <4 x i16> %t, <4 x i16> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.zext.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.zext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.zext\f[R]\[aq] intrinsic zero extends its first
operand to the return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.zext\f[R]\[aq] intrinsic takes a value to cast as
its first operand.
The return type is the type to cast the value to.
Both types must be vectors of \f[V]integer <t_integer>\f[R] type.
The bit size of the value must be smaller than the bit size of the
return type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.zext\f[R]\[aq] intrinsic fill the high order bits
of the value with zero bits until it reaches the size of the return
type.
When zero extending from i1, the result will always be either 0 or 1.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.zext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = zext <4 x i16> %a to <4 x i32>
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.sext.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.sext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.sext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.sext\f[R]\[aq] intrinsic sign extends its first
operand to the return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.sext\f[R]\[aq] intrinsic takes a value to cast as
its first operand.
The return type is the type to cast the value to.
Both types must be vectors of \f[V]integer <t_integer>\f[R] type.
The bit size of the value must be smaller than the bit size of the
return type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.sext\f[R]\[aq] intrinsic performs a sign extension
by copying the sign bit (highest order bit) of the value until it
reaches the size of the return type.
When zero extending from i1, the result will always be either -1 or 0.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.sext.v4i32.v4i16(<4 x i16> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = sext <4 x i16> %a to <4 x i32>
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fptrunc.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.fptrunc.v16f32.v16f64 (<16 x double> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.trunc.nxv4f32.nxv4f64 (<vscale x 4 x double> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.fptrunc\f[R]\[aq] intrinsic truncates its first
operand to the return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.fptrunc\f[R]\[aq] intrinsic takes a value to cast
as its first operand.
The return type is the type to cast the value to.
Both types must be vector of \f[V]floating-point <t_floating>\f[R] type.
The bit size of the value must be larger than the bit size of the return
type.
This implies that \[aq]\f[V]llvm.vp.fptrunc\f[R]\[aq] cannot be used to
make a \f[I]no-op cast\f[R].
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fptrunc\f[R]\[aq] intrinsic casts a
\f[V]value\f[R] from a larger \f[V]floating-point <t_floating>\f[R] type
to a smaller \f[V]floating-point
<t_floating>\f[R] type.
This instruction is assumed to execute in the default
\f[V]floating-point
environment <floatenv>\f[R].
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.fptrunc.v4f32.v4f64(<4 x double> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fptrunc <4 x double> %a to <4 x float>
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fpext.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x double>  \[at]llvm.vp.fpext.v16f64.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x double>  \[at]llvm.vp.fpext.nxv4f64.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.fpext\f[R]\[aq] intrinsic extends its first
operand to the return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.fpext\f[R]\[aq] intrinsic takes a value to cast as
its first operand.
The return type is the type to cast the value to.
Both types must be vector of \f[V]floating-point <t_floating>\f[R] type.
The bit size of the value must be smaller than the bit size of the
return type.
This implies that \[aq]\f[V]llvm.vp.fpext\f[R]\[aq] cannot be used to
make a \f[I]no-op cast\f[R].
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fpext\f[R]\[aq] intrinsic extends the
\f[V]value\f[R] from a smaller \f[V]floating-point <t_floating>\f[R]
type to a larger \f[V]floating-point
<t_floating>\f[R] type.
The \[aq]\f[V]llvm.vp.fpext\f[R]\[aq] cannot be used to make a
\f[I]no-op cast\f[R] because it always changes bits.
Use \f[V]bitcast\f[R] to make a \f[I]no-op cast\f[R] for a
floating-point cast.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x double> \[at]llvm.vp.fpext.v4f64.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fpext <4 x float> %a to <4 x double>
%also.r = select <4 x i1> %mask, <4 x double> %t, <4 x double> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fptoui.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.fptoui.v16i32.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.fptoui.nxv4i32.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.fptoui.v256i64.v256f64 (<256 x double> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.fptoui\f[R]\[aq] intrinsic converts the
\f[V]floating-point
<t_floating>\f[R] operand to the unsigned integer return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.fptoui\f[R]\[aq] intrinsic takes a value to cast
as its first operand.
The value to cast must be a vector of
\f[V]floating-point <t_floating>\f[R] type.
The return type is the type to cast the value to.
The return type must be vector of \f[V]integer <t_integer>\f[R] type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fptoui\f[R]\[aq] intrinsic converts its
\f[V]floating-point
<t_floating>\f[R] operand into the nearest (rounding towards zero)
unsigned integer value where the lane position is below the explicit
vector length and the vector mask is true.
Masked-off lanes are undefined.
On enabled lanes where conversion takes place and the value cannot fit
in the return type, the result on that lane is a
\f[V]poison value <poisonvalues>\f[R].
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.fptoui.v4i32.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fptoui <4 x float> %a to <4 x i32>
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fptosi.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32>  \[at]llvm.vp.fptosi.v16i32.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32>  \[at]llvm.vp.fptosi.nxv4i32.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.fptosi.v256i64.v256f64 (<256 x double> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.fptosi\f[R]\[aq] intrinsic converts the
\f[V]floating-point
<t_floating>\f[R] operand to the signed integer return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.fptosi\f[R]\[aq] intrinsic takes a value to cast
as its first operand.
The value to cast must be a vector of
\f[V]floating-point <t_floating>\f[R] type.
The return type is the type to cast the value to.
The return type must be vector of \f[V]integer <t_integer>\f[R] type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fptosi\f[R]\[aq] intrinsic converts its
\f[V]floating-point
<t_floating>\f[R] operand into the nearest (rounding towards zero)
signed integer value where the lane position is below the explicit
vector length and the vector mask is true.
Masked-off lanes are undefined.
On enabled lanes where conversion takes place and the value cannot fit
in the return type, the result on that lane is a
\f[V]poison value <poisonvalues>\f[R].
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32> \[at]llvm.vp.fptosi.v4i32.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fptosi <4 x float> %a to <4 x i32>
%also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.uitofp.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.uitofp.v16f32.v16i32 (<16 x i32> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.uitofp.nxv4f32.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.uitofp.v256f64.v256i64 (<256 x i64> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.uitofp\f[R]\[aq] intrinsic converts its unsigned
integer operand to the \f[V]floating-point <t_floating>\f[R] return
type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.uitofp\f[R]\[aq] intrinsic takes a value to cast
as its first operand.
The value to cast must be vector of \f[V]integer <t_integer>\f[R] type.
The return type is the type to cast the value to.
The return type must be a vector of
\f[V]floating-point <t_floating>\f[R] type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.uitofp\f[R]\[aq] intrinsic interprets its first
operand as an unsigned integer quantity and converts it to the
corresponding floating-point value.
If the value cannot be exactly represented, it is rounded using the
default rounding mode.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.uitofp.v4f32.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = uitofp <4 x i32> %a to <4 x float>
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.sitofp.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.vp.sitofp.v16f32.v16i32 (<16 x i32> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x float>  \[at]llvm.vp.sitofp.nxv4f32.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x double>  \[at]llvm.vp.sitofp.v256f64.v256i64 (<256 x i64> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.sitofp\f[R]\[aq] intrinsic converts its signed
integer operand to the \f[V]floating-point <t_floating>\f[R] return
type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.sitofp\f[R]\[aq] intrinsic takes a value to cast
as its first operand.
The value to cast must be vector of \f[V]integer <t_integer>\f[R] type.
The return type is the type to cast the value to.
The return type must be a vector of
\f[V]floating-point <t_floating>\f[R] type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.sitofp\f[R]\[aq] intrinsic interprets its first
operand as a signed integer quantity and converts it to the
corresponding floating-point value.
If the value cannot be exactly represented, it is rounded using the
default rounding mode.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x float> \[at]llvm.vp.sitofp.v4f32.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = sitofp <4 x i32> %a to <4 x float>
%also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.ptrtoint.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i8>  \[at]llvm.vp.ptrtoint.v16i8.v16p0i32 (<16 x i32*> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i8>  \[at]llvm.vp.ptrtoint.nxv4i8.nxv4p0i32 (<vscale x 4 x i32*> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i64>  \[at]llvm.vp.ptrtoint.v16i64.v16p0i32 (<256 x i32*> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.ptrtoint\f[R]\[aq] intrinsic converts its pointer
to the integer return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.ptrtoint\f[R]\[aq] intrinsic takes a value to cast
as its first operand , which must be a vector of pointers, and a type to
cast it to return type, which must be a vector of
\f[V]integer <t_integer>\f[R] type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.ptrtoint\f[R]\[aq] intrinsic converts value to
return type by interpreting the pointer value as an integer and either
truncating or zero extending that value to the size of the integer type.
If \f[V]value\f[R] is smaller than return type, then a zero extension is
done.
If \f[V]value\f[R] is larger than return type, then a truncation is
done.
If they are the same size, then nothing is done (\f[I]no-op cast\f[R])
other than a type change.
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i8> \[at]llvm.vp.ptrtoint.v4i8.v4p0i32(<4 x i32*> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = ptrtoint <4 x i32*> %a to <4 x i8>
%also.r = select <4 x i1> %mask, <4 x i8> %t, <4 x i8> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.inttoptr.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i32*>  \[at]llvm.vp.inttoptr.v16p0i32.v16i32 (<16 x i32> <op>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i32*>  \[at]llvm.vp.inttoptr.nxv4p0i32.nxv4i32 (<vscale x 4 x i32> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i32*>  \[at]llvm.vp.inttoptr.v256p0i32.v256i32 (<256 x i32> <op>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.inttoptr\f[R]\[aq] intrinsic converts its integer
value to the point return type.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.inttoptr\f[R]\[aq] intrinsic takes a value to cast
as its first operand , which must be a vector of
\f[V]integer <t_integer>\f[R] type, and a type to cast it to return
type, which must be a vector of pointers type.
The second operand is the vector mask.
The return type, the value to cast, and the vector mask have the same
number of elements.
The third operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.inttoptr\f[R]\[aq] intrinsic converts
\f[V]value\f[R] to return type by applying either a zero extension or a
truncation depending on the size of the integer \f[V]value\f[R].
If \f[V]value\f[R] is larger than the size of a pointer, then a
truncation is done.
If \f[V]value\f[R] is smaller than the size of a pointer, then a zero
extension is done.
If they are the same size, nothing is done (\f[I]no-op cast\f[R]).
The conversion is performed on lane positions below the explicit vector
length and where the vector mask is true.
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i32*> \[at]llvm.vp.inttoptr.v4p0i32.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = inttoptr <4 x i32> %a to <4 x i32*>
%also.r = select <4 x i1> %mask, <4 x i32*> %t, <4 x i32*> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.fcmp.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <16 x i1> \[at]llvm.vp.fcmp.v16f32(<16 x float> <left_op>, <16 x float> <right_op>, metadata <condition code>, <16 x i1> <mask>, i32 <vector_length>)
declare <vscale x 4 x i1> \[at]llvm.vp.fcmp.nxv4f32(<vscale x 4 x float> <left_op>, <vscale x 4 x float> <right_op>, metadata <condition code>, <vscale x 4 x i1> <mask>, i32 <vector_length>)
declare <256 x i1> \[at]llvm.vp.fcmp.v256f64(<256 x double> <left_op>, <256 x double> <right_op>, metadata <condition code>, <256 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.fcmp\f[R]\[aq] intrinsic returns a vector of
boolean values based on the comparison of its operands.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.fcmp\f[R]\[aq] intrinsic takes the two values to
compare as its first and second operands.
These two values must be vectors of \f[V]floating-point
<t_floating>\f[R] types.
The return type is the result of the comparison.
The return type must be a vector of \f[V]i1 <t_integer>\f[R] type.
The fourth operand is the vector mask.
The return type, the values to compare, and the vector mask have the
same number of elements.
The third operand is the condition code indicating the kind of
comparison to perform.
It must be a metadata string with \f[V]one of the
supported floating-point condition code values <fcmp_md_cc>\f[R].
The fifth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.fcmp\f[R]\[aq] compares its first two operands
according to the condition code given as the third operand.
The operands are compared element by element on each enabled lane, where
the the semantics of the comparison are defined
\f[V]according to the condition code <fcmp_md_cc_sem>\f[R].
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i1> \[at]llvm.vp.fcmp.v4f32(<4 x float> %a, <4 x float> %b, metadata !\[dq]oeq\[dq], <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = fcmp oeq <4 x float> %a, %b
%also.r = select <4 x i1> %mask, <4 x i1> %t, <4 x i1> undef
\f[R]
.fi
.SS \[aq]\f[V]llvm.vp.icmp.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
.IP
.nf
\f[C]
declare <32 x i1> \[at]llvm.vp.icmp.v32i32(<32 x i32> <left_op>, <32 x i32> <right_op>, metadata <condition code>, <32 x i1> <mask>, i32 <vector_length>)
declare <vscale x 2 x i1> \[at]llvm.vp.icmp.nxv2i32(<vscale x 2 x i32> <left_op>, <vscale x 2 x i32> <right_op>, metadata <condition code>, <vscale x 2 x i1> <mask>, i32 <vector_length>)
declare <128 x i1> \[at]llvm.vp.icmp.v128i8(<128 x i8> <left_op>, <128 x i8> <right_op>, metadata <condition code>, <128 x i1> <mask>, i32 <vector_length>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.vp.icmp\f[R]\[aq] intrinsic returns a vector of
boolean values based on the comparison of its operands.
The operation has a mask and an explicit vector length parameter.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.vp.icmp\f[R]\[aq] intrinsic takes the two values to
compare as its first and second operands.
These two values must be vectors of \f[V]integer
<t_integer>\f[R] types.
The return type is the result of the comparison.
The return type must be a vector of \f[V]i1 <t_integer>\f[R] type.
The fourth operand is the vector mask.
The return type, the values to compare, and the vector mask have the
same number of elements.
The third operand is the condition code indicating the kind of
comparison to perform.
It must be a metadata string with \f[V]one of the
supported integer condition code values <icmp_md_cc>\f[R].
The fifth operand is the explicit vector length of the operation.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.vp.icmp\f[R]\[aq] compares its first two operands
according to the condition code given as the third operand.
The operands are compared element by element on each enabled lane, where
the the semantics of the comparison are defined
\f[V]according to the condition code <icmp_md_cc_sem>\f[R].
Masked-off lanes are undefined.
.SS Examples:
.IP
.nf
\f[C]
%r = call <4 x i1> \[at]llvm.vp.icmp.v4i32(<4 x i32> %a, <4 x i32> %b, metadata !\[dq]ne\[dq], <4 x i1> %mask, i32 %evl)
;; For all lanes below %evl, %r is lane-wise equivalent to %also.r

%t = icmp ne <4 x i32> %a, %b
%also.r = select <4 x i1> %mask, <4 x i1> %t, <4 x i1> undef
\f[R]
.fi
.SS Masked Vector Load and Store Intrinsics
.PP
LLVM provides intrinsics for predicated vector load and store
operations.
The predicate is specified by a mask operand, which holds one bit per
vector element, switching the associated vector lane on or off.
The memory addresses corresponding to the \[dq]off\[dq] lanes are not
accessed.
When all bits of the mask are on, the intrinsic is identical to a
regular vector load or store.
When all bits are off, no memory is accessed.
.SS \[aq]\f[V]llvm.masked.load.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
The loaded data is a vector of any integer, floating-point or pointer
data type.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.masked.load.v16f32.p0v16f32 (<16 x float>* <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>)
declare <2 x double>  \[at]llvm.masked.load.v2f64.p0v2f64  (<2 x double>* <ptr>, i32 <alignment>, <2 x i1>  <mask>, <2 x double> <passthru>)
;; The data is a vector of pointers to double
declare <8 x double*> \[at]llvm.masked.load.v8p0f64.p0v8p0f64    (<8 x double*>* <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x double*> <passthru>)
;; The data is a vector of function pointers
declare <8 x i32 ()*> \[at]llvm.masked.load.v8p0f_i32f.p0v8p0f_i32f (<8 x i32 ()*>* <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x i32 ()*> <passthru>)
\f[R]
.fi
.SS Overview:
.PP
Reads a vector from memory according to the provided mask.
The mask holds a bit for each vector lane, and is used to prevent memory
accesses to the masked-off lanes.
The masked-off lanes in the result vector are taken from the
corresponding lanes of the \[aq]\f[V]passthru\f[R]\[aq] operand.
.SS Arguments:
.PP
The first operand is the base pointer for the load.
The second operand is the alignment of the source location.
It must be a power of two constant integer value.
The third operand, mask, is a vector of boolean values with the same
number of elements as the return type.
The fourth is a pass-through value that is used to fill the masked-off
lanes of the result.
The return type, underlying type of the base pointer and the type of the
\[aq]\f[V]passthru\f[R]\[aq] operand are the same vector types.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.load\f[R]\[aq] intrinsic is designed for
conditional reading of selected vector elements in a single IR
operation.
It is useful for targets that support vector masked loads and allows
vectorizing predicated basic blocks on these targets.
Other targets may support this intrinsic differently, for example by
lowering it into a sequence of branches that guard scalar load
operations.
The result of this operation is equivalent to a regular vector load
instruction followed by a \[aq]select\[aq] between the loaded and the
passthru values, predicated on the same mask.
However, using this intrinsic prevents exceptions on memory access to
masked-off lanes.
.IP
.nf
\f[C]
%res = call <16 x float> \[at]llvm.masked.load.v16f32.p0v16f32 (<16 x float>* %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru)

;; The result of the two following instructions is identical aside from potential memory access exception
%loadlal = load <16 x float>, <16 x float>* %ptr, align 4
%res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru
\f[R]
.fi
.SS \[aq]\f[V]llvm.masked.store.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
The data stored in memory is a vector of any integer, floating-point or
pointer data type.
.IP
.nf
\f[C]
declare void \[at]llvm.masked.store.v8i32.p0v8i32  (<8  x i32>   <value>, <8  x i32>*   <ptr>, i32 <alignment>,  <8  x i1> <mask>)
declare void \[at]llvm.masked.store.v16f32.p0v16f32 (<16 x float> <value>, <16 x float>* <ptr>, i32 <alignment>,  <16 x i1> <mask>)
;; The data is a vector of pointers to double
declare void \[at]llvm.masked.store.v8p0f64.p0v8p0f64    (<8 x double*> <value>, <8 x double*>* <ptr>, i32 <alignment>, <8 x i1> <mask>)
;; The data is a vector of function pointers
declare void \[at]llvm.masked.store.v4p0f_i32f.p0v4p0f_i32f (<4 x i32 ()*> <value>, <4 x i32 ()*>* <ptr>, i32 <alignment>, <4 x i1> <mask>)
\f[R]
.fi
.SS Overview:
.PP
Writes a vector to memory according to the provided mask.
The mask holds a bit for each vector lane, and is used to prevent memory
accesses to the masked-off lanes.
.SS Arguments:
.PP
The first operand is the vector value to be written to memory.
The second operand is the base pointer for the store, it has the same
underlying type as the value operand.
The third operand is the alignment of the destination location.
It must be a power of two constant integer value.
The fourth operand, mask, is a vector of boolean values.
The types of the mask and the value operand must have the same number of
vector elements.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.store\f[R]\[aq] intrinsics is designed for
conditional writing of selected vector elements in a single IR
operation.
It is useful for targets that support vector masked store and allows
vectorizing predicated basic blocks on these targets.
Other targets may support this intrinsic differently, for example by
lowering it into a sequence of branches that guard scalar store
operations.
The result of this operation is equivalent to a load-modify-store
sequence.
However, using this intrinsic prevents exceptions and data races on
memory access to masked-off lanes.
.IP
.nf
\f[C]
call void \[at]llvm.masked.store.v16f32.p0v16f32(<16 x float> %value, <16 x float>* %ptr, i32 4,  <16 x i1> %mask)

;; The result of the following instructions is identical aside from potential data races and memory access exceptions
%oldval = load <16 x float>, <16 x float>* %ptr, align 4
%res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval
store <16 x float> %res, <16 x float>* %ptr, align 4
\f[R]
.fi
.SS Masked Vector Gather and Scatter Intrinsics
.PP
LLVM provides intrinsics for vector gather and scatter operations.
They are similar to
\f[V]Masked Vector Load and Store <int_mload_mstore>\f[R], except they
are designed for arbitrary memory accesses, rather than sequential
memory accesses.
Gather and scatter also employ a mask operand, which holds one bit per
vector element, switching the associated vector lane on or off.
The memory addresses corresponding to the \[dq]off\[dq] lanes are not
accessed.
When all bits are off, no memory is accessed.
.SS \[aq]\f[V]llvm.masked.gather.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
The loaded data are multiple scalar values of any integer,
floating-point or pointer data type gathered together into one vector.
.IP
.nf
\f[C]
declare <16 x float> \[at]llvm.masked.gather.v16f32.v16p0f32   (<16 x float*> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>)
declare <2 x double> \[at]llvm.masked.gather.v2f64.v2p1f64     (<2 x double addrspace(1)*> <ptrs>, i32 <alignment>, <2 x i1>  <mask>, <2 x double> <passthru>)
declare <8 x float*> \[at]llvm.masked.gather.v8p0f32.v8p0p0f32 (<8 x float**> <ptrs>, i32 <alignment>, <8 x i1>  <mask>, <8 x float*> <passthru>)
\f[R]
.fi
.SS Overview:
.PP
Reads scalar values from arbitrary memory locations and gathers them
into one vector.
The memory locations are provided in the vector of pointers
\[aq]\f[V]ptrs\f[R]\[aq].
The memory is accessed according to the provided mask.
The mask holds a bit for each vector lane, and is used to prevent memory
accesses to the masked-off lanes.
The masked-off lanes in the result vector are taken from the
corresponding lanes of the \[aq]\f[V]passthru\f[R]\[aq] operand.
.SS Arguments:
.PP
The first operand is a vector of pointers which holds all memory
addresses to read.
The second operand is an alignment of the source addresses.
It must be 0 or a power of two constant integer value.
The third operand, mask, is a vector of boolean values with the same
number of elements as the return type.
The fourth is a pass-through value that is used to fill the masked-off
lanes of the result.
The return type, underlying type of the vector of pointers and the type
of the \[aq]\f[V]passthru\f[R]\[aq] operand are the same vector types.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.gather\f[R]\[aq] intrinsic is designed for
conditional reading of multiple scalar values from arbitrary memory
locations in a single IR operation.
It is useful for targets that support vector masked gathers and allows
vectorizing basic blocks with data and control divergence.
Other targets may support this intrinsic differently, for example by
lowering it into a sequence of scalar load operations.
The semantics of this operation are equivalent to a sequence of
conditional scalar loads with subsequent gathering all loaded values
into a single vector.
The mask restricts memory access to certain lanes and facilitates
vectorization of predicated basic blocks.
.IP
.nf
\f[C]
%res = call <4 x double> \[at]llvm.masked.gather.v4f64.v4p0f64 (<4 x double*> %ptrs, i32 8, <4 x i1> <i1 true, i1 true, i1 true, i1 true>, <4 x double> undef)

;; The gather with all-true mask is equivalent to the following instruction sequence
%ptr0 = extractelement <4 x double*> %ptrs, i32 0
%ptr1 = extractelement <4 x double*> %ptrs, i32 1
%ptr2 = extractelement <4 x double*> %ptrs, i32 2
%ptr3 = extractelement <4 x double*> %ptrs, i32 3

%val0 = load double, double* %ptr0, align 8
%val1 = load double, double* %ptr1, align 8
%val2 = load double, double* %ptr2, align 8
%val3 = load double, double* %ptr3, align 8

%vec0    = insertelement <4 x double>undef, %val0, 0
%vec01   = insertelement <4 x double>%vec0, %val1, 1
%vec012  = insertelement <4 x double>%vec01, %val2, 2
%vec0123 = insertelement <4 x double>%vec012, %val3, 3
\f[R]
.fi
.SS \[aq]\f[V]llvm.masked.scatter.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
The data stored in memory is a vector of any integer, floating-point or
pointer data type.
Each vector element is stored in an arbitrary memory address.
Scatter with overlapping addresses is guaranteed to be ordered from
least-significant to most-significant element.
.IP
.nf
\f[C]
declare void \[at]llvm.masked.scatter.v8i32.v8p0i32     (<8 x i32>     <value>, <8 x i32*>     <ptrs>, i32 <alignment>, <8 x i1>  <mask>)
declare void \[at]llvm.masked.scatter.v16f32.v16p1f32   (<16 x float>  <value>, <16 x float addrspace(1)*>  <ptrs>, i32 <alignment>, <16 x i1> <mask>)
declare void \[at]llvm.masked.scatter.v4p0f64.v4p0p0f64 (<4 x double*> <value>, <4 x double**> <ptrs>, i32 <alignment>, <4 x i1>  <mask>)
\f[R]
.fi
.SS Overview:
.PP
Writes each element from the value vector to the corresponding memory
address.
The memory addresses are represented as a vector of pointers.
Writing is done according to the provided mask.
The mask holds a bit for each vector lane, and is used to prevent memory
accesses to the masked-off lanes.
.SS Arguments:
.PP
The first operand is a vector value to be written to memory.
The second operand is a vector of pointers, pointing to where the value
elements should be stored.
It has the same underlying type as the value operand.
The third operand is an alignment of the destination addresses.
It must be 0 or a power of two constant integer value.
The fourth operand, mask, is a vector of boolean values.
The types of the mask and the value operand must have the same number of
vector elements.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.scatter\f[R]\[aq] intrinsics is designed for
writing selected vector elements to arbitrary memory addresses in a
single IR operation.
The operation may be conditional, when not all bits in the mask are
switched on.
It is useful for targets that support vector masked scatter and allows
vectorizing basic blocks with data and control divergence.
Other targets may support this intrinsic differently, for example by
lowering it into a sequence of branches that guard scalar store
operations.
.IP
.nf
\f[C]
;; This instruction unconditionally stores data vector in multiple addresses
call \[at]llvm.masked.scatter.v8i32.v8p0i32 (<8 x i32> %value, <8 x i32*> %ptrs, i32 4,  <8 x i1>  <true, true, .. true>)

;; It is equivalent to a list of scalar stores
%val0 = extractelement <8 x i32> %value, i32 0
%val1 = extractelement <8 x i32> %value, i32 1
\&..
%val7 = extractelement <8 x i32> %value, i32 7
%ptr0 = extractelement <8 x i32*> %ptrs, i32 0
%ptr1 = extractelement <8 x i32*> %ptrs, i32 1
\&..
%ptr7 = extractelement <8 x i32*> %ptrs, i32 7
;; Note: the order of the following stores is important when they overlap:
store i32 %val0, i32* %ptr0, align 4
store i32 %val1, i32* %ptr1, align 4
\&..
store i32 %val7, i32* %ptr7, align 4
\f[R]
.fi
.SS Masked Vector Expanding Load and Compressing Store Intrinsics
.PP
LLVM provides intrinsics for expanding load and compressing store
operations.
Data selected from a vector according to a mask is stored in consecutive
memory addresses (compressed store), and vice-versa (expanding load).
These operations effective map to \[dq]if (cond.i) a[j++] = v.i\[dq] and
\[dq]if (cond.i) v.i = a[j++]\[dq] patterns, respectively.
Note that when the mask starts with \[aq]1\[aq] bits followed by
\[aq]0\[aq] bits, these operations are identical to
\f[V]llvm.masked.store <int_mstore>\f[R] and
\f[V]llvm.masked.load <int_mload>\f[R].
.SS \[aq]\f[V]llvm.masked.expandload.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
Several values of integer, floating point or pointer data type are
loaded from consecutive memory addresses and stored into the elements of
a vector according to the mask.
.IP
.nf
\f[C]
declare <16 x float>  \[at]llvm.masked.expandload.v16f32 (float* <ptr>, <16 x i1> <mask>, <16 x float> <passthru>)
declare <2 x i64>     \[at]llvm.masked.expandload.v2i64 (i64* <ptr>, <2 x i1>  <mask>, <2 x i64> <passthru>)
\f[R]
.fi
.SS Overview:
.PP
Reads a number of scalar values sequentially from memory location
provided in \[aq]\f[V]ptr\f[R]\[aq] and spreads them in a vector.
The \[aq]\f[V]mask\f[R]\[aq] holds a bit for each vector lane.
The number of elements read from memory is equal to the number of
\[aq]1\[aq] bits in the mask.
The loaded elements are positioned in the destination vector according
to the sequence of \[aq]1\[aq] and \[aq]0\[aq] bits in the mask.
E.g., if the mask vector is \[aq]10010001\[aq], \[dq]expandload\[dq]
reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them
in lanes 0, 3 and 7 accordingly.
The masked-off lanes are filled by elements from the corresponding lanes
of the \[aq]\f[V]passthru\f[R]\[aq] operand.
.SS Arguments:
.PP
The first operand is the base pointer for the load.
It has the same underlying type as the element of the returned vector.
The second operand, mask, is a vector of boolean values with the same
number of elements as the return type.
The third is a pass-through value that is used to fill the masked-off
lanes of the result.
The return type and the type of the \[aq]\f[V]passthru\f[R]\[aq] operand
have the same vector type.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.expandload\f[R]\[aq] intrinsic is designed for
reading multiple scalar values from adjacent memory addresses into
possibly non-adjacent vector lanes.
It is useful for targets that support vector expanding loads and allows
vectorizing loop with cross-iteration dependency like in the following
example:
.IP
.nf
\f[C]
// In this loop we load from B and spread the elements into array A.
double *A, B; int *C;
for (int i = 0; i < size; ++i) {
  if (C[i] != 0)
    A[i] = B[j++];
}
\f[R]
.fi
.IP
.nf
\f[C]
; Load several elements from array B and expand them in a vector.
; The number of loaded elements is equal to the number of \[aq]1\[aq] elements in the Mask.
%Tmp = call <8 x double> \[at]llvm.masked.expandload.v8f64(double* %Bptr, <8 x i1> %Mask, <8 x double> undef)
; Store the result in A
call void \[at]llvm.masked.store.v8f64.p0v8f64(<8 x double> %Tmp, <8 x double>* %Aptr, i32 8, <8 x i1> %Mask)

; %Bptr should be increased on each iteration according to the number of \[aq]1\[aq] elements in the Mask.
%MaskI = bitcast <8 x i1> %Mask to i8
%MaskIPopcnt = call i8 \[at]llvm.ctpop.i8(i8 %MaskI)
%MaskI64 = zext i8 %MaskIPopcnt to i64
%BNextInd = add i64 %BInd, %MaskI64
\f[R]
.fi
.PP
Other targets may support this intrinsic differently, for example, by
lowering it into a sequence of conditional scalar load operations and
shuffles.
If all mask elements are \[aq]1\[aq], the intrinsic behavior is
equivalent to the regular unmasked vector load.
.SS \[aq]\f[V]llvm.masked.compressstore.*\f[R]\[aq] Intrinsics
.SS Syntax:
.PP
This is an overloaded intrinsic.
A number of scalar values of integer, floating point or pointer data
type are collected from an input vector and stored into adjacent memory
addresses.
A mask defines which elements to collect from the vector.
.IP
.nf
\f[C]
declare void \[at]llvm.masked.compressstore.v8i32  (<8  x i32>   <value>, i32*   <ptr>, <8  x i1> <mask>)
declare void \[at]llvm.masked.compressstore.v16f32 (<16 x float> <value>, float* <ptr>, <16 x i1> <mask>)
\f[R]
.fi
.SS Overview:
.PP
Selects elements from input vector \[aq]\f[V]value\f[R]\[aq] according
to the \[aq]\f[V]mask\f[R]\[aq].
All selected elements are written into adjacent memory addresses
starting at address \[aq]ptr\[aq], from lower to higher.
The mask holds a bit for each vector lane, and is used to select
elements to be stored.
The number of elements to be stored is equal to the number of active
bits in the mask.
.SS Arguments:
.PP
The first operand is the input vector, from which elements are collected
and written to memory.
The second operand is the base pointer for the store, it has the same
underlying type as the element of the input vector operand.
The third operand is the mask, a vector of boolean values.
The mask and the input vector must have the same number of vector
elements.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.masked.compressstore\f[R]\[aq] intrinsic is designed
for compressing data in memory.
It allows to collect elements from possibly non-adjacent lanes of a
vector and store them contiguously in memory in one IR operation.
It is useful for targets that support compressing store operations and
allows vectorizing loops with cross-iteration dependences like in the
following example:
.IP
.nf
\f[C]
// In this loop we load elements from A and store them consecutively in B
double *A, B; int *C;
for (int i = 0; i < size; ++i) {
  if (C[i] != 0)
    B[j++] = A[i]
}
\f[R]
.fi
.IP
.nf
\f[C]
; Load elements from A.
%Tmp = call <8 x double> \[at]llvm.masked.load.v8f64.p0v8f64(<8 x double>* %Aptr, i32 8, <8 x i1> %Mask, <8 x double> undef)
; Store all selected elements consecutively in array B
call <void> \[at]llvm.masked.compressstore.v8f64(<8 x double> %Tmp, double* %Bptr, <8 x i1> %Mask)

; %Bptr should be increased on each iteration according to the number of \[aq]1\[aq] elements in the Mask.
%MaskI = bitcast <8 x i1> %Mask to i8
%MaskIPopcnt = call i8 \[at]llvm.ctpop.i8(i8 %MaskI)
%MaskI64 = zext i8 %MaskIPopcnt to i64
%BNextInd = add i64 %BInd, %MaskI64
\f[R]
.fi
.PP
Other targets may support this intrinsic differently, for example, by
lowering it into a sequence of branches that guard scalar store
operations.
.SS Memory Use Markers
.PP
This class of intrinsics provides information about the
\f[V]lifetime of memory objects <objectlifetime>\f[R] and ranges where
variables are immutable.
.SS \[aq]\f[V]llvm.lifetime.start\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.lifetime.start(i64 <size>, i8* nocapture <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.lifetime.start\f[R]\[aq] intrinsic specifies the
start of a memory object\[aq]s lifetime.
.SS Arguments:
.PP
The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized.
The second argument is a pointer to the object.
.SS Semantics:
.PP
If \f[V]ptr\f[R] is a stack-allocated object and it points to the first
byte of the object, the object is initially marked as dead.
\f[V]ptr\f[R] is conservatively considered as a non-stack-allocated
object if the stack coloring algorithm that is used in the optimization
pipeline cannot conclude that \f[V]ptr\f[R] is a stack-allocated object.
.PP
After \[aq]\f[V]llvm.lifetime.start\f[R]\[aq], the stack object that
\f[V]ptr\f[R] points is marked as alive and has an uninitialized value.
The stack object is marked as dead when either
\f[V]llvm.lifetime.end <int_lifeend>\f[R] to the alloca is executed or
the function returns.
.PP
After \f[V]llvm.lifetime.end <int_lifeend>\f[R] is called,
\[aq]\f[V]llvm.lifetime.start\f[R]\[aq] on the stack object can be
called again.
The second \[aq]\f[V]llvm.lifetime.start\f[R]\[aq] call marks the object
as alive, but it does not change the address of the object.
.PP
If \f[V]ptr\f[R] is a non-stack-allocated object, it does not point to
the first byte of the object or it is a stack object that is already
alive, it simply fills all bytes of the object with \f[V]poison\f[R].
.SS \[aq]\f[V]llvm.lifetime.end\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.lifetime.end(i64 <size>, i8* nocapture <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.lifetime.end\f[R]\[aq] intrinsic specifies the end of
a memory object\[aq]s lifetime.
.SS Arguments:
.PP
The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized.
The second argument is a pointer to the object.
.SS Semantics:
.PP
If \f[V]ptr\f[R] is a stack-allocated object and it points to the first
byte of the object, the object is dead.
\f[V]ptr\f[R] is conservatively considered as a non-stack-allocated
object if the stack coloring algorithm that is used in the optimization
pipeline cannot conclude that \f[V]ptr\f[R] is a stack-allocated object.
.PP
Calling \f[V]llvm.lifetime.end\f[R] on an already dead alloca is no-op.
.PP
If \f[V]ptr\f[R] is a non-stack-allocated object or it does not point to
the first byte of the object, it is equivalent to simply filling all
bytes of the object with \f[V]poison\f[R].
.SS \[aq]\f[V]llvm.invariant.start\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
The memory object can belong to any address space.
.IP
.nf
\f[C]
declare {}* \[at]llvm.invariant.start.p0i8(i64 <size>, i8* nocapture <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.invariant.start\f[R]\[aq] intrinsic specifies that
the contents of a memory object will not change.
.SS Arguments:
.PP
The first argument is a constant integer representing the size of the
object, or -1 if it is variable sized.
The second argument is a pointer to the object.
.SS Semantics:
.PP
This intrinsic indicates that until an \f[V]llvm.invariant.end\f[R] that
uses the return value, the referenced memory location is constant and
unchanging.
.SS \[aq]\f[V]llvm.invariant.end\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
The memory object can belong to any address space.
.IP
.nf
\f[C]
declare void \[at]llvm.invariant.end.p0i8({}* <start>, i64 <size>, i8* nocapture <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.invariant.end\f[R]\[aq] intrinsic specifies that the
contents of a memory object are mutable.
.SS Arguments:
.PP
The first argument is the matching \f[V]llvm.invariant.start\f[R]
intrinsic.
The second argument is a constant integer representing the size of the
object, or -1 if it is variable sized and the third argument is a
pointer to the object.
.SS Semantics:
.PP
This intrinsic indicates that the memory is mutable again.
.SS \[aq]\f[V]llvm.launder.invariant.group\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
The memory object can belong to any address space.
The returned pointer must belong to the same address space as the
argument.
.IP
.nf
\f[C]
declare i8* \[at]llvm.launder.invariant.group.p0i8(i8* <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.launder.invariant.group\f[R]\[aq] intrinsic can be
used when an invariant established by \f[V]invariant.group\f[R] metadata
no longer holds, to obtain a new pointer value that carries fresh
invariant group information.
It is an experimental intrinsic, which means that its semantics might
change in the future.
.SS Arguments:
.PP
The \f[V]llvm.launder.invariant.group\f[R] takes only one argument,
which is a pointer to the memory.
.SS Semantics:
.PP
Returns another pointer that aliases its argument but which is
considered different for the purposes of \f[V]load\f[R]/\f[V]store\f[R]
\f[V]invariant.group\f[R] metadata.
It does not read any accessible memory and the execution can be
speculated.
.SS \[aq]\f[V]llvm.strip.invariant.group\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
The memory object can belong to any address space.
The returned pointer must belong to the same address space as the
argument.
.IP
.nf
\f[C]
declare i8* \[at]llvm.strip.invariant.group.p0i8(i8* <ptr>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.strip.invariant.group\f[R]\[aq] intrinsic can be used
when an invariant established by \f[V]invariant.group\f[R] metadata no
longer holds, to obtain a new pointer value that does not carry the
invariant information.
It is an experimental intrinsic, which means that its semantics might
change in the future.
.SS Arguments:
.PP
The \f[V]llvm.strip.invariant.group\f[R] takes only one argument, which
is a pointer to the memory.
.SS Semantics:
.PP
Returns another pointer that aliases its argument but which has no
associated \f[V]invariant.group\f[R] metadata.
It does not read any memory and can be speculated.
.SS Constrained Floating-Point Intrinsics
.PP
These intrinsics are used to provide special handling of floating-point
operations when specific rounding mode or floating-point exception
behavior is required.
By default, LLVM optimization passes assume that the rounding mode is
round-to-nearest and that floating-point exceptions will not be
monitored.
Constrained FP intrinsics are used to support non-default rounding modes
and accurately preserve exception behavior without compromising
LLVM\[aq]s ability to optimize FP code when the default behavior is
used.
.PP
If any FP operation in a function is constrained then they all must be
constrained.
This is required for correct LLVM IR.
Optimizations that move code around can create miscompiles if mixing of
constrained and normal operations is done.
The correct way to mix constrained and less constrained operations is to
use the rounding mode and exception handling metadata to mark
constrained intrinsics as having LLVM\[aq]s default behavior.
.PP
Each of these intrinsics corresponds to a normal floating-point
operation.
The data arguments and the return value are the same as the
corresponding FP operation.
.PP
The rounding mode argument is a metadata string specifying what
assumptions, if any, the optimizer can make when transforming constant
values.
Some constrained FP intrinsics omit this argument.
If required by the intrinsic, this argument must be one of the following
strings:
.IP
.nf
\f[C]
\[dq]round.dynamic\[dq]
\[dq]round.tonearest\[dq]
\[dq]round.downward\[dq]
\[dq]round.upward\[dq]
\[dq]round.towardzero\[dq]
\[dq]round.tonearestaway\[dq]
\f[R]
.fi
.PP
If this argument is \[dq]round.dynamic\[dq] optimization passes must
assume that the rounding mode is unknown and may change at runtime.
No transformations that depend on rounding mode may be performed in this
case.
.PP
The other possible values for the rounding mode argument correspond to
the similarly named IEEE rounding modes.
If the argument is any of these values optimization passes may perform
transformations as long as they are consistent with the specified
rounding mode.
.PP
For example, \[aq]x-0\[aq]->\[aq]x\[aq] is not a valid transformation if
the rounding mode is \[dq]round.downward\[dq] or \[dq]round.dynamic\[dq]
because if the value of \[aq]x\[aq] is +0 then \[aq]x-0\[aq] should
evaluate to \[aq]-0\[aq] when rounding downward.
However, this transformation is legal for all other rounding modes.
.PP
For values other than \[dq]round.dynamic\[dq] optimization passes may
assume that the actual runtime rounding mode (as defined in a
target-specific manner) matches the specified rounding mode, but this is
not guaranteed.
Using a specific non-dynamic rounding mode which does not match the
actual rounding mode at runtime results in undefined behavior.
.PP
The exception behavior argument is a metadata string describing the
floating point exception semantics that required for the intrinsic.
This argument must be one of the following strings:
.IP
.nf
\f[C]
\[dq]fpexcept.ignore\[dq]
\[dq]fpexcept.maytrap\[dq]
\[dq]fpexcept.strict\[dq]
\f[R]
.fi
.PP
If this argument is \[dq]fpexcept.ignore\[dq] optimization passes may
assume that the exception status flags will not be read and that
floating-point exceptions will be masked.
This allows transformations to be performed that may change the
exception semantics of the original code.
For example, FP operations may be speculatively executed in this case
whereas they must not be for either of the other possible values of this
argument.
.PP
If the exception behavior argument is \[dq]fpexcept.maytrap\[dq]
optimization passes must avoid transformations that may raise exceptions
that would not have been raised by the original code (such as
speculatively executing FP operations), but passes are not required to
preserve all exceptions that are implied by the original code.
For example, exceptions may be potentially hidden by constant folding.
.PP
If the exception behavior argument is \[dq]fpexcept.strict\[dq] all
transformations must strictly preserve the floating-point exception
semantics of the original code.
Any FP exception that would have been raised by the original code must
be raised by the transformed code, and the transformed code must not
raise any FP exceptions that would not have been raised by the original
code.
This is the exception behavior argument that will be used if the code
being compiled reads the FP exception status flags, but this mode can
also be used with code that unmasks FP exceptions.
.PP
The number and order of floating-point exceptions is NOT guaranteed.
For example, a series of FP operations that each may raise exceptions
may be vectorized into a single instruction that raises each unique
exception a single time.
.PP
Proper \f[V]function attributes <fnattrs>\f[R] usage is required for the
constrained intrinsics to function correctly.
.PP
All function \f[I]calls\f[R] done in a function that uses constrained
floating point intrinsics must have the \f[V]strictfp\f[R] attribute.
.PP
All function \f[I]definitions\f[R] that use constrained floating point
intrinsics must have the \f[V]strictfp\f[R] attribute.
.SS \[aq]\f[V]llvm.experimental.constrained.fadd\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fadd(<type> <op1>, <type> <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fadd\f[R]\[aq] intrinsic
returns the sum of its two operands.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.fadd\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The value produced is the floating-point sum of the two value operands
and has the same type as the operands.
.SS \[aq]\f[V]llvm.experimental.constrained.fsub\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fsub(<type> <op1>, <type> <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fsub\f[R]\[aq] intrinsic
returns the difference of its two operands.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.fsub\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The value produced is the floating-point difference of the two value
operands and has the same type as the operands.
.SS \[aq]\f[V]llvm.experimental.constrained.fmul\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fmul(<type> <op1>, <type> <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fmul\f[R]\[aq] intrinsic
returns the product of its two operands.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.fmul\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The value produced is the floating-point product of the two value
operands and has the same type as the operands.
.SS \[aq]\f[V]llvm.experimental.constrained.fdiv\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fdiv(<type> <op1>, <type> <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fdiv\f[R]\[aq] intrinsic
returns the quotient of its two operands.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.fdiv\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The value produced is the floating-point quotient of the two value
operands and has the same type as the operands.
.SS \[aq]\f[V]llvm.experimental.constrained.frem\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.frem(<type> <op1>, <type> <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.frem\f[R]\[aq] intrinsic
returns the remainder from the division of its two operands.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.frem\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R] of
floating-point values.
Both arguments must have identical types.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
The rounding mode argument has no effect, since the result of frem is
never rounded, but the argument is included for consistency with the
other constrained floating-point intrinsics.
.SS Semantics:
.PP
The value produced is the floating-point remainder from the division of
the two value operands and has the same type as the operands.
The remainder has the same sign as the dividend.
.SS \[aq]\f[V]llvm.experimental.constrained.fma\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fma(<type> <op1>, <type> <op2>, <type> <op3>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fma\f[R]\[aq] intrinsic
returns the result of a fused-multiply-add operation on its operands.
.SS Arguments:
.PP
The first three arguments to the
\[aq]\f[V]llvm.experimental.constrained.fma\f[R]\[aq] intrinsic must be
\f[V]floating-point <t_floating>\f[R] or \f[V]vector
<t_vector>\f[R] of floating-point values.
All arguments must have identical types.
.PP
The fourth and fifth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The result produced is the product of the first two operands added to
the third operand computed with infinite precision, and then rounded to
the target precision.
.SS \[aq]\f[V]llvm.experimental.constrained.fptoui\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.fptoui(<type> <value>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fptoui\f[R]\[aq] intrinsic
converts a floating-point \f[V]value\f[R] to its unsigned integer
equivalent of type \f[V]ty2\f[R].
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.fptoui\f[R]\[aq] intrinsic must
be \f[V]floating point <t_floating>\f[R] or \f[V]vector
<t_vector>\f[R] of floating point values.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
The result produced is an unsigned integer converted from the floating
point operand.
The value is truncated, so it is rounded towards zero.
.SS \[aq]\f[V]llvm.experimental.constrained.fptosi\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.fptosi(<type> <value>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fptosi\f[R]\[aq] intrinsic
converts \f[V]floating-point <t_floating>\f[R] \f[V]value\f[R] to type
\f[V]ty2\f[R].
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.fptosi\f[R]\[aq] intrinsic must
be \f[V]floating point <t_floating>\f[R] or \f[V]vector
<t_vector>\f[R] of floating point values.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
The result produced is a signed integer converted from the floating
point operand.
The value is truncated, so it is rounded towards zero.
.SS \[aq]\f[V]llvm.experimental.constrained.uitofp\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.uitofp(<type> <value>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.uitofp\f[R]\[aq] intrinsic
converts an unsigned integer \f[V]value\f[R] to a floating-point of type
\f[V]ty2\f[R].
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.uitofp\f[R]\[aq] intrinsic must
be an \f[V]integer <t_integer>\f[R] or \f[V]vector
<t_vector>\f[R] of integer values.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
An inexact floating-point exception will be raised if rounding is
required.
Any result produced is a floating point value converted from the input
integer operand.
.SS \[aq]\f[V]llvm.experimental.constrained.sitofp\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.sitofp(<type> <value>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.sitofp\f[R]\[aq] intrinsic
converts a signed integer \f[V]value\f[R] to a floating-point of type
\f[V]ty2\f[R].
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.sitofp\f[R]\[aq] intrinsic must
be an \f[V]integer <t_integer>\f[R] or \f[V]vector
<t_vector>\f[R] of integer values.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
An inexact floating-point exception will be raised if rounding is
required.
Any result produced is a floating point value converted from the input
integer operand.
.SS \[aq]\f[V]llvm.experimental.constrained.fptrunc\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.fptrunc(<type> <value>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fptrunc\f[R]\[aq] intrinsic
truncates \f[V]value\f[R] to type \f[V]ty2\f[R].
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.fptrunc\f[R]\[aq] intrinsic must
be \f[V]floating point <t_floating>\f[R] or \f[V]vector
<t_vector>\f[R] of floating point values.
This argument must be larger in size than the result.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The result produced is a floating point value truncated to be smaller in
size than the operand.
.SS \[aq]\f[V]llvm.experimental.constrained.fpext\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.fpext(<type> <value>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fpext\f[R]\[aq] intrinsic
extends a floating-point \f[V]value\f[R] to a larger floating-point
value.
.SS Arguments:
.PP
The first argument to the
\[aq]\f[V]llvm.experimental.constrained.fpext\f[R]\[aq] intrinsic must
be \f[V]floating point <t_floating>\f[R] or \f[V]vector
<t_vector>\f[R] of floating point values.
This argument must be smaller in size than the result.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
The result produced is a floating point value extended to be larger in
size than the operand.
All restrictions that apply to the fpext instruction also apply to this
intrinsic.
.SS \[aq]\f[V]llvm.experimental.constrained.fcmp\f[R]\[aq] and \[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] Intrinsics
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.experimental.constrained.fcmp(<type> <op1>, <type> <op2>,
                                    metadata <condition code>,
                                    metadata <exception behavior>)
declare <ty2>
\[at]llvm.experimental.constrained.fcmps(<type> <op1>, <type> <op2>,
                                     metadata <condition code>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fcmp\f[R]\[aq] and
\[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] intrinsics
return a boolean value or vector of boolean values based on comparison
of its operands.
.PP
If the operands are floating-point scalars, then the result type is a
boolean (\f[V]i1 <t_integer>\f[R]).
.PP
If the operands are floating-point vectors, then the result type is a
vector of boolean with the same number of elements as the operands being
compared.
.PP
The \[aq]\f[V]llvm.experimental.constrained.fcmp\f[R]\[aq] intrinsic
performs a quiet comparison operation while the
\[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] intrinsic
performs a signaling comparison operation.
.SS Arguments:
.PP
The first two arguments to the
\[aq]\f[V]llvm.experimental.constrained.fcmp\f[R]\[aq] and
\[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] intrinsics must
be \f[V]floating-point <t_floating>\f[R] or \f[V]vector <t_vector>\f[R]
of floating-point values.
Both arguments must have identical types.
.PP
The third argument is the condition code indicating the kind of
comparison to perform.
It must be a metadata string with one of the following values:
.IP \[bu] 2
\[dq]\f[V]oeq\f[R]\[dq]: ordered and equal
.IP \[bu] 2
\[dq]\f[V]ogt\f[R]\[dq]: ordered and greater than
.IP \[bu] 2
\[dq]\f[V]oge\f[R]\[dq]: ordered and greater than or equal
.IP \[bu] 2
\[dq]\f[V]olt\f[R]\[dq]: ordered and less than
.IP \[bu] 2
\[dq]\f[V]ole\f[R]\[dq]: ordered and less than or equal
.IP \[bu] 2
\[dq]\f[V]one\f[R]\[dq]: ordered and not equal
.IP \[bu] 2
\[dq]\f[V]ord\f[R]\[dq]: ordered (no nans)
.IP \[bu] 2
\[dq]\f[V]ueq\f[R]\[dq]: unordered or equal
.IP \[bu] 2
\[dq]\f[V]ugt\f[R]\[dq]: unordered or greater than
.IP \[bu] 2
\[dq]\f[V]uge\f[R]\[dq]: unordered or greater than or equal
.IP \[bu] 2
\[dq]\f[V]ult\f[R]\[dq]: unordered or less than
.IP \[bu] 2
\[dq]\f[V]ule\f[R]\[dq]: unordered or less than or equal
.IP \[bu] 2
\[dq]\f[V]une\f[R]\[dq]: unordered or not equal
.IP \[bu] 2
\[dq]\f[V]uno\f[R]\[dq]: unordered (either nans)
.PP
\f[I]Ordered\f[R] means that neither operand is a NAN while
\f[I]unordered\f[R] means that either operand may be a NAN.
.PP
The fourth argument specifies the exception behavior as described above.
.SS Semantics:
.PP
\f[V]op1\f[R] and \f[V]op2\f[R] are compared according to the condition
code given as the third argument.
If the operands are vectors, then the vectors are compared element by
element.
Each comparison performed always yields an \f[V]i1 <t_integer>\f[R]
result, as follows:
.IP \[bu] 2
\[dq]\f[V]oeq\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ogt\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]oge\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is greater than or equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]olt\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ole\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]one\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN and \f[V]op1\f[R] is not equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ord\f[R]\[dq]: yields \f[V]true\f[R] if both operands are not
a NAN.
.IP \[bu] 2
\[dq]\f[V]ueq\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ugt\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is greater than \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]uge\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is greater than or equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ult\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is less than \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]ule\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is less than or equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]une\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN or \f[V]op1\f[R] is not equal to \f[V]op2\f[R].
.IP \[bu] 2
\[dq]\f[V]uno\f[R]\[dq]: yields \f[V]true\f[R] if either operand is a
NAN.
.PP
The quiet comparison operation performed by
\[aq]\f[V]llvm.experimental.constrained.fcmp\f[R]\[aq] will only raise
an exception if either operand is a SNAN.
The signaling comparison operation performed by
\[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] will raise an
exception if either operand is a NAN (QNAN or SNAN).
Such an exception does not preclude a result being produced (e.g.
exception might only set a flag), therefore the distinction between
ordered and unordered comparisons is also relevant for the
\[aq]\f[V]llvm.experimental.constrained.fcmps\f[R]\[aq] intrinsic.
.SS \[aq]\f[V]llvm.experimental.constrained.fmuladd\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.fmuladd(<type> <op1>, <type> <op2>,
                                       <type> <op3>,
                                       metadata <rounding mode>,
                                       metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.fmuladd\f[R]\[aq] intrinsic
represents multiply-add expressions that can be fused if the code
generator determines that (a) the target instruction set has support for
a fused operation, and (b) that the fused operation is more efficient
than the equivalent, separate pair of mul and add instructions.
.SS Arguments:
.PP
The first three arguments to the
\[aq]\f[V]llvm.experimental.constrained.fmuladd\f[R]\[aq] intrinsic must
be floating-point or vector of floating-point values.
All three arguments must have identical types.
.PP
The fourth and fifth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
The expression:
.IP
.nf
\f[C]
%0 = call float \[at]llvm.experimental.constrained.fmuladd.f32(%a, %b, %c,
                                                           metadata <rounding mode>,
                                                           metadata <exception behavior>)
\f[R]
.fi
.PP
is equivalent to the expression:
.IP
.nf
\f[C]
%0 = call float \[at]llvm.experimental.constrained.fmul.f32(%a, %b,
                                                        metadata <rounding mode>,
                                                        metadata <exception behavior>)
%1 = call float \[at]llvm.experimental.constrained.fadd.f32(%0, %c,
                                                        metadata <rounding mode>,
                                                        metadata <exception behavior>)
\f[R]
.fi
.PP
except that it is unspecified whether rounding will be performed between
the multiplication and addition steps.
Fusion is not guaranteed, even if the target platform supports it.
If a fused multiply-add is required, the corresponding
\f[V]llvm.experimental.constrained.fma <int_fma>\f[R] intrinsic function
should be used instead.
This never sets errno, just as
\[aq]\f[V]llvm.experimental.constrained.fma.*\f[R]\[aq].
.SS Constrained libm-equivalent Intrinsics
.PP
In addition to the basic floating-point operations for which constrained
intrinsics are described above, there are constrained versions of
various operations which provide equivalent behavior to a corresponding
libm function.
These intrinsics allow the precise behavior of these operations with
respect to rounding mode and exception behavior to be controlled.
.PP
As with the basic constrained floating-point intrinsics, the rounding
mode and exception behavior arguments only control the behavior of the
optimizer.
They do not change the runtime floating-point environment.
.SS \[aq]\f[V]llvm.experimental.constrained.sqrt\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.sqrt(<type> <op1>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.sqrt\f[R]\[aq] intrinsic
returns the square root of the specified value, returning the same value
as the libm \[aq]\f[V]sqrt\f[R]\[aq] functions would, but without
setting \f[V]errno\f[R].
.SS Arguments:
.PP
The first argument and the return type are floating-point numbers of the
same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the nonnegative square root of the specified
value.
If the value is less than negative zero, a floating-point exception
occurs and the return value is architecture specific.
.SS \[aq]\f[V]llvm.experimental.constrained.pow\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.pow(<type> <op1>, <type> <op2>,
                                   metadata <rounding mode>,
                                   metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.pow\f[R]\[aq] intrinsic
returns the first operand raised to the (positive or negative) power
specified by the second operand.
.SS Arguments:
.PP
The first two arguments and the return value are floating-point numbers
of the same type.
The second argument specifies the power to which the first argument
should be raised.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the first value raised to the second power,
returning the same values as the libm \f[V]pow\f[R] functions would, and
handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.powi\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.powi(<type> <op1>, i32 <op2>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.powi\f[R]\[aq] intrinsic
returns the first operand raised to the (positive or negative) power
specified by the second operand.
The order of evaluation of multiplications is not defined.
When a vector of floating-point type is used, the second argument
remains a scalar integer value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
The second argument is a 32-bit signed integer specifying the power to
which the first argument should be raised.
.PP
The third and fourth arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the first value raised to the second power with an
unspecified sequence of rounding operations.
.SS \[aq]\f[V]llvm.experimental.constrained.sin\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.sin(<type> <op1>,
                                   metadata <rounding mode>,
                                   metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.sin\f[R]\[aq] intrinsic
returns the sine of the first operand.
.SS Arguments:
.PP
The first argument and the return type are floating-point numbers of the
same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the sine of the specified operand, returning the
same values as the libm \f[V]sin\f[R] functions would, and handles error
conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.cos\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.cos(<type> <op1>,
                                   metadata <rounding mode>,
                                   metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.cos\f[R]\[aq] intrinsic
returns the cosine of the first operand.
.SS Arguments:
.PP
The first argument and the return type are floating-point numbers of the
same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the cosine of the specified operand, returning the
same values as the libm \f[V]cos\f[R] functions would, and handles error
conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.exp\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.exp(<type> <op1>,
                                   metadata <rounding mode>,
                                   metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.exp\f[R]\[aq] intrinsic
computes the base-e exponential of the specified value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]exp\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.exp2\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.exp2(<type> <op1>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.exp2\f[R]\[aq] intrinsic
computes the base-2 exponential of the specified value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]exp2\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.log\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.log(<type> <op1>,
                                   metadata <rounding mode>,
                                   metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.log\f[R]\[aq] intrinsic
computes the base-e logarithm of the specified value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]log\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.log10\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.log10(<type> <op1>,
                                     metadata <rounding mode>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.log10\f[R]\[aq] intrinsic
computes the base-10 logarithm of the specified value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]log10\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.log2\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.log2(<type> <op1>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.log2\f[R]\[aq] intrinsic
computes the base-2 logarithm of the specified value.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]log2\f[R]
functions would, and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.rint\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.rint(<type> <op1>,
                                    metadata <rounding mode>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.rint\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer.
It may raise an inexact floating-point exception if the operand is not
an integer.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]rint\f[R]
functions would, and handles error conditions in the same way.
The rounding mode is described, not determined, by the rounding mode
argument.
The actual rounding mode is determined by the runtime floating-point
environment.
The rounding mode argument is only intended as information to the
compiler.
.SS \[aq]\f[V]llvm.experimental.constrained.lrint\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <inttype>
\[at]llvm.experimental.constrained.lrint(<fptype> <op1>,
                                     metadata <rounding mode>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.lrint\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer.
An inexact floating-point exception will be raised if the operand is not
an integer.
An invalid exception is raised if the result is too large to fit into a
supported integer type, and in this case the result is undefined.
.SS Arguments:
.PP
The first argument is a floating-point number.
The return value is an integer type.
Not all types are supported on all targets.
The supported types are the same as the \f[V]llvm.lrint\f[R] intrinsic
and the \f[V]lrint\f[R] libm functions.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]lrint\f[R]
functions would, and handles error conditions in the same way.
.PP
The rounding mode is described, not determined, by the rounding mode
argument.
The actual rounding mode is determined by the runtime floating-point
environment.
The rounding mode argument is only intended as information to the
compiler.
.PP
If the runtime floating-point environment is using the default rounding
mode then the results will be the same as the llvm.lrint intrinsic.
.SS \[aq]\f[V]llvm.experimental.constrained.llrint\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <inttype>
\[at]llvm.experimental.constrained.llrint(<fptype> <op1>,
                                      metadata <rounding mode>,
                                      metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.llrint\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer.
An inexact floating-point exception will be raised if the operand is not
an integer.
An invalid exception is raised if the result is too large to fit into a
supported integer type, and in this case the result is undefined.
.SS Arguments:
.PP
The first argument is a floating-point number.
The return value is an integer type.
Not all types are supported on all targets.
The supported types are the same as the \f[V]llvm.llrint\f[R] intrinsic
and the \f[V]llrint\f[R] libm functions.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]llrint\f[R]
functions would, and handles error conditions in the same way.
.PP
The rounding mode is described, not determined, by the rounding mode
argument.
The actual rounding mode is determined by the runtime floating-point
environment.
The rounding mode argument is only intended as information to the
compiler.
.PP
If the runtime floating-point environment is using the default rounding
mode then the results will be the same as the llvm.llrint intrinsic.
.SS \[aq]\f[V]llvm.experimental.constrained.nearbyint\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.nearbyint(<type> <op1>,
                                         metadata <rounding mode>,
                                         metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.nearbyint\f[R]\[aq]
intrinsic returns the first operand rounded to the nearest integer.
It will not raise an inexact floating-point exception if the operand is
not an integer.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second and third arguments specify the rounding mode and exception
behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]nearbyint\f[R]
functions would, and handles error conditions in the same way.
The rounding mode is described, not determined, by the rounding mode
argument.
The actual rounding mode is determined by the runtime floating-point
environment.
The rounding mode argument is only intended as information to the
compiler.
.SS \[aq]\f[V]llvm.experimental.constrained.maxnum\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.maxnum(<type> <op1>, <type> <op2>
                                      metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.maxnum\f[R]\[aq] intrinsic
returns the maximum of the two arguments.
.SS Arguments:
.PP
The first two arguments and the return value are floating-point numbers
of the same type.
.PP
The third argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function follows the IEEE-754 semantics for maxNum.
.SS \[aq]\f[V]llvm.experimental.constrained.minnum\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.minnum(<type> <op1>, <type> <op2>
                                      metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.minnum\f[R]\[aq] intrinsic
returns the minimum of the two arguments.
.SS Arguments:
.PP
The first two arguments and the return value are floating-point numbers
of the same type.
.PP
The third argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function follows the IEEE-754 semantics for minNum.
.SS \[aq]\f[V]llvm.experimental.constrained.maximum\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.maximum(<type> <op1>, <type> <op2>
                                       metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.maximum\f[R]\[aq] intrinsic
returns the maximum of the two arguments, propagating NaNs and treating
-0.0 as less than +0.0.
.SS Arguments:
.PP
The first two arguments and the return value are floating-point numbers
of the same type.
.PP
The third argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function follows semantics specified in the draft of IEEE 754-2018.
.SS \[aq]\f[V]llvm.experimental.constrained.minimum\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.minimum(<type> <op1>, <type> <op2>
                                       metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.minimum\f[R]\[aq] intrinsic
returns the minimum of the two arguments, propagating NaNs and treating
-0.0 as less than +0.0.
.SS Arguments:
.PP
The first two arguments and the return value are floating-point numbers
of the same type.
.PP
The third argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function follows semantics specified in the draft of IEEE 754-2018.
.SS \[aq]\f[V]llvm.experimental.constrained.ceil\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.ceil(<type> <op1>,
                                    metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.ceil\f[R]\[aq] intrinsic
returns the ceiling of the first operand.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]ceil\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.floor\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.floor(<type> <op1>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.floor\f[R]\[aq] intrinsic
returns the floor of the first operand.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]floor\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.round\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.round(<type> <op1>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.round\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]round\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.roundeven\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.roundeven(<type> <op1>,
                                         metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.roundeven\f[R]\[aq]
intrinsic returns the first operand rounded to the nearest integer in
floating-point format, rounding halfway cases to even (that is, to the
nearest value that is an even integer), regardless of the current
rounding direction.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function implements IEEE-754 operation
\f[V]roundToIntegralTiesToEven\f[R].
It also behaves in the same way as C standard function
\f[V]roundeven\f[R] and can signal the invalid operation exception for a
SNAN operand.
.SS \[aq]\f[V]llvm.experimental.constrained.lround\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <inttype>
\[at]llvm.experimental.constrained.lround(<fptype> <op1>,
                                      metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.lround\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer with ties away
from zero.
It will raise an inexact floating-point exception if the operand is not
an integer.
An invalid exception is raised if the result is too large to fit into a
supported integer type, and in this case the result is undefined.
.SS Arguments:
.PP
The first argument is a floating-point number.
The return value is an integer type.
Not all types are supported on all targets.
The supported types are the same as the \f[V]llvm.lround\f[R] intrinsic
and the \f[V]lround\f[R] libm functions.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]lround\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.llround\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <inttype>
\[at]llvm.experimental.constrained.llround(<fptype> <op1>,
                                       metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.llround\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer with ties away
from zero.
It will raise an inexact floating-point exception if the operand is not
an integer.
An invalid exception is raised if the result is too large to fit into a
supported integer type, and in this case the result is undefined.
.SS Arguments:
.PP
The first argument is a floating-point number.
The return value is an integer type.
Not all types are supported on all targets.
The supported types are the same as the \f[V]llvm.llround\f[R] intrinsic
and the \f[V]llround\f[R] libm functions.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]llround\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.constrained.trunc\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.experimental.constrained.trunc(<type> <op1>,
                                     metadata <exception behavior>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.experimental.constrained.trunc\f[R]\[aq] intrinsic
returns the first operand rounded to the nearest integer not larger in
magnitude than the operand.
.SS Arguments:
.PP
The first argument and the return value are floating-point numbers of
the same type.
.PP
The second argument specifies the exception behavior as described above.
.SS Semantics:
.PP
This function returns the same values as the libm \f[V]trunc\f[R]
functions would and handles error conditions in the same way.
.SS \[aq]\f[V]llvm.experimental.noalias.scope.decl\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.experimental.noalias.scope.decl(metadata !id.scope.list)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.experimental.noalias.scope.decl\f[R] intrinsic identifies
where a noalias scope is declared.
When the intrinsic is duplicated, a decision must also be made about the
scope: depending on the reason of the duplication, the scope might need
to be duplicated as well.
.SS Arguments:
.PP
The \f[V]!id.scope.list\f[R] argument is metadata that is a list of
\f[V]noalias\f[R] metadata references.
The format is identical to that required for \f[V]noalias\f[R] metadata.
This list must have exactly one element.
.SS Semantics:
.PP
The \f[V]llvm.experimental.noalias.scope.decl\f[R] intrinsic identifies
where a noalias scope is declared.
When the intrinsic is duplicated, a decision must also be made about the
scope: depending on the reason of the duplication, the scope might need
to be duplicated as well.
.PP
For example, when the intrinsic is used inside a loop body, and that
loop is unrolled, the associated noalias scope must also be duplicated.
Otherwise, the noalias property it signifies would spill across loop
iterations, whereas it was only valid within a single iteration.
.IP
.nf
\f[C]
; This examples shows two possible positions for noalias.decl and how they impact the semantics:
; If it is outside the loop (Version 1), then %a and %b are noalias across *all* iterations.
; If it is inside the loop (Version 2), then %a and %b are noalias only within *one* iteration.
declare void \[at]decl_in_loop(i8* %a.base, i8* %b.base) {
entry:
  ; call void \[at]llvm.experimental.noalias.scope.decl(metadata !2) ; Version 1: noalias decl outside loop
  br label %loop

loop:
  %a = phi i8* [ %a.base, %entry ], [ %a.inc, %loop ]
  %b = phi i8* [ %b.base, %entry ], [ %b.inc, %loop ]
  ; call void \[at]llvm.experimental.noalias.scope.decl(metadata !2) ; Version 2: noalias decl inside loop
  %val = load i8, i8* %a, !alias.scope !2
  store i8 %val, i8* %b, !noalias !2
  %a.inc = getelementptr inbounds i8, i8* %a, i64 1
  %b.inc = getelementptr inbounds i8, i8* %b, i64 1
  %cond = call i1 \[at]cond()
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}

!0 = !{!0} ; domain
!1 = !{!1, !0} ; scope
!2 = !{!1} ; scope list
\f[R]
.fi
.PP
Multiple calls to \[at]llvm.experimental.noalias.scope.decl for the same
scope are possible, but one should never dominate another.
Violations are pointed out by the verifier as they indicate a problem in
either a transformation pass or the input.
.SS Floating Point Environment Manipulation intrinsics
.PP
These functions read or write floating point environment, such as
rounding mode or state of floating point exceptions.
Altering the floating point environment requires special care.
See \f[V]Floating Point Environment <floatenv>\f[R].
.SS \[aq]\f[V]llvm.flt.rounds\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.flt.rounds()
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.flt.rounds\f[R]\[aq] intrinsic reads the current
rounding mode.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.flt.rounds\f[R]\[aq] intrinsic returns the current
rounding mode.
Encoding of the returned values is same as the result of
\f[V]FLT_ROUNDS\f[R], specified by C standard:
.IP
.nf
\f[C]
0  - toward zero
1  - to nearest, ties to even
2  - toward positive infinity
3  - toward negative infinity
4  - to nearest, ties away from zero
\f[R]
.fi
.PP
Other values may be used to represent additional rounding modes,
supported by a target.
These values are target-specific.
.SS \[aq]\f[V]llvm.set.rounding\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.set.rounding(i32 <val>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.set.rounding\f[R]\[aq] intrinsic sets current
rounding mode.
.SS Arguments:
.PP
The argument is the required rounding mode.
Encoding of rounding mode is the same as used by
\[aq]\f[V]llvm.flt.rounds\f[R]\[aq].
.SS Semantics:
.PP
The \[aq]\f[V]llvm.set.rounding\f[R]\[aq] intrinsic sets the current
rounding mode.
It is similar to C library function \[aq]fesetround\[aq], however this
intrinsic does not return any value and uses platform-independent
representation of IEEE rounding modes.
.SS Floating-Point Test Intrinsics
.PP
These functions get properties of floating-point values.
.SS \[aq]\f[V]llvm.is.fpclass\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i1 \[at]llvm.is.fpclass(<fptype> <op>, i32 <test>)
declare <N x i1> \[at]llvm.is.fpclass(<vector-fptype> <op>, i32 <test>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.is.fpclass\f[R]\[aq] intrinsic returns a boolean
value or vector of boolean values depending on whether the first
argument satisfies the test specified by the second argument.
.PP
If the first argument is a floating-point scalar, then the result type
is a boolean (\f[V]i1 <t_integer>\f[R]).
.PP
If the first argument is a floating-point vector, then the result type
is a vector of boolean with the same number of elements as the first
argument.
.SS Arguments:
.PP
The first argument to the \[aq]\f[V]llvm.is.fpclass\f[R]\[aq] intrinsic
must be \f[V]floating-point <t_floating>\f[R] or
\f[V]vector <t_vector>\f[R] of floating-point values.
.PP
The second argument specifies, which tests to perform.
It must be a compile-time integer constant, each bit in which specifies
floating-point class:
.PP
.TS
tab(@);
lw(7.8n) lw(22.4n).
T{
Bit #
T}@T{
floating-point class
T}
_
T{
0
T}@T{
Signaling NaN
T}
T{
1
T}@T{
Quiet NaN
T}
T{
2
T}@T{
Negative infinity
T}
T{
3
T}@T{
Negative normal
T}
T{
4
T}@T{
Negative subnormal
T}
T{
5
T}@T{
Negative zero
T}
T{
6
T}@T{
Positive zero
T}
T{
7
T}@T{
Positive subnormal
T}
T{
8
T}@T{
Positive normal
T}
T{
9
T}@T{
Positive infinity
T}
.TE
.SS Semantics:
.PP
The function checks if \f[V]op\f[R] belongs to any of the floating-point
classes specified by \f[V]test\f[R].
If \f[V]op\f[R] is a vector, then the check is made element by element.
Each check yields an \f[V]i1 <t_integer>\f[R] result, which is
\f[V]true\f[R], if the element value satisfies the specified test.
The argument \f[V]test\f[R] is a bit mask where each bit specifies
floating-point class to test.
For example, the value 0x108 makes test for normal value, - bits 3 and 8
in it are set, which means that the function returns \f[V]true\f[R] if
\f[V]op\f[R] is a positive or negative normal value.
The function never raises floating-point exceptions.
.SS General Intrinsics
.PP
This class of intrinsics is designed to be generic and has no specific
purpose.
.SS \[aq]\f[V]llvm.var.annotation\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.var.annotation(i8* <val>, i8* <str>, i8* <str>, i32  <int>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.var.annotation\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
The first argument is a pointer to a value, the second is a pointer to a
global string, the third is a pointer to a global string which is the
source file name, and the last argument is the line number.
.SS Semantics:
.PP
This intrinsic allows annotation of local variables with arbitrary
strings.
This can be useful for special purpose optimizations that want to look
for these annotations.
These have no other defined use; they are ignored by code generation and
optimization.
.SS \[aq]\f[V]llvm.ptr.annotation.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \[aq]\f[V]llvm.ptr.annotation\f[R]\[aq] on a pointer to an
integer of any width.
\f[I]NOTE\f[R] you must specify an address space for the pointer.
The identifier for the default address space is the integer
\[aq]\f[V]0\f[R]\[aq].
.IP
.nf
\f[C]
declare i8*   \[at]llvm.ptr.annotation.p<address space>i8(i8* <val>, i8* <str>, i8* <str>, i32  <int>)
declare i16*  \[at]llvm.ptr.annotation.p<address space>i16(i16* <val>, i8* <str>, i8* <str>, i32  <int>)
declare i32*  \[at]llvm.ptr.annotation.p<address space>i32(i32* <val>, i8* <str>, i8* <str>, i32  <int>)
declare i64*  \[at]llvm.ptr.annotation.p<address space>i64(i64* <val>, i8* <str>, i8* <str>, i32  <int>)
declare i256* \[at]llvm.ptr.annotation.p<address space>i256(i256* <val>, i8* <str>, i8* <str>, i32  <int>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ptr.annotation\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
The first argument is a pointer to an integer value of arbitrary
bitwidth (result of some expression), the second is a pointer to a
global string, the third is a pointer to a global string which is the
source file name, and the last argument is the line number.
It returns the value of the first argument.
.SS Semantics:
.PP
This intrinsic allows annotation of a pointer to an integer with
arbitrary strings.
This can be useful for special purpose optimizations that want to look
for these annotations.
These have no other defined use; transformations preserve annotations on
a best-effort basis but are allowed to replace the intrinsic with its
first argument without breaking semantics and the intrinsic is
completely dropped during instruction selection.
.SS \[aq]\f[V]llvm.annotation.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \[aq]\f[V]llvm.annotation\f[R]\[aq] on any integer bit
width.
.IP
.nf
\f[C]
declare i8 \[at]llvm.annotation.i8(i8 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i16 \[at]llvm.annotation.i16(i16 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i32 \[at]llvm.annotation.i32(i32 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i64 \[at]llvm.annotation.i64(i64 <val>, i8* <str>, i8* <str>, i32  <int>)
declare i256 \[at]llvm.annotation.i256(i256 <val>, i8* <str>, i8* <str>, i32  <int>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.annotation\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
The first argument is an integer value (result of some expression), the
second is a pointer to a global string, the third is a pointer to a
global string which is the source file name, and the last argument is
the line number.
It returns the value of the first argument.
.SS Semantics:
.PP
This intrinsic allows annotations to be put on arbitrary expressions
with arbitrary strings.
This can be useful for special purpose optimizations that want to look
for these annotations.
These have no other defined use; transformations preserve annotations on
a best-effort basis but are allowed to replace the intrinsic with its
first argument without breaking semantics and the intrinsic is
completely dropped during instruction selection.
.SS \[aq]\f[V]llvm.codeview.annotation\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This annotation emits a label at its program point and an associated
\f[V]S_ANNOTATION\f[R] codeview record with some additional string
metadata.
This is used to implement MSVC\[aq]s \f[V]__annotation\f[R] intrinsic.
It is marked \f[V]noduplicate\f[R], so calls to this intrinsic prevent
inlining and should be considered expensive.
.IP
.nf
\f[C]
declare void \[at]llvm.codeview.annotation(metadata)
\f[R]
.fi
.SS Arguments:
.PP
The argument should be an MDTuple containing any number of MDStrings.
.SS \[aq]\f[V]llvm.trap\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.trap() cold noreturn nounwind
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.trap\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
This intrinsic is lowered to the target dependent trap instruction.
If the target does not have a trap instruction, this intrinsic will be
lowered to a call of the \f[V]abort()\f[R] function.
.SS \[aq]\f[V]llvm.debugtrap\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.debugtrap() nounwind
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.debugtrap\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
This intrinsic is lowered to code which is intended to cause an
execution trap with the intention of requesting the attention of a
debugger.
.SS \[aq]\f[V]llvm.ubsantrap\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.ubsantrap(i8 immarg) cold noreturn nounwind
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.ubsantrap\f[R]\[aq] intrinsic.
.SS Arguments:
.PP
An integer describing the kind of failure detected.
.SS Semantics:
.PP
This intrinsic is lowered to code which is intended to cause an
execution trap, embedding the argument into encoding of that trap
somehow to discriminate crashes if possible.
.PP
Equivalent to \f[V]\[at]llvm.trap\f[R] for targets that do not support
this behaviour.
.SS \[aq]\f[V]llvm.stackprotector\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.stackprotector(i8* <guard>, i8** <slot>)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.stackprotector\f[R] intrinsic takes the \f[V]guard\f[R]
and stores it onto the stack at \f[V]slot\f[R].
The stack slot is adjusted to ensure that it is placed on the stack
before local variables.
.SS Arguments:
.PP
The \f[V]llvm.stackprotector\f[R] intrinsic requires two pointer
arguments.
The first argument is the value loaded from the stack guard
\f[V]\[at]__stack_chk_guard\f[R].
The second variable is an \f[V]alloca\f[R] that has enough space to hold
the value of the guard.
.SS Semantics:
.PP
This intrinsic causes the prologue/epilogue inserter to force the
position of the \f[V]AllocaInst\f[R] stack slot to be before local
variables on the stack.
This is to ensure that if a local variable on the stack is overwritten,
it will destroy the value of the guard.
When the function exits, the guard on the stack is checked against the
original guard by \f[V]llvm.stackprotectorcheck\f[R].
If they are different, then \f[V]llvm.stackprotectorcheck\f[R] causes
the program to abort by calling the \f[V]__stack_chk_fail()\f[R]
function.
.SS \[aq]\f[V]llvm.stackguard\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.stackguard()
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.stackguard\f[R] intrinsic returns the system stack guard
value.
.PP
It should not be generated by frontends, since it is only for internal
usage.
The reason why we create this intrinsic is that we still support IR form
Stack Protector in FastISel.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
On some platforms, the value returned by this intrinsic remains
unchanged between loads in the same thread.
On other platforms, it returns the same global variable value, if any,
e.g.
\f[V]\[at]__stack_chk_guard\f[R].
.PP
Currently some platforms have IR-level customized stack guard loading
(e.g.
X86 Linux) that is not handled by \f[V]llvm.stackguard()\f[R], while
they should be in the future.
.SS \[aq]\f[V]llvm.objectsize\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 \[at]llvm.objectsize.i32(i8* <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>)
declare i64 \[at]llvm.objectsize.i64(i8* <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.objectsize\f[R] intrinsic is designed to provide
information to the optimizer to determine whether a) an operation (like
memcpy) will overflow a buffer that corresponds to an object, or b) that
a runtime check for overflow isn\[aq]t necessary.
An object in this context means an allocation of a specific class,
structure, array, or other object.
.SS Arguments:
.PP
The \f[V]llvm.objectsize\f[R] intrinsic takes four arguments.
The first argument is a pointer to or into the \f[V]object\f[R].
The second argument determines whether \f[V]llvm.objectsize\f[R] returns
0 (if true) or -1 (if false) when the object size is unknown.
The third argument controls how \f[V]llvm.objectsize\f[R] acts when
\f[V]null\f[R] in address space 0 is used as its pointer argument.
If it\[aq]s \f[V]false\f[R], \f[V]llvm.objectsize\f[R] reports 0 bytes
available when given \f[V]null\f[R].
Otherwise, if the \f[V]null\f[R] is in a non-zero address space or if
\f[V]true\f[R] is given for the third argument of
\f[V]llvm.objectsize\f[R], we assume its size is unknown.
The fourth argument to \f[V]llvm.objectsize\f[R] determines if the value
should be evaluated at runtime.
.PP
The second, third, and fourth arguments only accept constants.
.SS Semantics:
.PP
The \f[V]llvm.objectsize\f[R] intrinsic is lowered to a value
representing the size of the object concerned.
If the size cannot be determined, \f[V]llvm.objectsize\f[R] returns
\f[V]i32/i64 -1 or 0\f[R] (depending on the \f[V]min\f[R] argument).
.SS \[aq]\f[V]llvm.expect\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.expect\f[R] on any integer bit width.
.IP
.nf
\f[C]
declare i1 \[at]llvm.expect.i1(i1 <val>, i1 <expected_val>)
declare i32 \[at]llvm.expect.i32(i32 <val>, i32 <expected_val>)
declare i64 \[at]llvm.expect.i64(i64 <val>, i64 <expected_val>)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.expect\f[R] intrinsic provides information about expected
(the most probable) value of \f[V]val\f[R], which can be used by
optimizers.
.SS Arguments:
.PP
The \f[V]llvm.expect\f[R] intrinsic takes two arguments.
The first argument is a value.
The second argument is an expected value.
.SS Semantics:
.PP
This intrinsic is lowered to the \f[V]val\f[R].
.SS \[aq]\f[V]llvm.expect.with.probability\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This intrinsic is similar to \f[V]llvm.expect\f[R].
This is an overloaded intrinsic.
You can use \f[V]llvm.expect.with.probability\f[R] on any integer bit
width.
.IP
.nf
\f[C]
declare i1 \[at]llvm.expect.with.probability.i1(i1 <val>, i1 <expected_val>, double <prob>)
declare i32 \[at]llvm.expect.with.probability.i32(i32 <val>, i32 <expected_val>, double <prob>)
declare i64 \[at]llvm.expect.with.probability.i64(i64 <val>, i64 <expected_val>, double <prob>)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.expect.with.probability\f[R] intrinsic provides
information about expected value of \f[V]val\f[R] with probability(or
confidence) \f[V]prob\f[R], which can be used by optimizers.
.SS Arguments:
.PP
The \f[V]llvm.expect.with.probability\f[R] intrinsic takes three
arguments.
The first argument is a value.
The second argument is an expected value.
The third argument is a probability.
.SS Semantics:
.PP
This intrinsic is lowered to the \f[V]val\f[R].
.SS \[aq]\f[V]llvm.assume\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.assume(i1 %cond)
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.assume\f[R] allows the optimizer to assume that the
provided condition is true.
This information can then be used in simplifying other parts of the
code.
.PP
More complex assumptions can be encoded as
\f[V]assume operand bundles <assume_opbundles>\f[R].
.SS Arguments:
.PP
The argument of the call is the condition which the optimizer may assume
is always true.
.SS Semantics:
.PP
The intrinsic allows the optimizer to assume that the provided condition
is always true whenever the control flow reaches the intrinsic call.
No code is generated for this intrinsic, and instructions that
contribute only to the provided condition are not used for code
generation.
If the condition is violated during execution, the behavior is
undefined.
.PP
Note that the optimizer might limit the transformations performed on
values used by the \f[V]llvm.assume\f[R] intrinsic in order to preserve
the instructions only used to form the intrinsic\[aq]s input argument.
This might prove undesirable if the extra information provided by the
\f[V]llvm.assume\f[R] intrinsic does not cause sufficient overall
improvement in code quality.
For this reason, \f[V]llvm.assume\f[R] should not be used to document
basic mathematical invariants that the optimizer can otherwise deduce or
facts that are of little use to the optimizer.
.SS \[aq]\f[V]llvm.ssa.copy\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare type \[at]llvm.ssa.copy(type %operand) returned(1) readnone
\f[R]
.fi
.SS Arguments:
.PP
The first argument is an operand which is used as the returned value.
.SS Overview:
.PP
The \f[V]llvm.ssa.copy\f[R] intrinsic can be used to attach information
to operations by copying them and giving them new names.
For example, the PredicateInfo utility uses it to build Extended SSA
form, and attach various forms of information to operands that dominate
specific uses.
It is not meant for general use, only for building temporary renaming
forms that require value splits at certain points.
.SS \[aq]\f[V]llvm.type.test\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i1 \[at]llvm.type.test(i8* %ptr, metadata %type) nounwind readnone
\f[R]
.fi
.SS Arguments:
.PP
The first argument is a pointer to be tested.
The second argument is a metadata object representing a
\f[V]type identifier <TypeMetadata>\f[R].
.SS Overview:
.PP
The \f[V]llvm.type.test\f[R] intrinsic tests whether the given pointer
is associated with the given type identifier.
.SS \[aq]\f[V]llvm.type.checked.load\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare {i8*, i1} \[at]llvm.type.checked.load(i8* %ptr, i32 %offset, metadata %type) argmemonly nounwind readonly
\f[R]
.fi
.SS Arguments:
.PP
The first argument is a pointer from which to load a function pointer.
The second argument is the byte offset from which to load the function
pointer.
The third argument is a metadata object representing a
\f[V]type identifier
<TypeMetadata>\f[R].
.SS Overview:
.PP
The \f[V]llvm.type.checked.load\f[R] intrinsic safely loads a function
pointer from a virtual table pointer using type metadata.
This intrinsic is used to implement control flow integrity in
conjunction with virtual call optimization.
The virtual call optimization pass will optimize away
\f[V]llvm.type.checked.load\f[R] intrinsics associated with
devirtualized calls, thereby removing the type check in cases where it
is not needed to enforce the control flow integrity constraint.
.PP
If the given pointer is associated with a type metadata identifier, this
function returns true as the second element of its return value.
(Note that the function may also return true if the given pointer is not
associated with a type metadata identifier.)
If the function\[aq]s return value\[aq]s second element is true, the
following rules apply to the first element:
.IP \[bu] 2
If the given pointer is associated with the given type metadata
identifier, it is the function pointer loaded from the given byte offset
from the given pointer.
.IP \[bu] 2
If the given pointer is not associated with the given type metadata
identifier, it is one of the following (the choice of which is
unspecified):
.RS 2
.IP "1." 3
The function pointer that would have been loaded from an arbitrarily
chosen (through an unspecified mechanism) pointer associated with the
type metadata.
.IP "2." 3
If the function has a non-void return type, a pointer to a function that
returns an unspecified value without causing side effects.
.RE
.PP
If the function\[aq]s return value\[aq]s second element is false, the
value of the first element is undefined.
.SS \[aq]\f[V]llvm.arithmetic.fence\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.arithmetic.fence(<type> <op>)
\f[R]
.fi
.SS Overview:
.PP
The purpose of the \f[V]llvm.arithmetic.fence\f[R] intrinsic is to
prevent the optimizer from performing fast-math optimizations,
particularly reassociation, between the argument and the expression that
contains the argument.
It can be used to preserve the parentheses in the source language.
.SS Arguments:
.PP
The \f[V]llvm.arithmetic.fence\f[R] intrinsic takes only one argument.
The argument and the return value are floating-point numbers, or vector
floating-point numbers, of the same type.
.SS Semantics:
.PP
This intrinsic returns the value of its operand.
The optimizer can optimize the argument, but the optimizer cannot hoist
any component of the operand to the containing context, and the
optimizer cannot move the calculation of any expression in the
containing context into the operand.
.SS \[aq]\f[V]llvm.donothing\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.donothing() nounwind readnone
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.donothing\f[R] intrinsic doesn\[aq]t perform any
operation.
It\[aq]s one of only three intrinsics (besides
\f[V]llvm.experimental.patchpoint\f[R] and
\f[V]llvm.experimental.gc.statepoint\f[R]) that can be called with an
invoke instruction.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
This intrinsic does nothing, and it\[aq]s removed by optimizers and
ignored by codegen.
.SS \[aq]\f[V]llvm.experimental.deoptimize\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare type \[at]llvm.experimental.deoptimize(...) [ \[dq]deopt\[dq](...) ]
\f[R]
.fi
.SS Overview:
.PP
This intrinsic, together with \f[V]deoptimization operand bundles
<deopt_opbundles>\f[R], allow frontends to express transfer of control
and frame-local state from the currently executing (typically more
specialized, hence faster) version of a function into another (typically
more generic, hence slower) version.
.PP
In languages with a fully integrated managed runtime like Java and
JavaScript this intrinsic can be used to implement \[dq]uncommon
trap\[dq] or \[dq]side exit\[dq] like functionality.
In unmanaged languages like C and C++, this intrinsic can be used to
represent the slow paths of specialized functions.
.SS Arguments:
.PP
The intrinsic takes an arbitrary number of arguments, whose meaning is
decided by the \f[V]lowering strategy<deoptimize_lowering>\f[R].
.SS Semantics:
.PP
The \f[V]\[at]llvm.experimental.deoptimize\f[R] intrinsic executes an
attached deoptimization continuation (denoted using a
\f[V]deoptimization
operand bundle <deopt_opbundles>\f[R]) and returns the value returned by
the deoptimization continuation.
Defining the semantic properties of the continuation itself is out of
scope of the language reference --as far as LLVM is concerned, the
deoptimization continuation can invoke arbitrary side effects, including
reading from and writing to the entire heap.
.PP
Deoptimization continuations expressed using \f[V]\[dq]deopt\[dq]\f[R]
operand bundles always continue execution to the end of the physical
frame containing them, so all calls to
\f[V]\[at]llvm.experimental.deoptimize\f[R] must be in \[dq]tail
position\[dq]:
.RS
.IP \[bu] 2
\f[V]\[at]llvm.experimental.deoptimize\f[R] cannot be invoked.
.IP \[bu] 2
The call must immediately precede a \f[V]ret <i_ret>\f[R] instruction.
.IP \[bu] 2
The \f[V]ret\f[R] instruction must return the value produced by the
\f[V]\[at]llvm.experimental.deoptimize\f[R] call if there is one, or
void.
.RE
.PP
Note that the above restrictions imply that the return type for a call
to \f[V]\[at]llvm.experimental.deoptimize\f[R] will match the return
type of its immediate caller.
.PP
The inliner composes the \f[V]\[dq]deopt\[dq]\f[R] continuations of the
caller into the \f[V]\[dq]deopt\[dq]\f[R] continuations present in the
inlinee, and also updates calls to this intrinsic to return directly
from the frame of the function it inlined into.
.PP
All declarations of \f[V]\[at]llvm.experimental.deoptimize\f[R] must
share the same calling convention.
.SS Lowering:
.PP
Calls to \f[V]\[at]llvm.experimental.deoptimize\f[R] are lowered to
calls to the symbol \f[V]__llvm_deoptimize\f[R] (it is the
frontend\[aq]s responsibility to ensure that this symbol is defined).
The call arguments to \f[V]\[at]llvm.experimental.deoptimize\f[R] are
lowered as if they were formal arguments of the specified types, and not
as varargs.
.SS \[aq]\f[V]llvm.experimental.guard\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.experimental.guard(i1, ...) [ \[dq]deopt\[dq](...) ]
\f[R]
.fi
.SS Overview:
.PP
This intrinsic, together with \f[V]deoptimization operand bundles
<deopt_opbundles>\f[R], allows frontends to express guards or checks on
optimistic assumptions made during compilation.
The semantics of \f[V]\[at]llvm.experimental.guard\f[R] is defined in
terms of \f[V]\[at]llvm.experimental.deoptimize\f[R] -- its body is
defined to be equivalent to:
.IP
.nf
\f[C]
define void \[at]llvm.experimental.guard(i1 %pred, <args...>) {
  %realPred = and i1 %pred, undef
  br i1 %realPred, label %continue, label %leave [, !make.implicit !{}]

leave:
  call void \[at]llvm.experimental.deoptimize(<args...>) [ \[dq]deopt\[dq]() ]
  ret void

continue:
  ret void
}
\f[R]
.fi
.PP
with the optional \f[V][, !make.implicit !{}]\f[R] present if and only
if it is present on the call site.
For more details on \f[V]!make.implicit\f[R], see \f[V]FaultMaps\f[R].
.PP
In words, \f[V]\[at]llvm.experimental.guard\f[R] executes the attached
\f[V]\[dq]deopt\[dq]\f[R] continuation if (but \f[B]not\f[R] only if)
its first argument is \f[V]false\f[R].
Since the optimizer is allowed to replace the \f[V]undef\f[R] with an
arbitrary value, it can optimize guard to fail \[dq]spuriously\[dq],
i.e.
without the original condition being false (hence the \[dq]not only
if\[dq]); and this allows for \[dq]check widening\[dq] type
optimizations.
.PP
\f[V]\[at]llvm.experimental.guard\f[R] cannot be invoked.
.PP
After \f[V]\[at]llvm.experimental.guard\f[R] was first added, a more
general formulation was found in
\f[V]\[at]llvm.experimental.widenable.condition\f[R].
Support for \f[V]\[at]llvm.experimental.guard\f[R] is slowly being
rephrased in terms of this alternate.
.SS \[aq]\f[V]llvm.experimental.widenable.condition\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i1 \[at]llvm.experimental.widenable.condition()
\f[R]
.fi
.SS Overview:
.PP
This intrinsic represents a \[dq]widenable condition\[dq] which is
boolean expressions with the following property: whether this expression
is true or false, the program is correct and well-defined.
.PP
Together with
\f[V]deoptimization operand bundles <deopt_opbundles>\f[R],
\f[V]\[at]llvm.experimental.widenable.condition\f[R] allows frontends to
express guards or checks on optimistic assumptions made during
compilation and represent them as branch instructions on special
conditions.
.PP
While this may appear similar in semantics to undef, it is very
different in that an invocation produces a particular, singular value.
It is also intended to be lowered late, and remain available for
specific optimizations and transforms that can benefit from its special
properties.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
The intrinsic \f[V]\[at]llvm.experimental.widenable.condition()\f[R]
returns either true or false.
For each evaluation of a call to this intrinsic, the program must be
valid and correct both if it returns true and if it returns false.
This allows transformation passes to replace evaluations of this
intrinsic with either value whenever one is beneficial.
.PP
When used in a branch condition, it allows us to choose between two
alternative correct solutions for the same problem, like in example
below:
.IP
.nf
\f[C]
%cond = call i1 \[at]llvm.experimental.widenable.condition()
br i1 %cond, label %solution_1, label %solution_2

label %fast_path:
; Apply memory-consuming but fast solution for a task.

label %slow_path:
; Cheap in memory but slow solution.
\f[R]
.fi
.PP
Whether the result of intrinsic\[aq]s call is true or false, it should
be correct to pick either solution.
We can switch between them by replacing the result of
\f[V]\[at]llvm.experimental.widenable.condition\f[R] with different i1
expressions.
.PP
This is how it can be used to represent guards as widenable branches:
.IP
.nf
\f[C]
block:
  ; Unguarded instructions
  call void \[at]llvm.experimental.guard(i1 %cond, <args...>) [\[dq]deopt\[dq](<deopt_args...>)]
  ; Guarded instructions
\f[R]
.fi
.PP
Can be expressed in an alternative equivalent form of explicit branch
using \f[V]\[at]llvm.experimental.widenable.condition\f[R]:
.IP
.nf
\f[C]
block:
  ; Unguarded instructions
  %widenable_condition = call i1 \[at]llvm.experimental.widenable.condition()
  %guard_condition = and i1 %cond, %widenable_condition
  br i1 %guard_condition, label %guarded, label %deopt

guarded:
  ; Guarded instructions

deopt:
  call type \[at]llvm.experimental.deoptimize(<args...>) [ \[dq]deopt\[dq](<deopt_args...>) ]
\f[R]
.fi
.PP
So the block guarded is only reachable when %cond is true, and it should
be valid to go to the block deopt whenever %cond is true or false.
.PP
\f[V]\[at]llvm.experimental.widenable.condition\f[R] will never throw,
thus it cannot be invoked.
.SS Guard widening:
.PP
When \f[V]\[at]llvm.experimental.widenable.condition()\f[R] is used in
condition of a guard represented as explicit branch, it is legal to
widen the guard\[aq]s condition with any additional conditions.
.PP
Guard widening looks like replacement of
.IP
.nf
\f[C]
%widenable_cond = call i1 \[at]llvm.experimental.widenable.condition()
%guard_cond = and i1 %cond, %widenable_cond
br i1 %guard_cond, label %guarded, label %deopt
\f[R]
.fi
.PP
with
.IP
.nf
\f[C]
%widenable_cond = call i1 \[at]llvm.experimental.widenable.condition()
%new_cond = and i1 %any_other_cond, %widenable_cond
%new_guard_cond = and i1 %cond, %new_cond
br i1 %new_guard_cond, label %guarded, label %deopt
\f[R]
.fi
.PP
for this branch.
Here %any_other_cond is an arbitrarily chosen well-defined i1 value.
By making guard widening, we may impose stricter conditions on guarded
block and bail to the deopt when the new condition is not met.
.SS Lowering:
.PP
Default lowering strategy is replacing the result of call of
\f[V]\[at]llvm.experimental.widenable.condition\f[R] with constant true.
However it is always correct to replace it with any other i1 value.
Any pass can freely do it if it can benefit from non-default lowering.
.SS \[aq]\f[V]llvm.load.relative\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.load.relative.iN(i8* %ptr, iN %offset) argmemonly nounwind readonly
\f[R]
.fi
.SS Overview:
.PP
This intrinsic loads a 32-bit value from the address
\f[V]%ptr + %offset\f[R], adds \f[V]%ptr\f[R] to that value and returns
it.
The constant folder specifically recognizes the form of this intrinsic
and the constant initializers it may load from; if a loaded constant
initializer is known to have the form \f[V]i32 trunc(x - %ptr)\f[R], the
intrinsic call is folded to \f[V]x\f[R].
.PP
LLVM provides that the calculation of such a constant initializer will
not overflow at link time under the medium code model if \f[V]x\f[R] is
an \f[V]unnamed_addr\f[R] function.
However, it does not provide this guarantee for a constant initializer
folded into a function body.
This intrinsic can be used to avoid the possibility of overflows when
loading from such a constant.
.SS \[aq]\f[V]llvm.sideeffect\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.sideeffect() inaccessiblememonly nounwind willreturn
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.sideeffect\f[R] intrinsic doesn\[aq]t perform any
operation.
Optimizers treat it as having side effects, so it can be inserted into a
loop to indicate that the loop shouldn\[aq]t be assumed to terminate
(which could potentially lead to the loop being optimized away
entirely), even if it\[aq]s an infinite loop with no other side effects.
.SS Arguments:
.PP
None.
.SS Semantics:
.PP
This intrinsic actually does nothing, but optimizers must assume that it
has externally observable side effects.
.SS \[aq]\f[V]llvm.is.constant.*\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use llvm.is.constant with any argument type.
.IP
.nf
\f[C]
declare i1 \[at]llvm.is.constant.i32(i32 %operand) nounwind readnone
declare i1 \[at]llvm.is.constant.f32(float %operand) nounwind readnone
declare i1 \[at]llvm.is.constant.TYPENAME(TYPE %operand) nounwind readnone
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.is.constant\f[R]\[aq] intrinsic will return true if
the argument is known to be a manifest compile-time constant.
It is guaranteed to fold to either true or false before generating
machine code.
.SS Semantics:
.PP
This intrinsic generates no code.
If its argument is known to be a manifest compile-time constant value,
then the intrinsic will be converted to a constant true value.
Otherwise, it will be converted to a constant false value.
.PP
In particular, note that if the argument is a constant expression which
refers to a global (the address of which _is a constant, but not
manifest during the compile), then the intrinsic evaluates to false.
.PP
The result also intentionally depends on the result of optimization
passes -- e.g., the result can change depending on whether a function
gets inlined or not.
A function\[aq]s parameters are obviously not constant.
However, a call like \f[V]llvm.is.constant.i32(i32 %param)\f[R]
\f[I]can\f[R] return true after the function is inlined, if the value
passed to the function parameter was a constant.
.PP
On the other hand, if constant folding is not run, it will never
evaluate to true, even in simple cases.
.SS \[aq]\f[V]llvm.ptrmask\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare ptrty llvm.ptrmask(ptrty %ptr, intty %mask) readnone speculatable
\f[R]
.fi
.SS Arguments:
.PP
The first argument is a pointer.
The second argument is an integer.
.SS Overview:
.PP
The \f[V]llvm.ptrmask\f[R] intrinsic masks out bits of the pointer
according to a mask.
This allows stripping data from tagged pointers without converting them
to an integer (ptrtoint/inttoptr).
As a consequence, we can preserve more information to facilitate alias
analysis and underlying-object detection.
.SS Semantics:
.PP
The result of \f[V]ptrmask(ptr, mask)\f[R] is equivalent to
\f[V]getelementptr ptr, (ptrtoint(ptr) & mask) - ptrtoint(ptr)\f[R].
Both the returned pointer and the first argument are based on the same
underlying object (for more information on the \f[I]based on\f[R]
terminology see \f[V]the pointer aliasing rules <pointeraliasing>\f[R]).
If the bitwidth of the mask argument does not match the pointer size of
the target, the mask is zero-extended or truncated accordingly.
.SS \[aq]\f[V]llvm.vscale\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i32 llvm.vscale.i32()
declare i64 llvm.vscale.i64()
\f[R]
.fi
.SS Overview:
.PP
The \f[V]llvm.vscale\f[R] intrinsic returns the value for
\f[V]vscale\f[R] in scalable vectors such as
\f[V]<vscale x 16 x i8>\f[R].
.SS Semantics:
.PP
\f[V]vscale\f[R] is a positive value that is constant throughout program
execution, but is unknown at compile time.
If the result value does not fit in the result type, then the result is
a \f[V]poison value <poisonvalues>\f[R].
.SS Stack Map Intrinsics
.PP
LLVM provides experimental intrinsics to support runtime patching
mechanisms commonly desired in dynamic language JITs.
These intrinsics are described in \f[V]StackMaps\f[R].
.SS Element Wise Atomic Memory Intrinsics
.PP
These intrinsics are similar to the standard library memory intrinsics
except that they perform memory transfer as a sequence of atomic memory
accesses.
.SS \[aq]\f[V]llvm.memcpy.element.unordered.atomic\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memcpy.element.unordered.atomic\f[R] on any
integer bit width and for different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memcpy.element.unordered.atomic.p0i8.p0i8.i32(i8* <dest>,
                                                                 i8* <src>,
                                                                 i32 <len>,
                                                                 i32 <element_size>)
declare void \[at]llvm.memcpy.element.unordered.atomic.p0i8.p0i8.i64(i8* <dest>,
                                                                 i8* <src>,
                                                                 i64 <len>,
                                                                 i32 <element_size>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memcpy.element.unordered.atomic.*\f[R]\[aq] intrinsic
is a specialization of the \[aq]\f[V]llvm.memcpy.*\f[R]\[aq] intrinsic.
It differs in that the \f[V]dest\f[R] and \f[V]src\f[R] are treated as
arrays with elements that are exactly \f[V]element_size\f[R] bytes, and
the copy between buffers uses a sequence of
\f[V]unordered atomic <ordering>\f[R] load/store operations that are a
positive integer multiple of the \f[V]element_size\f[R] in size.
.SS Arguments:
.PP
The first three arguments are the same as they are in the
\f[V]\[at]llvm.memcpy <int_memcpy>\f[R] intrinsic, with the added
constraint that \f[V]len\f[R] is required to be a positive integer
multiple of the \f[V]element_size\f[R].
If \f[V]len\f[R] is not a positive integer multiple of
\f[V]element_size\f[R], then the behaviour of the intrinsic is
undefined.
.PP
\f[V]element_size\f[R] must be a compile-time constant positive power of
two no greater than target-specific atomic access size limit.
.PP
For each of the input pointers \f[V]align\f[R] parameter attribute must
be specified.
It must be a power of two no less than the \f[V]element_size\f[R].
Caller guarantees that both the source and destination pointers are
aligned to that boundary.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memcpy.element.unordered.atomic.*\f[R]\[aq] intrinsic
copies \f[V]len\f[R] bytes of memory from the source location to the
destination location.
These locations are not allowed to overlap.
The memory copy is performed as a sequence of load/store operations
where each access is guaranteed to be a multiple of
\f[V]element_size\f[R] bytes wide and aligned at an
\f[V]element_size\f[R] boundary.
.PP
The order of the copy is unspecified.
The same value may be read from the source buffer many times, but only
one write is issued to the destination buffer per element.
It is well defined to have concurrent reads and writes to both source
and destination provided those reads and writes are unordered atomic
when specified.
.PP
This intrinsic does not provide any additional ordering guarantees over
those provided by a set of unordered loads from the source location and
stores to the destination.
.SS Lowering:
.PP
In the most general case call to the
\[aq]\f[V]llvm.memcpy.element.unordered.atomic.*\f[R]\[aq] is lowered to
a call to the symbol \f[V]__llvm_memcpy_element_unordered_atomic_*\f[R].
Where \[aq]*\[aq] is replaced with an actual element size.
See \f[V]RewriteStatepointsForGC intrinsic
lowering <RewriteStatepointsForGC_intrinsic_lowering>\f[R] for details
on GC specific lowering.
.PP
Optimizer is allowed to inline memory copy when it\[aq]s profitable to
do so.
.SS \[aq]\f[V]llvm.memmove.element.unordered.atomic\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memmove.element.unordered.atomic\f[R] on any
integer bit width and for different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memmove.element.unordered.atomic.p0i8.p0i8.i32(i8* <dest>,
                                                                  i8* <src>,
                                                                  i32 <len>,
                                                                  i32 <element_size>)
declare void \[at]llvm.memmove.element.unordered.atomic.p0i8.p0i8.i64(i8* <dest>,
                                                                  i8* <src>,
                                                                  i64 <len>,
                                                                  i32 <element_size>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memmove.element.unordered.atomic.*\f[R]\[aq]
intrinsic is a specialization of the \[aq]\f[V]llvm.memmove.*\f[R]\[aq]
intrinsic.
It differs in that the \f[V]dest\f[R] and \f[V]src\f[R] are treated as
arrays with elements that are exactly \f[V]element_size\f[R] bytes, and
the copy between buffers uses a sequence of
\f[V]unordered atomic <ordering>\f[R] load/store operations that are a
positive integer multiple of the \f[V]element_size\f[R] in size.
.SS Arguments:
.PP
The first three arguments are the same as they are in the
\f[V]\[at]llvm.memmove <int_memmove>\f[R] intrinsic, with the added
constraint that \f[V]len\f[R] is required to be a positive integer
multiple of the \f[V]element_size\f[R].
If \f[V]len\f[R] is not a positive integer multiple of
\f[V]element_size\f[R], then the behaviour of the intrinsic is
undefined.
.PP
\f[V]element_size\f[R] must be a compile-time constant positive power of
two no greater than a target-specific atomic access size limit.
.PP
For each of the input pointers the \f[V]align\f[R] parameter attribute
must be specified.
It must be a power of two no less than the \f[V]element_size\f[R].
Caller guarantees that both the source and destination pointers are
aligned to that boundary.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memmove.element.unordered.atomic.*\f[R]\[aq]
intrinsic copies \f[V]len\f[R] bytes of memory from the source location
to the destination location.
These locations are allowed to overlap.
The memory copy is performed as a sequence of load/store operations
where each access is guaranteed to be a multiple of
\f[V]element_size\f[R] bytes wide and aligned at an
\f[V]element_size\f[R] boundary.
.PP
The order of the copy is unspecified.
The same value may be read from the source buffer many times, but only
one write is issued to the destination buffer per element.
It is well defined to have concurrent reads and writes to both source
and destination provided those reads and writes are unordered atomic
when specified.
.PP
This intrinsic does not provide any additional ordering guarantees over
those provided by a set of unordered loads from the source location and
stores to the destination.
.SS Lowering:
.PP
In the most general case call to the
\[aq]\f[V]llvm.memmove.element.unordered.atomic.*\f[R]\[aq] is lowered
to a call to the symbol
\f[V]__llvm_memmove_element_unordered_atomic_*\f[R].
Where \[aq]*\[aq] is replaced with an actual element size.
See \f[V]RewriteStatepointsForGC intrinsic lowering
<RewriteStatepointsForGC_intrinsic_lowering>\f[R] for details on GC
specific lowering.
.PP
The optimizer is allowed to inline the memory copy when it\[aq]s
profitable to do so.
.SS \[aq]\f[V]llvm.memset.element.unordered.atomic\f[R]\[aq] Intrinsic
.SS Syntax:
.PP
This is an overloaded intrinsic.
You can use \f[V]llvm.memset.element.unordered.atomic\f[R] on any
integer bit width and for different address spaces.
Not all targets support all bit widths however.
.IP
.nf
\f[C]
declare void \[at]llvm.memset.element.unordered.atomic.p0i8.i32(i8* <dest>,
                                                            i8 <value>,
                                                            i32 <len>,
                                                            i32 <element_size>)
declare void \[at]llvm.memset.element.unordered.atomic.p0i8.i64(i8* <dest>,
                                                            i8 <value>,
                                                            i64 <len>,
                                                            i32 <element_size>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.memset.element.unordered.atomic.*\f[R]\[aq] intrinsic
is a specialization of the \[aq]\f[V]llvm.memset.*\f[R]\[aq] intrinsic.
It differs in that the \f[V]dest\f[R] is treated as an array with
elements that are exactly \f[V]element_size\f[R] bytes, and the
assignment to that array uses uses a sequence of
\f[V]unordered atomic <ordering>\f[R] store operations that are a
positive integer multiple of the \f[V]element_size\f[R] in size.
.SS Arguments:
.PP
The first three arguments are the same as they are in the
\f[V]\[at]llvm.memset <int_memset>\f[R] intrinsic, with the added
constraint that \f[V]len\f[R] is required to be a positive integer
multiple of the \f[V]element_size\f[R].
If \f[V]len\f[R] is not a positive integer multiple of
\f[V]element_size\f[R], then the behaviour of the intrinsic is
undefined.
.PP
\f[V]element_size\f[R] must be a compile-time constant positive power of
two no greater than target-specific atomic access size limit.
.PP
The \f[V]dest\f[R] input pointer must have the \f[V]align\f[R] parameter
attribute specified.
It must be a power of two no less than the \f[V]element_size\f[R].
Caller guarantees that the destination pointer is aligned to that
boundary.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.memset.element.unordered.atomic.*\f[R]\[aq] intrinsic
sets the \f[V]len\f[R] bytes of memory starting at the destination
location to the given \f[V]value\f[R].
The memory is set with a sequence of store operations where each access
is guaranteed to be a multiple of \f[V]element_size\f[R] bytes wide and
aligned at an \f[V]element_size\f[R] boundary.
.PP
The order of the assignment is unspecified.
Only one write is issued to the destination buffer per element.
It is well defined to have concurrent reads and writes to the
destination provided those reads and writes are unordered atomic when
specified.
.PP
This intrinsic does not provide any additional ordering guarantees over
those provided by a set of unordered stores to the destination.
.SS Lowering:
.PP
In the most general case call to the
\[aq]\f[V]llvm.memset.element.unordered.atomic.*\f[R]\[aq] is lowered to
a call to the symbol \f[V]__llvm_memset_element_unordered_atomic_*\f[R].
Where \[aq]*\[aq] is replaced with an actual element size.
.PP
The optimizer is allowed to inline the memory assignment when it\[aq]s
profitable to do so.
.SS Objective-C ARC Runtime Intrinsics
.PP
LLVM provides intrinsics that lower to Objective-C ARC runtime entry
points.
LLVM is aware of the semantics of these functions, and optimizes based
on that knowledge.
You can read more about the details of Objective-C ARC
here (https://clang.llvm.org/docs/AutomaticReferenceCounting.html).
.SS \[aq]\f[V]llvm.objc.autorelease\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.autorelease(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_autorelease (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autorelease).
.SS \[aq]\f[V]llvm.objc.autoreleasePoolPop\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.autoreleasePoolPop(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_autoreleasePoolPop (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-autoreleasepoolpop-void-pool).
.SS \[aq]\f[V]llvm.objc.autoreleasePoolPush\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.autoreleasePoolPush()
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_autoreleasePoolPush (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-autoreleasepoolpush-void).
.SS \[aq]\f[V]llvm.objc.autoreleaseReturnValue\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.autoreleaseReturnValue(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_autoreleaseReturnValue (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue).
.SS \[aq]\f[V]llvm.objc.copyWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.copyWeak(i8**, i8**)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_copyWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-copyweak-id-dest-id-src).
.SS \[aq]\f[V]llvm.objc.destroyWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.destroyWeak(i8**)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_destroyWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-destroyweak-id-object).
.SS \[aq]\f[V]llvm.objc.initWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.initWeak(i8**, i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_initWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-initweak).
.SS \[aq]\f[V]llvm.objc.loadWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.loadWeak(i8**)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_loadWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak).
.SS \[aq]\f[V]llvm.objc.loadWeakRetained\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.loadWeakRetained(i8**)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_loadWeakRetained (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained).
.SS \[aq]\f[V]llvm.objc.moveWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.moveWeak(i8**, i8**)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_moveWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-moveweak-id-dest-id-src).
.SS \[aq]\f[V]llvm.objc.release\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.release(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_release (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-release-id-value).
.SS \[aq]\f[V]llvm.objc.retain\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.retain(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_retain (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain).
.SS \[aq]\f[V]llvm.objc.retainAutorelease\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.retainAutorelease(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_retainAutorelease (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease).
.SS \[aq]\f[V]llvm.objc.retainAutoreleaseReturnValue\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.retainAutoreleaseReturnValue(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_retainAutoreleaseReturnValue (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasereturnvalue).
.SS \[aq]\f[V]llvm.objc.retainAutoreleasedReturnValue\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.retainAutoreleasedReturnValue(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_retainAutoreleasedReturnValue (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasedreturnvalue).
.SS \[aq]\f[V]llvm.objc.retainBlock\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.retainBlock(i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_retainBlock (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainblock).
.SS \[aq]\f[V]llvm.objc.storeStrong\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare void \[at]llvm.objc.storeStrong(i8**, i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_storeStrong (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-storestrong-id-object-id-value).
.SS \[aq]\f[V]llvm.objc.storeWeak\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare i8* \[at]llvm.objc.storeWeak(i8**, i8*)
\f[R]
.fi
.SS Lowering:
.PP
Lowers to a call to
objc_storeWeak (https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak).
.SS Preserving Debug Information Intrinsics
.PP
These intrinsics are used to carry certain debuginfo together with
IR-level operations.
For example, it may be desirable to know the structure/union name and
the original user-level field indices.
Such information got lost in IR GetElementPtr instruction since the IR
types are different from debugInfo types and unions are converted to
structs in IR.
.SS \[aq]\f[V]llvm.preserve.array.access.index\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ret_type>
\[at]llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,
                                                                     i32 dim,
                                                                     i32 index)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.preserve.array.access.index\f[R]\[aq] intrinsic
returns the getelementptr address based on array base \f[V]base\f[R],
array dimension \f[V]dim\f[R] and the last access index \f[V]index\f[R]
into the array.
The return type \f[V]ret_type\f[R] is a pointer type to the array
element.
The array \f[V]dim\f[R] and \f[V]index\f[R] are preserved which is more
robust than getelementptr instruction which may be subject to compiler
transformation.
The \f[V]llvm.preserve.access.index\f[R] type of metadata is attached to
this call instruction to provide array or pointer debuginfo type.
The metadata is a \f[V]DICompositeType\f[R] or \f[V]DIDerivedType\f[R]
representing the debuginfo version of \f[V]type\f[R].
.SS Arguments:
.PP
The \f[V]base\f[R] is the array base address.
The \f[V]dim\f[R] is the array dimension.
The \f[V]base\f[R] is a pointer if \f[V]dim\f[R] equals 0.
The \f[V]index\f[R] is the last access index into the array or pointer.
.PP
The \f[V]base\f[R] argument must be annotated with an \f[V]elementtype
<attr_elementtype>\f[R] attribute at the call-site.
This attribute specifies the getelementptr element type.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.preserve.array.access.index\f[R]\[aq] intrinsic
produces the same result as a getelementptr with base \f[V]base\f[R] and
access operands \f[V]{dim\[aq]s 0\[aq]s, index}\f[R].
.SS \[aq]\f[V]llvm.preserve.union.access.index\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <type>
\[at]llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,
                                                                  i32 di_index)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.preserve.union.access.index\f[R]\[aq] intrinsic
carries the debuginfo field index \f[V]di_index\f[R] and returns the
\f[V]base\f[R] address.
The \f[V]llvm.preserve.access.index\f[R] type of metadata is attached to
this call instruction to provide union debuginfo type.
The metadata is a \f[V]DICompositeType\f[R] representing the debuginfo
version of \f[V]type\f[R].
The return type \f[V]type\f[R] is the same as the \f[V]base\f[R] type.
.SS Arguments:
.PP
The \f[V]base\f[R] is the union base address.
The \f[V]di_index\f[R] is the field index in debuginfo.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.preserve.union.access.index\f[R]\[aq] intrinsic
returns the \f[V]base\f[R] address.
.SS \[aq]\f[V]llvm.preserve.struct.access.index\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ret_type>
\[at]llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,
                                                           i32 gep_index,
                                                           i32 di_index)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.preserve.struct.access.index\f[R]\[aq] intrinsic
returns the getelementptr address based on struct base \f[V]base\f[R]
and IR struct member index \f[V]gep_index\f[R].
The \f[V]llvm.preserve.access.index\f[R] type of metadata is attached to
this call instruction to provide struct debuginfo type.
The metadata is a \f[V]DICompositeType\f[R] representing the debuginfo
version of \f[V]type\f[R].
The return type \f[V]ret_type\f[R] is a pointer type to the structure
member.
.SS Arguments:
.PP
The \f[V]base\f[R] is the structure base address.
The \f[V]gep_index\f[R] is the struct member index based on IR
structures.
The \f[V]di_index\f[R] is the struct member index based on debuginfo.
.PP
The \f[V]base\f[R] argument must be annotated with an \f[V]elementtype
<attr_elementtype>\f[R] attribute at the call-site.
This attribute specifies the getelementptr element type.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.preserve.struct.access.index\f[R]\[aq] intrinsic
produces the same result as a getelementptr with base \f[V]base\f[R] and
access operands \f[V]{0, gep_index}\f[R].
.SS \[aq]\f[V]llvm.fptrunc.round\f[R]\[aq] Intrinsic
.SS Syntax:
.IP
.nf
\f[C]
declare <ty2>
\[at]llvm.fptrunc.round(<type> <value>, metadata <rounding mode>)
\f[R]
.fi
.SS Overview:
.PP
The \[aq]\f[V]llvm.fptrunc.round\f[R]\[aq] intrinsic truncates
\f[V]floating-point <t_floating>\f[R] \f[V]value\f[R] to type
\f[V]ty2\f[R] with a specified rounding mode.
.SS Arguments:
.PP
The \[aq]\f[V]llvm.fptrunc.round\f[R]\[aq] intrinsic takes a
\f[V]floating-point
<t_floating>\f[R] value to cast and a
\f[V]floating-point <t_floating>\f[R] type to cast it to.
This argument must be larger in size than the result.
.PP
The second argument specifies the rounding mode as described in the
constrained intrinsics section.
For this intrinsic, the \[dq]round.dynamic\[dq] mode is not supported.
.SS Semantics:
.PP
The \[aq]\f[V]llvm.fptrunc.round\f[R]\[aq] intrinsic casts a
\f[V]value\f[R] from a larger \f[V]floating-point <t_floating>\f[R] type
to a smaller \f[V]floating-point
<t_floating>\f[R] type.
This intrinsic is assumed to execute in the default \f[V]floating-point
environment <floatenv>\f[R] \f[I]except\f[R] for the rounding mode.
This intrinsic is not supported on all targets.
Some targets may not support all rounding modes.
